function rr(e) { return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e } (() => { var e = document.createElement("link").relList; if (!(e && e.supports && e.supports("modulepreload"))) { for (var t of document.querySelectorAll('link[rel="modulepreload"]')) i(t); new MutationObserver(e => { for (var t of e) if ("childList" === t.type) for (var r of t.addedNodes) "LINK" === r.tagName && "modulepreload" === r.rel && i(r) }).observe(document, { childList: !0, subtree: !0 }) } function i(e) { var t, r; e.ep || (e.ep = !0, r = {}, (t = e).integrity && (r.integrity = t.integrity), t.referrerPolicy && (r.referrerPolicy = t.referrerPolicy), "use-credentials" === t.crossOrigin ? r.credentials = "include" : "anonymous" === t.crossOrigin ? r.credentials = "omit" : r.credentials = "same-origin", fetch(e.href, r)) } })(); var ai = { exports: {} }, ze = ((() => { var t, a, r, i, n; t = /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/, a = /^(?=([^\/?#]*))\1([^]*)$/, r = /(?:\/|^)\.(?=\/)/g, i = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g, n = { buildAbsoluteURL: function (e, t, r) { if (r = r || {}, e = e.trim(), !(t = t.trim())) { if (!r.alwaysNormalize) return e; var i = n.parseURL(e); if (i) return i.path = n.normalizePath(i.path), n.buildURLFromParts(i); throw new Error("Error trying to parse base URL.") } i = n.parseURL(t); if (!i) throw new Error("Error trying to parse relative URL."); if (i.scheme) return r.alwaysNormalize ? (i.path = n.normalizePath(i.path), n.buildURLFromParts(i)) : t; t = n.parseURL(e); if (!t) throw new Error("Error trying to parse base URL."); !t.netLoc && t.path && "/" !== t.path[0] && (e = a.exec(t.path), t.netLoc = e[1], t.path = e[2]), t.netLoc && !t.path && (t.path = "/"); var s, e = { scheme: t.scheme, netLoc: i.netLoc, path: null, params: i.params, query: i.query, fragment: i.fragment }; return i.netLoc || (e.netLoc = t.netLoc, "/" === i.path[0]) || (i.path ? (s = (s = t.path).substring(0, s.lastIndexOf("/") + 1) + i.path, e.path = n.normalizePath(s)) : (e.path = t.path, i.params || (e.params = t.params, i.query) || (e.query = t.query))), null === e.path && (e.path = r.alwaysNormalize ? n.normalizePath(i.path) : i.path), n.buildURLFromParts(e) }, parseURL: function (e) { e = t.exec(e); return e ? { scheme: e[1] || "", netLoc: e[2] || "", path: e[3] || "", params: e[4] || "", query: e[5] || "", fragment: e[6] || "" } : null }, normalizePath: function (e) { for (e = e.split("").reverse().join("").replace(r, ""); e.length !== (e = e.replace(i, "")).length;); return e.split("").reverse().join("") }, buildURLFromParts: function (e) { return e.scheme + e.netLoc + e.path + e.params + e.query + e.fragment } }, ai.exports = n })(), ai.exports); function us(t, e) { var r, i = Object.keys(t); return Object.getOwnPropertySymbols && (r = Object.getOwnPropertySymbols(t), e && (r = r.filter(function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable })), i.push.apply(i, r)), i } function ct(t) { for (var e = 1; e < arguments.length; e++) { var r = null != arguments[e] ? arguments[e] : {}; e % 2 ? us(Object(r), !0).forEach(function (e) { nr(t, e, r[e]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : us(Object(r)).forEach(function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(r, e)) }) } return t } function nr(e, t, r) { return (t = or(t)) in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e } function tt() { return (tt = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var r, i = arguments[t]; for (r in i) Object.prototype.hasOwnProperty.call(i, r) && (e[r] = i[r]) } return e }).apply(this, arguments) } function ar(e, t) { if ("object" != typeof e || null === e) return e; var r = e[Symbol.toPrimitive]; if (void 0 === r) return ("string" === t ? String : Number)(e); r = r.call(e, t || "default"); if ("object" != typeof r) return r; throw new TypeError("@@toPrimitive must return a primitive value.") } function or(e) { e = ar(e, "string"); return "symbol" == typeof e ? e : String(e) } let F = Number.isFinite || function (e) { return "number" == typeof e && isFinite(e) }, m = (e => (e.MEDIA_ATTACHING = "hlsMediaAttaching", e.MEDIA_ATTACHED = "hlsMediaAttached", e.MEDIA_DETACHING = "hlsMediaDetaching", e.MEDIA_DETACHED = "hlsMediaDetached", e.BUFFER_RESET = "hlsBufferReset", e.BUFFER_CODECS = "hlsBufferCodecs", e.BUFFER_CREATED = "hlsBufferCreated", e.BUFFER_APPENDING = "hlsBufferAppending", e.BUFFER_APPENDED = "hlsBufferAppended", e.BUFFER_EOS = "hlsBufferEos", e.BUFFER_FLUSHING = "hlsBufferFlushing", e.BUFFER_FLUSHED = "hlsBufferFlushed", e.MANIFEST_LOADING = "hlsManifestLoading", e.MANIFEST_LOADED = "hlsManifestLoaded", e.MANIFEST_PARSED = "hlsManifestParsed", e.LEVEL_SWITCHING = "hlsLevelSwitching", e.LEVEL_SWITCHED = "hlsLevelSwitched", e.LEVEL_LOADING = "hlsLevelLoading", e.LEVEL_LOADED = "hlsLevelLoaded", e.LEVEL_UPDATED = "hlsLevelUpdated", e.LEVEL_PTS_UPDATED = "hlsLevelPtsUpdated", e.LEVELS_UPDATED = "hlsLevelsUpdated", e.AUDIO_TRACKS_UPDATED = "hlsAudioTracksUpdated", e.AUDIO_TRACK_SWITCHING = "hlsAudioTrackSwitching", e.AUDIO_TRACK_SWITCHED = "hlsAudioTrackSwitched", e.AUDIO_TRACK_LOADING = "hlsAudioTrackLoading", e.AUDIO_TRACK_LOADED = "hlsAudioTrackLoaded", e.SUBTITLE_TRACKS_UPDATED = "hlsSubtitleTracksUpdated", e.SUBTITLE_TRACKS_CLEARED = "hlsSubtitleTracksCleared", e.SUBTITLE_TRACK_SWITCH = "hlsSubtitleTrackSwitch", e.SUBTITLE_TRACK_LOADING = "hlsSubtitleTrackLoading", e.SUBTITLE_TRACK_LOADED = "hlsSubtitleTrackLoaded", e.SUBTITLE_FRAG_PROCESSED = "hlsSubtitleFragProcessed", e.CUES_PARSED = "hlsCuesParsed", e.NON_NATIVE_TEXT_TRACKS_FOUND = "hlsNonNativeTextTracksFound", e.INIT_PTS_FOUND = "hlsInitPtsFound", e.FRAG_LOADING = "hlsFragLoading", e.FRAG_LOAD_EMERGENCY_ABORTED = "hlsFragLoadEmergencyAborted", e.FRAG_LOADED = "hlsFragLoaded", e.FRAG_DECRYPTED = "hlsFragDecrypted", e.FRAG_PARSING_INIT_SEGMENT = "hlsFragParsingInitSegment", e.FRAG_PARSING_USERDATA = "hlsFragParsingUserdata", e.FRAG_PARSING_METADATA = "hlsFragParsingMetadata", e.FRAG_PARSED = "hlsFragParsed", e.FRAG_BUFFERED = "hlsFragBuffered", e.FRAG_CHANGED = "hlsFragChanged", e.FPS_DROP = "hlsFpsDrop", e.FPS_DROP_LEVEL_CAPPING = "hlsFpsDropLevelCapping", e.ERROR = "hlsError", e.DESTROYING = "hlsDestroying", e.KEY_LOADING = "hlsKeyLoading", e.KEY_LOADED = "hlsKeyLoaded", e.LIVE_BACK_BUFFER_REACHED = "hlsLiveBackBufferReached", e.BACK_BUFFER_REACHED = "hlsBackBufferReached", e))({}), N = (e => (e.NETWORK_ERROR = "networkError", e.MEDIA_ERROR = "mediaError", e.KEY_SYSTEM_ERROR = "keySystemError", e.MUX_ERROR = "muxError", e.OTHER_ERROR = "otherError", e))({}), L = (e => (e.KEY_SYSTEM_NO_KEYS = "keySystemNoKeys", e.KEY_SYSTEM_NO_ACCESS = "keySystemNoAccess", e.KEY_SYSTEM_NO_SESSION = "keySystemNoSession", e.KEY_SYSTEM_NO_CONFIGURED_LICENSE = "keySystemNoConfiguredLicense", e.KEY_SYSTEM_LICENSE_REQUEST_FAILED = "keySystemLicenseRequestFailed", e.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED = "keySystemServerCertificateRequestFailed", e.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED = "keySystemServerCertificateUpdateFailed", e.KEY_SYSTEM_SESSION_UPDATE_FAILED = "keySystemSessionUpdateFailed", e.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED = "keySystemStatusOutputRestricted", e.KEY_SYSTEM_STATUS_INTERNAL_ERROR = "keySystemStatusInternalError", e.MANIFEST_LOAD_ERROR = "manifestLoadError", e.MANIFEST_LOAD_TIMEOUT = "manifestLoadTimeOut", e.MANIFEST_PARSING_ERROR = "manifestParsingError", e.MANIFEST_INCOMPATIBLE_CODECS_ERROR = "manifestIncompatibleCodecsError", e.LEVEL_EMPTY_ERROR = "levelEmptyError", e.LEVEL_LOAD_ERROR = "levelLoadError", e.LEVEL_LOAD_TIMEOUT = "levelLoadTimeOut", e.LEVEL_PARSING_ERROR = "levelParsingError", e.LEVEL_SWITCH_ERROR = "levelSwitchError", e.AUDIO_TRACK_LOAD_ERROR = "audioTrackLoadError", e.AUDIO_TRACK_LOAD_TIMEOUT = "audioTrackLoadTimeOut", e.SUBTITLE_LOAD_ERROR = "subtitleTrackLoadError", e.SUBTITLE_TRACK_LOAD_TIMEOUT = "subtitleTrackLoadTimeOut", e.FRAG_LOAD_ERROR = "fragLoadError", e.FRAG_LOAD_TIMEOUT = "fragLoadTimeOut", e.FRAG_DECRYPT_ERROR = "fragDecryptError", e.FRAG_PARSING_ERROR = "fragParsingError", e.FRAG_GAP = "fragGap", e.REMUX_ALLOC_ERROR = "remuxAllocError", e.KEY_LOAD_ERROR = "keyLoadError", e.KEY_LOAD_TIMEOUT = "keyLoadTimeOut", e.BUFFER_ADD_CODEC_ERROR = "bufferAddCodecError", e.BUFFER_INCOMPATIBLE_CODECS_ERROR = "bufferIncompatibleCodecsError", e.BUFFER_APPEND_ERROR = "bufferAppendError", e.BUFFER_APPENDING_ERROR = "bufferAppendingError", e.BUFFER_STALLED_ERROR = "bufferStalledError", e.BUFFER_FULL_ERROR = "bufferFullError", e.BUFFER_SEEK_OVER_HOLE = "bufferSeekOverHole", e.BUFFER_NUDGE_ON_STALL = "bufferNudgeOnStall", e.INTERNAL_EXCEPTION = "internalException", e.INTERNAL_ABORTED = "aborted", e.UNKNOWN = "unknown", e))({}), _t = function () { }, Be = { trace: _t, debug: _t, log: _t, warn: _t, info: _t, error: _t }, Ht = Be; function lr(e) { var t = self.console[e]; return t ? t.bind(self.console, `[${e}] >`) : _t } function cr(t, ...e) { e.forEach(function (e) { Ht[e] = t[e] ? t[e].bind(t) : lr(e) }) } function hr(e, t) { if (self.console && !0 === e || "object" == typeof e) { cr(e, "debug", "log", "info", "warn", "error"); try { Ht.log(`Debug logs enabled for "${t}" in hls.js version 1.4.4`) } catch { Ht = Be } } else Ht = Be } let E = Ht, dr = /^(\d+)x(\d+)$/, fs = /(.+?)=(".*?"|.*?)(?:,|$)/g; class Q { constructor(e) { for (var t in e = "string" == typeof e ? Q.parseAttrList(e) : e) e.hasOwnProperty(t) && ("X-" === t.substring(0, 2) && (this.clientAttrs = this.clientAttrs || [], this.clientAttrs.push(t)), this[t] = e[t]) } decimalInteger(e) { e = parseInt(this[e], 10); return e > Number.MAX_SAFE_INTEGER ? 1 / 0 : e } hexadecimalInteger(e) { if (this[e]) { var t = (1 & (t = (this[e] || "0x").slice(2)).length ? "0" : "") + t, r = new Uint8Array(t.length / 2); for (let e = 0; e < t.length / 2; e++)r[e] = parseInt(t.slice(2 * e, 2 * e + 2), 16); return r } return null } hexadecimalIntegerAsNumber(e) { e = parseInt(this[e], 16); return e > Number.MAX_SAFE_INTEGER ? 1 / 0 : e } decimalFloatingPoint(e) { return parseFloat(this[e]) } optionalFloat(e, t) { e = this[e]; return e ? parseFloat(e) : t } enumeratedString(e) { return this[e] } bool(e) { return "YES" === this[e] } decimalResolution(e) { e = dr.exec(this[e]); if (null !== e) return { width: parseInt(e[1], 10), height: parseInt(e[2], 10) } } static parseAttrList(e) { var t, r = {}; for (fs.lastIndex = 0; null !== (t = fs.exec(e));) { let e = t[2]; 0 === e.indexOf('"') && e.lastIndexOf('"') === e.length - 1 && (e = e.slice(1, -1)), r[t[1].trim()] = e } return r } } function ur(e) { return "ID" !== e && "CLASS" !== e && "START-DATE" !== e && "DURATION" !== e && "END-DATE" !== e && "END-ON-NEXT" !== e } function fr(e) { return "SCTE35-OUT" === e || "SCTE35-IN" === e } class oi { constructor(e, t) { if (this.attr = void 0, this._startDate = void 0, this._endDate = void 0, this._badValueForSameId = void 0, t) { var r, i = t.attr; for (r in i) if (Object.prototype.hasOwnProperty.call(e, r) && e[r] !== i[r]) { E.warn(`DATERANGE tag attribute: "${r}" does not match for tags with ID: "${e.ID}"`), this._badValueForSameId = r; break } e = tt(new Q({}), i, e) } this.attr = e, this._startDate = new Date(e["START-DATE"]), "END-DATE" in this.attr && (t = new Date(this.attr["END-DATE"]), F(t.getTime())) && (this._endDate = t) } get id() { return this.attr.ID } get class() { return this.attr.CLASS } get startDate() { return this._startDate } get endDate() { var e; return this._endDate || (null !== (e = this.duration) ? new Date(this._startDate.getTime() + 1e3 * e) : null) } get duration() { if ("DURATION" in this.attr) { var e = this.attr.decimalFloatingPoint("DURATION"); if (F(e)) return e } else if (this._endDate) return (this._endDate.getTime() - this._startDate.getTime()) / 1e3; return null } get plannedDuration() { return "PLANNED-DURATION" in this.attr ? this.attr.decimalFloatingPoint("PLANNED-DURATION") : null } get endOnNext() { return this.attr.bool("END-ON-NEXT") } get isValid() { return !!this.id && !this._badValueForSameId && F(this.startDate.getTime()) && (null === this.duration || 0 <= this.duration) && (!this.endOnNext || !!this.class) } } class de { constructor() { this.aborted = !1, this.loaded = 0, this.retry = 0, this.total = 0, this.chunkCount = 0, this.bwEstimate = 0, this.loading = { start: 0, first: 0, end: 0 }, this.parsing = { start: 0, end: 0 }, this.buffering = { start: 0, first: 0, end: 0 } } } var H = { AUDIO: "audio", VIDEO: "video", AUDIOVIDEO: "audiovideo" }; class li { constructor(e) { this._byteRange = null, this._url = null, this.baseurl = void 0, this.relurl = void 0, this.elementaryStreams = { [H.AUDIO]: null, [H.VIDEO]: null, [H.AUDIOVIDEO]: null }, this.baseurl = e } setByteRange(e, t) { var e = e.split("@", 2), r = []; 1 === e.length ? r[0] = t ? t.byteRangeEndOffset : 0 : r[0] = parseInt(e[1]), r[1] = parseInt(e[0]) + r[0], this._byteRange = r } get byteRange() { return this._byteRange || [] } get byteRangeStartOffset() { return this.byteRange[0] } get byteRangeEndOffset() { return this.byteRange[1] } get url() { return !this._url && this.baseurl && this.relurl && (this._url = ze.buildAbsoluteURL(this.baseurl, this.relurl, { alwaysNormalize: !0 })), this._url || "" } set url(e) { this._url = e } } class me extends li { constructor(e, t) { super(t), this._decryptdata = null, this.rawProgramDateTime = null, this.programDateTime = null, this.tagList = [], this.duration = 0, this.sn = 0, this.levelkeys = void 0, this.type = void 0, this.loader = null, this.keyLoader = null, this.level = -1, this.cc = 0, this.startPTS = void 0, this.endPTS = void 0, this.startDTS = void 0, this.endDTS = void 0, this.start = 0, this.deltaPTS = void 0, this.maxStartPTS = void 0, this.minEndPTS = void 0, this.stats = new de, this.urlId = 0, this.data = void 0, this.bitrateTest = !1, this.title = null, this.initSegment = null, this.endList = void 0, this.gap = void 0, this.type = e } get decryptdata() { var e = this.levelkeys; if (!e && !this._decryptdata) return null; if (!this._decryptdata && this.levelkeys && !this.levelkeys.NONE) { e = this.levelkeys.identity; if (e) this._decryptdata = e.getDecryptData(this.sn); else { e = Object.keys(this.levelkeys); if (1 === e.length) return this._decryptdata = this.levelkeys[e[0]].getDecryptData(this.sn) } } return this._decryptdata } get end() { return this.start + this.duration } get endProgramDateTime() { var e; return null !== this.programDateTime && F(this.programDateTime) ? (e = F(this.duration) ? this.duration : 0, this.programDateTime + 1e3 * e) : null } get encrypted() { if (null != (e = this._decryptdata) && e.encrypted) return !0; if (this.levelkeys) { var e = Object.keys(this.levelkeys), t = e.length; if (1 < t || 1 === t && this.levelkeys[e[0]].encrypted) return !0 } return !1 } setKeyFormat(e) { this.levelkeys && (e = this.levelkeys[e]) && !this._decryptdata && (this._decryptdata = e.getDecryptData(this.sn)) } abortRequests() { var e; null != (e = this.loader) && e.abort(), null != (e = this.keyLoader) && e.abort() } setElementaryStreamInfo(e, t, r, i, s, a = !1) { var n = this.elementaryStreams, o = n[e]; o ? (o.startPTS = Math.min(o.startPTS, t), o.endPTS = Math.max(o.endPTS, r), o.startDTS = Math.min(o.startDTS, i), o.endDTS = Math.max(o.endDTS, s)) : n[e] = { startPTS: t, endPTS: r, startDTS: i, endDTS: s, partial: a } } clearElementaryStreamInfo() { var e = this.elementaryStreams; e[H.AUDIO] = null, e[H.VIDEO] = null, e[H.AUDIOVIDEO] = null } } class gr extends li { constructor(e, t, r, i, s) { super(r), this.fragOffset = 0, this.duration = 0, this.gap = !1, this.independent = !1, this.relurl = void 0, this.fragment = void 0, this.index = void 0, this.stats = new de, this.duration = e.decimalFloatingPoint("DURATION"), this.gap = e.bool("GAP"), this.independent = e.bool("INDEPENDENT"), this.relurl = e.enumeratedString("URI"), this.fragment = t, this.index = i; r = e.enumeratedString("BYTERANGE"); r && this.setByteRange(r, s), s && (this.fragOffset = s.fragOffset + s.duration) } get start() { return this.fragment.start + this.fragOffset } get end() { return this.start + this.duration } get loaded() { var e = this.elementaryStreams; return !!(e.audio || e.video || e.audiovideo) } } let mr = 10; class pr { constructor(e) { this.PTSKnown = !1, this.alignedSliding = !1, this.averagetargetduration = void 0, this.endCC = 0, this.endSN = 0, this.fragments = void 0, this.fragmentHint = void 0, this.partList = null, this.dateRanges = void 0, this.live = !0, this.ageHeader = 0, this.advancedDateTime = void 0, this.updated = !0, this.advanced = !0, this.availabilityDelay = void 0, this.misses = 0, this.startCC = 0, this.startSN = 0, this.startTimeOffset = null, this.targetduration = 0, this.totalduration = 0, this.type = null, this.url = void 0, this.m3u8 = "", this.version = null, this.canBlockReload = !1, this.canSkipUntil = 0, this.canSkipDateRanges = !1, this.skippedSegments = 0, this.recentlyRemovedDateranges = void 0, this.partHoldBack = 0, this.holdBack = 0, this.partTarget = 0, this.preloadHint = void 0, this.renditionReports = void 0, this.tuneInGoal = 0, this.deltaUpdateFailed = void 0, this.driftStartTime = 0, this.driftEndTime = 0, this.driftStart = 0, this.driftEnd = 0, this.encryptedFragments = void 0, this.playlistParsingError = null, this.variableList = null, this.hasVariableRefs = !1, this.fragments = [], this.encryptedFragments = [], this.dateRanges = {}, this.url = e } reloaded(e) { var t, r; e ? (t = this.lastPartSn - e.lastPartSn, r = this.lastPartIndex - e.lastPartIndex, this.updated = this.endSN !== e.endSN || !!r || !!t, this.advanced = this.endSN > e.endSN || 0 < t || 0 == t && 0 < r, this.updated || this.advanced ? this.misses = Math.floor(.6 * e.misses) : this.misses = e.misses + 1, this.availabilityDelay = e.availabilityDelay) : (this.advanced = !0, this.updated = !0) } get hasProgramDateTime() { return !!this.fragments.length && F(this.fragments[this.fragments.length - 1].programDateTime) } get levelTargetDuration() { return this.averagetargetduration || this.targetduration || mr } get drift() { var e = this.driftEndTime - this.driftStartTime; return 0 < e ? 1e3 * (this.driftEnd - this.driftStart) / e : 1 } get edge() { return this.partEnd || this.fragmentEnd } get partEnd() { var e; return null != (e = this.partList) && e.length ? this.partList[this.partList.length - 1].end : this.fragmentEnd } get fragmentEnd() { var e; return null != (e = this.fragments) && e.length ? this.fragments[this.fragments.length - 1].end : 0 } get age() { return this.advancedDateTime ? Math.max(Date.now() - this.advancedDateTime, 0) / 1e3 : 0 } get lastPartIndex() { var e; return null != (e = this.partList) && e.length ? this.partList[this.partList.length - 1].index : -1 } get lastPartSn() { var e; return null != (e = this.partList) && e.length ? this.partList[this.partList.length - 1].fragment.sn : this.endSN } } function Qe(e) { return Uint8Array.from(atob(e), e => e.charCodeAt(0)) } function Tr(e) { var e = ci(e).subarray(0, 16), t = new Uint8Array(16); return t.set(e, 16 - e.length), t } function yr(e) { function t(e, t, r) { var i = e[t]; e[t] = e[r], e[r] = i } t(e, 0, 3), t(e, 1, 2), t(e, 4, 5), t(e, 6, 7) } function Er(e) { var t, r, e = e.split(":"); let i = null; return "data" === e[0] && 2 === e.length && 2 === (r = (e = e[1].split(";"))[e.length - 1].split(",")).length && (t = "base64" === r[0], r = r[1], i = (t ? (e.splice(-1, 1), Qe) : Tr)(r)), i } function ci(e) { return Uint8Array.from(unescape(encodeURIComponent(e)), e => e.charCodeAt(0)) } var J = { CLEARKEY: "org.w3.clearkey", FAIRPLAY: "com.apple.fps", PLAYREADY: "com.microsoft.playready", WIDEVINE: "com.widevine.alpha" }, lt = { CLEARKEY: "org.w3.clearkey", FAIRPLAY: "com.apple.streamingkeydelivery", PLAYREADY: "com.microsoft.playready", WIDEVINE: "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed" }; function gs(e) { switch (e) { case lt.FAIRPLAY: return J.FAIRPLAY; case lt.PLAYREADY: return J.PLAYREADY; case lt.WIDEVINE: return J.WIDEVINE; case lt.CLEARKEY: return J.CLEARKEY } } var hi = { WIDEVINE: "edef8ba979d64acea3c827dcd51d21ed" }; function xr(e) { if (e === hi.WIDEVINE) return J.WIDEVINE } function ms(e) { switch (e) { case J.FAIRPLAY: return lt.FAIRPLAY; case J.PLAYREADY: return lt.PLAYREADY; case J.WIDEVINE: return lt.WIDEVINE; case J.CLEARKEY: return lt.CLEARKEY } } function pe(e) { let { drmSystems: t, widevineLicenseUrl: r } = e, i = t ? [J.FAIRPLAY, J.WIDEVINE, J.PLAYREADY, J.CLEARKEY].filter(e => !!t[e]) : []; return !i[J.WIDEVINE] && r && i.push(J.WIDEVINE), i } let di = typeof self < "u" && self.navigator && self.navigator.requestMediaKeySystemAccess ? self.navigator.requestMediaKeySystemAccess.bind(self.navigator) : null; function Sr(e, t, r, i) { let s; switch (e) { case J.FAIRPLAY: s = ["cenc", "sinf"]; break; case J.WIDEVINE: case J.PLAYREADY: s = ["cenc"]; break; case J.CLEARKEY: s = ["cenc", "keyids"]; break; default: throw new Error("Unknown key-system: " + e) }return vr(s, t, r, i) } function vr(e, t, r, i) { return [{ initDataTypes: e, persistentState: i.persistentState || "not-allowed", distinctiveIdentifier: i.distinctiveIdentifier || "not-allowed", sessionTypes: i.sessionTypes || [i.sessionType || "temporary"], audioCapabilities: t.map(e => ({ contentType: `audio/mp4; codecs="${e}"`, robustness: i.audioRobustness || "", encryptionScheme: i.audioEncryptionScheme || null })), videoCapabilities: r.map(e => ({ contentType: `video/mp4; codecs="${e}"`, robustness: i.videoRobustness || "", encryptionScheme: i.videoEncryptionScheme || null })) }] } function wt(e, t, r) { return Uint8Array.prototype.slice ? e.slice(t, r) : new Uint8Array(Array.prototype.slice.call(e, t, r)) } let Je = (e, t) => t + 10 <= e.length && 73 === e[t] && 68 === e[t + 1] && 51 === e[t + 2] && e[t + 3] < 255 && e[t + 4] < 255 && e[t + 6] < 128 && e[t + 7] < 128 && e[t + 8] < 128 && e[t + 9] < 128, ui = (e, t) => t + 10 <= e.length && 51 === e[t] && 68 === e[t + 1] && 73 === e[t + 2] && e[t + 3] < 255 && e[t + 4] < 255 && e[t + 6] < 128 && e[t + 7] < 128 && e[t + 8] < 128 && e[t + 9] < 128, ne = (e, t) => { var r = t; let i = 0; for (; Je(e, t);) { i += 10; var s = ue(e, t + 6); i += s, ui(e, t + 10) && (i += 10), t += i } if (0 < i) return e.subarray(r, r + i) }, ue = (e, t) => { var r = (127 & e[t]) << 21; return (r |= (127 & e[t + 1]) << 14) | (127 & e[t + 2]) << 7 | 127 & e[t + 3] }, Ar = (e, t) => Je(e, t) && ue(e, t + 6) + 10 <= e.length - t, Lr = e => { var t = gi(e); for (let e = 0; e < t.length; e++) { var r = t[e]; if (fi(r)) return kr(r) } }, fi = e => e && "PRIV" === e.key && "com.apple.streaming.transportStreamTimestamp" === e.info, Rr = e => { var t = String.fromCharCode(e[0], e[1], e[2], e[3]), r = ue(e, 4); return { type: t, size: r, data: e.subarray(10, 10 + r) } }, gi = e => { let t = 0; for (var r = []; Je(e, t);) { for (var i = ue(e, t + 6), s = (t += 10) + i; t + 8 < s;) { var a = Rr(e.subarray(t)), n = Ir(a); n && r.push(n), t += a.size + 10 } ui(e, t) && (t += 10) } return r }, Ir = e => ("PRIV" === e.type ? br : "W" === e.type[0] ? Cr : Dr)(e), br = e => { var t, r; if (!(e.size < 2)) return t = St(e.data, !0), r = new Uint8Array(e.data.subarray(t.length + 1)), { key: e.type, info: t, data: r.buffer } }, Dr = e => { var t, r; if (!(e.size < 2)) return "TXXX" === e.type ? (t = 1, t += (r = St(e.data.subarray(1), !0)).length + 1, t = St(e.data.subarray(t)), { key: e.type, info: r, data: t }) : (r = St(e.data.subarray(1)), { key: e.type, data: r }) }, Cr = e => { var t, r; return "WXXX" === e.type ? e.size < 2 ? void 0 : (t = 1, t += (r = St(e.data.subarray(1), !0)).length + 1, t = St(e.data.subarray(t)), { key: e.type, info: r, data: t }) : (r = St(e.data), { key: e.type, data: r }) }, kr = t => { if (8 === t.data.byteLength) { var t = new Uint8Array(t.data), r = 1 & t[3]; let e = (t[4] << 23) + (t[5] << 15) + (t[6] << 7) + t[7]; return e /= 45, r && (e += 47721858.84), Math.round(e) } }, St = (e, t = !1) => { var r, i = _r(); if (i) return i = i.decode(e), t ? -1 !== (r = i.indexOf("\0")) ? i.substring(0, r) : i : i.replace(/\0/g, ""); var s = e.length; let a, n, o, l = "", h = 0; for (; h < s;) { if (0 === (a = e[h++]) && t) return l; if (0 !== a && 3 !== a) switch (a >> 4) { case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: l += String.fromCharCode(a); break; case 12: case 13: n = e[h++], l += String.fromCharCode((31 & a) << 6 | 63 & n); break; case 14: n = e[h++], o = e[h++], l += String.fromCharCode((15 & a) << 12 | (63 & n) << 6 | (63 & o) << 0) } } return l }, Te; function _r() { return Te = !Te && typeof self.TextDecoder < "u" ? new self.TextDecoder("utf-8") : Te } let Et = { hexDump: function (r) { let i = ""; for (let t = 0; t < r.length; t++) { let e = r[t].toString(16); e.length < 2 && (e = "0" + e), i += e } return i } }, ae = Math.pow(2, 32) - 1, wr = [].push, mi = { video: 1, audio: 2, id3: 3, text: 4 }; function et(e) { return String.fromCharCode.apply(null, e) } function pi(e, t) { e = e[t] << 8 | e[t + 1]; return e < 0 ? 65536 + e : e } function B(e, t) { e = Ti(e, t); return e < 0 ? 4294967296 + e : e } function Ti(e, t) { return e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3] } function ye(e, t, r) { e[t] = r >> 24, e[t + 1] = r >> 16 & 255, e[t + 2] = r >> 8 & 255, e[t + 3] = 255 & r } function $(t, r) { var i = []; if (r.length) { var s = t.byteLength; for (let e = 0; e < s;) { var a = B(t, e), n = et(t.subarray(e + 4, e + 8)), a = 1 < a ? e + a : s; n === r[0] && (1 === r.length ? i.push(t.subarray(e + 8, a)) : (n = $(t.subarray(e + 8, a), r.slice(1))).length && wr.apply(i, n)), e = a } } return i } function Pr(t) { var r = [], e = t[0]; let i = 8; var s = B(t, i); i = (i += 4) + (0 === e ? 8 : 16) + 2; let a = t.length + 0; var n = pi(t, i); i += 2; for (let e = 0; e < n; e++) { var o = i, l = B(t, o), h = (o += 4, 2147483647 & l); if ((2147483648 & l) >>> 31 == 1) return E.warn("SIDX has hierarchical references (not supported)"), null; l = B(t, o); o += 4, r.push({ referenceSize: h, subsegmentDuration: l, info: { duration: l / s, start: a, end: a + h - 1 } }), a += h, o += 4, i = o } return { earliestPresentationTime: 0, timescale: s, version: e, referencesCount: n, references: r } } function yi(e) { let r = [], t = $(e, ["moov", "trak"]); for (let e = 0; e < t.length; e++) { var i = t[e], s = $(i, ["tkhd"])[0]; if (s) { var s = B(s, 0 === s[0] ? 12 : 20), a = $(i, ["mdia", "mdhd"])[0]; if (a) { var a = B(a, 0 === a[0] ? 12 : 20), n = $(i, ["mdia", "hdlr"])[0]; if (n) { n = et(n.subarray(8, 12)), n = { soun: H.AUDIO, vide: H.VIDEO }[n]; if (n) { i = $(i, ["mdia", "minf", "stbl", "stsd"])[0]; let e; i && (e = et(i.subarray(12, 16))), r[s] = { timescale: a, type: n }, r[n] = { timescale: a, id: s, codec: e } } } } } } return $(e, ["moov", "mvex", "trex"]).forEach(e => { var t = B(e, 4), t = r[t]; t && (t.default = { duration: B(e, 12), flags: B(e, 20) }) }), r } function Fr(e, t) { if (e && t) { let i = t.keyId; i && t.isCommonEncryption && $(e, ["moov", "trak"]).forEach(e => { e = $(e, ["mdia", "minf", "stbl", "stsd"])[0].subarray(8); let t = $(e, ["enca"]), r = 0 < t.length; (t = r ? t : $(e, ["encv"])).forEach(e => { $(r ? e.subarray(28) : e.subarray(78), ["sinf"]).forEach(e => { var t, e = Ei(e); e && !(t = e.subarray(8, 24)).some(e => 0 !== e) && (E.log(`[eme] Patching keyId in 'enc${r ? "a" : "v"}>sinf>>tenc' box: ${Et.hexDump(t)} -> ` + Et.hexDump(i)), e.set(i, 8)) }) }) }) } return e } function Ei(e) { var t = $(e, ["schm"])[0]; if (t) { t = et(t.subarray(4, 8)); if ("cbcs" === t || "cenc" === t) return $(e, ["schi", "tenc"])[0] } return E.error("[eme] missing 'schm' box"), null } function Or(a, e) { return $(e, ["moof", "traf"]).reduce((e, t) => { let i = $(t, ["tfdt"])[0], s = i[0], r = $(t, ["tfhd"]).reduce((t, r) => { r = B(r, 4), r = a[r]; if (r) { let e = B(i, 4); if (1 === s) { if (e === ae) return E.warn("[mp4-demuxer]: Ignoring assumed invalid signed 64-bit track fragment decode time"), t; e = (e *= ae + 1) + B(i, 8) } r = r.timescale || 9e4, r = e / r; if (isFinite(r) && (null === t || r < t)) return r } return t }, null); return null !== r && isFinite(r) && (null === e || r < e) ? r : e }, null) } function Mr(e, t) { let r = 0, i = 0, s = 0; var a = $(e, ["moof", "traf"]); for (let e = 0; e < a.length; e++) { var n = a[e], o = $(n, ["tfhd"])[0], l = t[B(o, 4)]; if (l) { var h = l.default, d = B(o, 0) | (null == h ? void 0 : h.flags); let t = null == h ? void 0 : h.duration; 8 & d && (t = B(o, 2 & d ? 12 : 8)); var u, c = l.timescale || 9e4, f = $(n, ["trun"]); for (let e = 0; e < f.length; e++)!(r = Nr(f[e])) && t && (u = B(f[e], 4), r = t * u), l.type === H.VIDEO ? i += r / c : l.type === H.AUDIO && (s += r / c) } } if (0 !== i || 0 !== s) return i || s; { let t = 0; var g = $(e, ["sidx"]); for (let e = 0; e < g.length; e++) { var m = Pr(g[e]); null != m && m.references && (t += m.references.reduce((e, t) => e + t.info.duration || 0, 0)) } return t } } function Nr(t) { var r = B(t, 0); let i = 8, s = (1 & r && (i += 4), 4 & r && (i += 4), 0); var a, n = B(t, 4); for (let e = 0; e < n; e++)256 & r && (a = B(t, i), s += a, i += 4), 512 & r && (i += 4), 1024 & r && (i += 4), 2048 & r && (i += 4); return s } function Ur(r, e, a) { $(e, ["moof", "traf"]).forEach(t => { $(t, ["tfhd"]).forEach(e => { e = B(e, 4), e = r[e]; if (e) { let s = e.timescale || 9e4; $(t, ["tfdt"]).forEach(e => { var t, r = e[0]; let i = B(e, 4); 0 === r ? (i -= a * s, ye(e, 4, i = Math.max(i, 0))) : (i = (i = (i *= Math.pow(2, 32)) + B(e, 8)) - a * s, i = Math.max(i, 0), r = Math.floor(i / (ae + 1)), t = Math.floor(i % (ae + 1)), ye(e, 4, r), ye(e, 8, t)) }) } }) }) } function Br(e) { var t = { valid: null, remainder: null }, r = $(e, ["moof"]); return r && (r.length < 2 ? t.remainder = e : (r = r[r.length - 1], t.valid = wt(e, 0, r.byteOffset - 8), t.remainder = wt(e, r.byteOffset - 8))), t } function Pt(e, t) { var r = new Uint8Array(e.length + t.length); return r.set(e), r.set(t, e.length), r } function ps(y, L) { let S = [], A = L.samples, R = L.timescale, h = L.id, I = !1; return $(A, ["moof"]).map(e => { let T = e.byteOffset - 8; $(e, ["traf"]).map(l => { var e = $(l, ["tfdt"]).map(e => { var t = e[0]; let r = B(e, 4); return (r = 1 === t ? (r *= Math.pow(2, 32)) + B(e, 8) : r) / R })[0]; return void 0 !== e && (y = e), $(l, ["tfhd"]).map(e => { var t = B(e, 4), r = 16777215 & B(e, 0), i = 0 != (1 & r), s = 0 != (2 & r), a = 0 != (8 & r); let v = 0; var n = 0 != (16 & r); let E = 0; r = 0 != (32 & r); let o = 8; t === h && (i && (o += 8), s && (o += 4), a && (v = B(e, o), o += 4), n && (E = B(e, o), o += 4), r && (o += 4), "video" === L.type && (I = $r(L.codec)), $(l, ["trun"]).map(t => { var r = t[0], e = 16777215 & B(t, 0), i = 0 != (1 & e); let s = 0; var a = 0 != (4 & e), n = 0 != (256 & e); let o = 0; var l = 0 != (512 & e); let h = 0; var d = 0 != (1024 & e), u = 0 != (2048 & e); let c = 0; var f = B(t, 4); let g = 8, m = (i && (s = B(t, g), g += 4), a && (g += 4), s + T); for (let e = 0; e < f; e++) { if (n ? (o = B(t, g), g += 4) : o = v, l ? (h = B(t, g), g += 4) : h = E, d && (g += 4), u && (c = (0 === r ? B : Ti)(t, g), g += 4), L.type === H.VIDEO) { let e = 0; for (; e < h;) { var p = B(A, m); m += 4, Gr(I, A[m]) && xi(A.subarray(m, m + p), I ? 2 : 1, y + c / R, S), m += p, e += p + 4 } } y += o / R } })) }) }) }), S } function $r(e) { var t; return !!e && ("hvc1" === (e = (t = e.indexOf(".")) < 0 ? e : e.substring(0, t)) || "hev1" === e || "dvh1" === e || "dvhe" === e) } function Gr(e, t) { return e ? 39 == (e = t >> 1 & 63) || 40 == e : 6 == (31 & t) } function xi(e, t, r, i) { var s = Si(e); let a = 0, n = (a += t, 0), o = 0, l = !1, h = 0; for (; a < s.length;) { for (n = 0; !(a >= s.length) && (h = s[a++], n += h, 255 === h);); for (o = 0; !(a >= s.length) && (h = s[a++], o += h, 255 === h);); var d = s.length - a; if (!l && 4 === n && a < s.length) { if (l = !0, 181 === s[a++]) { var u = pi(s, a); if (a += 2, 49 === u) { u = B(s, a); if (a += 4, 1195456820 === u) { u = s[a++]; if (3 === u) { var c = s[a++], f = 64 & c, g = f ? 2 + 3 * (31 & c) : 0, m = new Uint8Array(g); if (f) { m[0] = c; for (let e = 1; e < g; e++)m[e] = s[a++] } i.push({ type: u, payloadType: n, pts: r, bytes: m }) } } } } } else if (5 === n && o < d) { if (l = !0, 16 < o) { var p = []; for (let e = 0; e < 16; e++) { var v = s[a++].toString(16); p.push(1 == v.length ? "0" + v : v), 3 !== e && 5 !== e && 7 !== e && 9 !== e || p.push("-") } var E = o - 16, T = new Uint8Array(E); for (let e = 0; e < E; e++)T[e] = s[a++]; i.push({ payloadType: n, pts: r, uuid: p.join(""), userData: St(T), userDataBytes: T }) } } else if (o < d) a += o; else if (o > d) break } } function Si(e) { var t = e.byteLength, r = []; let i = 1; for (; i < t - 2;)0 === e[i] && 0 === e[i + 1] && 3 === e[i + 2] ? (r.push(i + 2), i += 2) : i++; if (0 === r.length) return e; var s = t - r.length, a = new Uint8Array(s); let n = 0; for (i = 0; i < s; n++, i++)n === r[0] && (n++, r.shift()), a[i] = e[n]; return a } function Kr(e) { var t = e[0]; let r = "", i = "", s = 0, a = 0, n = 0, o = 0, l = 0, h = 0; if (0 === t) { for (; "\0" !== et(e.subarray(h, h + 1));)r += et(e.subarray(h, h + 1)), h += 1; for (r += et(e.subarray(h, h + 1)), h += 1; "\0" !== et(e.subarray(h, h + 1));)i += et(e.subarray(h, h + 1)), h += 1; i += et(e.subarray(h, h + 1)), h += 1, s = B(e, 12), a = B(e, 16), o = B(e, 20), l = B(e, 24), h = 28 } else if (1 === t) { h += 4, s = B(e, h); var t = B(e, h += 4), d = B(e, h += 4); for (h += 4, n = 2 ** 32 * t + d, Number.isSafeInteger(n) || (n = Number.MAX_SAFE_INTEGER, E.warn("Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box")), o = B(e, h), h += 4, l = B(e, h), h += 4; "\0" !== et(e.subarray(h, h + 1));)r += et(e.subarray(h, h + 1)), h += 1; for (r += et(e.subarray(h, h + 1)), h += 1; "\0" !== et(e.subarray(h, h + 1));)i += et(e.subarray(h, h + 1)), h += 1; i += et(e.subarray(h, h + 1)), h += 1 } t = e.subarray(h, e.byteLength); return { schemeIdUri: r, value: i, timeScale: s, presentationTime: n, presentationTimeDelta: a, eventDuration: o, id: l, payload: t } } function Hr(e, ...t) { var r = t.length; let i = 8, s = r; for (; s--;)i += t[s].byteLength; var a = new Uint8Array(i); for (a[0] = i >> 24 & 255, a[1] = i >> 16 & 255, a[2] = i >> 8 & 255, a[3] = 255 & i, a.set(e, 4), s = 0, i = 8; s < r; s++)a.set(t[s], i), i += t[s].byteLength; return a } function Vr(e, t, r) { if (16 !== e.byteLength) throw new RangeError("Invalid system id"); let i, s; if (t) { i = 1, s = new Uint8Array(16 * t.length); for (let e = 0; e < t.length; e++) { var a = t[e]; if (16 !== a.byteLength) throw new RangeError("Invalid key"); s.set(a, 16 * e) } } else i = 0, s = new Uint8Array; let n; 0 < i ? (n = new Uint8Array(4), 0 < t.length && new DataView(n.buffer).setUint32(0, t.length, !1)) : n = new Uint8Array; var o = new Uint8Array(4); return r && 0 < r.byteLength && new DataView(o.buffer).setUint32(0, r.byteLength, !1), Hr([112, 115, 115, 104], new Uint8Array([i, 0, 0, 0]), e, n, s, o, r || new Uint8Array) } function Wr(t) { if (!(t instanceof ArrayBuffer) || t.byteLength < 32) return null; var r = { version: 0, systemId: "", kids: null, data: null }, e = new DataView(t), i = e.getUint32(0); if (t.byteLength !== i && 44 < i || 1886614376 !== e.getUint32(4) || (r.version = e.getUint32(8) >>> 24, 1 < r.version)) return null; r.systemId = Et.hexDump(new Uint8Array(t, 12, 16)); var s = e.getUint32(28); if (0 === r.version) { if (i - 32 < s) return null; r.data = new Uint8Array(t, 32, s) } else if (1 === r.version) { r.kids = []; for (let e = 0; e < s; e++)r.kids.push(new Uint8Array(t, 32 + 16 * e, 16)) } return r } let jt = {}; class Wt { static clearKeyUriToKeyIdMap() { jt = {} } constructor(e, t, r, i = [1], s = null) { this.uri = void 0, this.method = void 0, this.keyFormat = void 0, this.keyFormatVersions = void 0, this.encrypted = void 0, this.isCommonEncryption = void 0, this.iv = null, this.key = null, this.keyId = null, this.pssh = null, this.method = e, this.uri = t, this.keyFormat = r, this.keyFormatVersions = i, this.iv = s, this.encrypted = !!e && "NONE" !== e, this.isCommonEncryption = this.encrypted && "AES-128" !== e } isSupported() { if (this.method) { if ("AES-128" === this.method || "NONE" === this.method) return !0; if ("identity" === this.keyFormat) return "SAMPLE-AES" === this.method; switch (this.keyFormat) { case lt.FAIRPLAY: case lt.WIDEVINE: case lt.PLAYREADY: case lt.CLEARKEY: return -1 !== ["ISO-23001-7", "SAMPLE-AES", "SAMPLE-AES-CENC", "SAMPLE-AES-CTR"].indexOf(this.method) } } return !1 } getDecryptData(t) { if (!this.encrypted || !this.uri) return null; if ("AES-128" === this.method && this.uri && !this.iv) return "number" != typeof t && ("AES-128" !== this.method || this.iv || E.warn(`missing IV for initialization segment with method="${this.method}" - compliance issue`), t = 0), t = Yr(t), new Wt(this.method, this.uri, "identity", this.keyFormatVersions, t); var r = Er(this.uri); if (r) switch (this.keyFormat) { case lt.WIDEVINE: 22 <= (this.pssh = r).length && (this.keyId = r.subarray(r.length - 22, r.length - 6)); break; case lt.PLAYREADY: var i = new Uint8Array([154, 4, 240, 121, 152, 64, 66, 134, 171, 146, 230, 91, 224, 136, 95, 149]), i = (this.pssh = Vr(i, null, r), new Uint16Array(r.buffer, r.byteOffset, r.byteLength / 2)), i = String.fromCharCode.apply(null, Array.from(i)), i = i.substring(i.indexOf("<"), i.length), i = (new DOMParser).parseFromString(i, "text/xml").getElementsByTagName("KID")[0]; i && (i = i.childNodes[0] ? i.childNodes[0].nodeValue : i.getAttribute("VALUE")) && (yr(i = Qe(i).subarray(0, 16)), this.keyId = i); break; default: { let e = r.subarray(0, 16); 16 !== e.length && ((i = new Uint8Array(16)).set(e, 16 - e.length), e = i), this.keyId = e; break } }if (!this.keyId || 16 !== this.keyId.byteLength) { let e = jt[this.uri]; e || (t = Object.keys(jt).length % Number.MAX_SAFE_INTEGER, e = new Uint8Array(16), new DataView(e.buffer, 12, 4).setUint32(0, t), jt[this.uri] = e), this.keyId = e } return this } } function Yr(t) { var r = new Uint8Array(16); for (let e = 12; e < 16; e++)r[e] = t >> 8 * (15 - e) & 255; return r } let vi = /\{\$([a-zA-Z0-9-_]+)\}/g; function Ts(e) { return vi.test(e) } function at(t, r, i) { if (null !== t.variableList || t.hasVariableRefs) for (let e = i.length; e--;) { var s = i[e], a = r[s]; a && (r[s] = $e(t, a)) } } function $e(s, e) { if (null !== s.variableList || s.hasVariableRefs) { let i = s.variableList; return e.replace(vi, e => { var t = e.substring(2, e.length - 1), r = null == i ? void 0 : i[t]; return void 0 === r ? (s.playlistParsingError || (s.playlistParsingError = new Error(`Missing preceding EXT-X-DEFINE tag for Variable Reference: "${t}"`)), e) : r }) } return e } function ys(t, e, r) { let i = t.variableList; i || (t.variableList = i = {}); let s, a; if ("QUERYPARAM" in e) { s = e.QUERYPARAM; try { var n = new self.URL(r).searchParams; if (!n.has(s)) throw new Error(`"${s}" does not match any query parameter in URI: "${r}"`); a = n.get(s) } catch (e) { t.playlistParsingError || (t.playlistParsingError = new Error("EXT-X-DEFINE QUERYPARAM: " + e.message)) } } else s = e.NAME, a = e.VALUE; s in i ? t.playlistParsingError || (t.playlistParsingError = new Error(`EXT-X-DEFINE duplicate Variable Name declarations: "${s}"`)) : i[s] = a || "" } function qr(t, r, i) { r = r.IMPORT; if (i && r in i) { let e = t.variableList; e || (t.variableList = e = {}), e[r] = i[r] } else t.playlistParsingError || (t.playlistParsingError = new Error(`EXT-X-DEFINE IMPORT attribute not found in Multivariant Playlist: "${r}"`)) } function fe() { if (!("u" < typeof self)) return self.MediaSource || self.WebKitMediaSource } let jr = { audio: { a3ds: !0, "ac-3": !0, "ac-4": !0, alac: !0, alaw: !0, dra1: !0, "dts+": !0, "dts-": !0, dtsc: !0, dtse: !0, dtsh: !0, "ec-3": !0, enca: !0, g719: !0, g726: !0, m4ae: !0, mha1: !0, mha2: !0, mhm1: !0, mhm2: !0, mlpa: !0, mp4a: !0, "raw ": !0, Opus: !0, opus: !0, samr: !0, sawb: !0, sawp: !0, sevc: !0, sqcp: !0, ssmv: !0, twos: !0, ulaw: !0 }, video: { avc1: !0, avc2: !0, avc3: !0, avc4: !0, avcp: !0, av01: !0, drac: !0, dva1: !0, dvav: !0, dvh1: !0, dvhe: !0, encv: !0, hev1: !0, hvc1: !0, mjp2: !0, mp4v: !0, mvc1: !0, mvc2: !0, mvc3: !0, mvc4: !0, resv: !0, rv60: !0, s263: !0, svc1: !0, svc2: !0, "vc-1": !0, vp08: !0, vp09: !0 }, text: { stpp: !0, wvtt: !0 } }, Es = fe(); function Xr(e, t) { t = jr[t]; return !!t && !0 === t[e.slice(0, 4)] } function Ee(e, t) { return null != (t = null == Es ? void 0 : Es.isTypeSupported(`${t || "video"}/mp4;codecs="${e}"`)) && t } let xs = /#EXT-X-STREAM-INF:([^\r\n]*)(?:[\r\n](?:#[^\r\n]*)?)*([^\r\n]+)|#EXT-X-(SESSION-DATA|SESSION-KEY|DEFINE|CONTENT-STEERING|START):([^\r\n]*)[\r\n]+/g, Ss = /#EXT-X-MEDIA:(.*)/g, zr = /^#EXT(?:INF|-X-TARGETDURATION):/m, vs = new RegExp([/#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source, /(?!#) *(\S[\S ]*)/.source, /#EXT-X-BYTERANGE:*(.+)/.source, /#EXT-X-PROGRAM-DATE-TIME:(.+)/.source, /#.*/.source].join("|"), "g"), Qr = new RegExp([/#(EXTM3U)/.source, /#EXT-X-(DATERANGE|DEFINE|KEY|MAP|PART|PART-INF|PLAYLIST-TYPE|PRELOAD-HINT|RENDITION-REPORT|SERVER-CONTROL|SKIP|START):(.+)/.source, /#EXT-X-(BITRATE|DISCONTINUITY-SEQUENCE|MEDIA-SEQUENCE|TARGETDURATION|VERSION): *(\d+)/.source, /#EXT-X-(DISCONTINUITY|ENDLIST|GAP)/.source, /(#)([^:]*):(.*)/.source, /(#)(.*)(?:.*)\r?\n?/.source].join("|")); class yt { static findGroup(t, r) { for (let e = 0; e < t.length; e++) { var i = t[e]; if (i.id === r) return i } } static convertAVC1ToAVCOTI(e) { var t, r = e.split("."); return 2 < r.length ? (t = r.shift() + ".", (t += parseInt(r.shift()).toString(16)) + ("000" + parseInt(r.shift()).toString(16)).slice(-4)) : e } static resolve(e, t) { return ze.buildAbsoluteURL(t, e, { alwaysNormalize: !0 }) } static isMediaPlaylist(e) { return zr.test(e) } static parseMasterPlaylist(e, t) { var r, i = { contentSteering: null, levels: [], playlistParsingError: null, sessionData: null, sessionKeys: null, startTimeOffset: null, variableList: null, hasVariableRefs: Ts(e) }, s = []; for (xs.lastIndex = 0; null != (r = xs.exec(e));)if (r[1]) { var a = new Q(r[1]), n = (at(i, a, ["CODECS", "SUPPLEMENTAL-CODECS", "ALLOWED-CPC", "PATHWAY-ID", "STABLE-VARIANT-ID", "AUDIO", "VIDEO", "SUBTITLES", "CLOSED-CAPTIONS", "NAME"]), $e(i, r[2])), n = { attrs: a, bitrate: a.decimalInteger("AVERAGE-BANDWIDTH") || a.decimalInteger("BANDWIDTH"), name: a.NAME, url: yt.resolve(n, t) }, o = a.decimalResolution("RESOLUTION"); o && (n.width = o.width, n.height = o.height), Jr((a.CODECS || "").split(/[ ,]+/).filter(e => e), n), n.videoCodec && -1 !== n.videoCodec.indexOf("avc1") && (n.videoCodec = yt.convertAVC1ToAVCOTI(n.videoCodec)), null != (o = n.unknownCodecs) && o.length || s.push(n), i.levels.push(n) } else if (r[3]) { var a = r[3], l = r[4]; switch (a) { case "SESSION-DATA": var h = new Q(l), d = (at(i, h, ["DATA-ID", "LANGUAGE", "VALUE", "URI"]), h["DATA-ID"]); d && (null === i.sessionData && (i.sessionData = {}), i.sessionData[d] = h); break; case "SESSION-KEY": d = As(l, t, i); d.encrypted && d.isSupported() ? (null === i.sessionKeys && (i.sessionKeys = []), i.sessionKeys.push(d)) : E.warn(`[Keys] Ignoring invalid EXT-X-SESSION-KEY tag: "${l}"`); break; case "DEFINE": h = new Q(l); at(i, h, ["NAME", "VALUE", "QUERYPARAM"]), ys(i, h, t); break; case "CONTENT-STEERING": var u = new Q(l); at(i, u, ["SERVER-URI", "PATHWAY-ID"]), i.contentSteering = { uri: yt.resolve(u["SERVER-URI"], t), pathwayId: u["PATHWAY-ID"] || "." }; break; case "START": i.startTimeOffset = Ls(l) } } var c = 0 < s.length && s.length < i.levels.length; return i.levels = c ? s : i.levels, 0 === i.levels.length && (i.playlistParsingError = new Error("no levels found in manifest")), i } static parseMasterPlaylistMedia(e, t, r) { var i = {}, s = r.levels, a = { AUDIO: s.map(e => ({ id: e.attrs.AUDIO, audioCodec: e.audioCodec })), SUBTITLES: s.map(e => ({ id: e.attrs.SUBTITLES, textCodec: e.textCodec })), "CLOSED-CAPTIONS": [] }; let n = 0; for (Ss.lastIndex = 0; null !== (h = Ss.exec(e));) { var o, l, h = new Q(h[1]), d = h.TYPE; d && (o = a[d], l = i[d] || [], i[d] = l, at(r, h, ["URI", "GROUP-ID", "LANGUAGE", "ASSOC-LANGUAGE", "STABLE-RENDITION-ID", "NAME", "INSTREAM-ID", "CHARACTERISTICS", "CHANNELS"]), d = { attrs: h, bitrate: 0, id: n++, groupId: h["GROUP-ID"] || "", instreamId: h["INSTREAM-ID"], name: h.NAME || h.LANGUAGE || "", type: d, default: h.bool("DEFAULT"), autoselect: h.bool("AUTOSELECT"), forced: h.bool("FORCED"), lang: h.LANGUAGE, url: h.URI ? yt.resolve(h.URI, t) : "" }, null != o && o.length && (Rs(d, h = yt.findGroup(o, d.groupId) || o[0], "audioCodec"), Rs(d, h, "textCodec")), l.push(d)) } return i } static parseLevelPlaylist(e, t, r, i, s, a) { var n = new pr(t), o = n.fragments; let l = null, h = 0, d = 0, u = 0, c = 0, f = null, g = new me(i, t), m, p, v, T = -1, y = !1; for (vs.lastIndex = 0, n.m3u8 = e, n.hasVariableRefs = Ts(e); null !== (m = vs.exec(e));) { y && (y = !1, (g = new me(i, t)).start = u, g.sn = h, g.cc = c, g.level = r, l) && (g.initSegment = l, g.rawProgramDateTime = l.rawProgramDateTime, l.rawProgramDateTime = null); var L = m[1]; if (L) { g.duration = parseFloat(L); var S = (" " + m[2]).slice(1); g.title = S || null, g.tagList.push(S ? ["INF", L, S] : ["INF", L]) } else if (m[3]) F(g.duration) && (g.start = u, v && Ds(g, v, n), g.sn = h, g.level = r, g.cc = c, g.urlId = s, o.push(g), S = (" " + m[3]).slice(1), g.relurl = $e(n, S), Is(g, f), f = g, u += g.duration, h++, d = 0, y = !0); else if (m[4]) { L = (" " + m[4]).slice(1); f ? g.setByteRange(L, f) : g.setByteRange(L) } else if (m[5]) g.rawProgramDateTime = (" " + m[5]).slice(1), g.tagList.push(["PROGRAM-DATE-TIME", g.rawProgramDateTime]), -1 === T && (T = o.length); else if (m = m[0].match(Qr)) { for (p = 1; p < m.length && !(typeof m[p] < "u"); p++); var A = (" " + m[p]).slice(1), R = (" " + m[p + 1]).slice(1), I = m[p + 2] ? (" " + m[p + 2]).slice(1) : ""; switch (A) { case "PLAYLIST-TYPE": n.type = R.toUpperCase(); break; case "MEDIA-SEQUENCE": h = n.startSN = parseInt(R); break; case "SKIP": var D = new Q(R), b = (at(n, D, ["RECENTLY-REMOVED-DATERANGES"]), D.decimalInteger("SKIPPED-SEGMENTS")); if (F(b)) { for (let e = n.skippedSegments = b; e--;)o.unshift(null); h += b } b = D.enumeratedString("RECENTLY-REMOVED-DATERANGES"); b && (n.recentlyRemovedDateranges = b.split("\t")); break; case "TARGETDURATION": n.targetduration = Math.max(parseInt(R), 1); break; case "VERSION": n.version = parseInt(R); break; case "EXTM3U": break; case "ENDLIST": n.live = !1; break; case "#": (R || I) && g.tagList.push(I ? [R, I] : [R]); break; case "DISCONTINUITY": c++, g.tagList.push(["DIS"]); break; case "GAP": g.gap = !0, g.tagList.push([A]); break; case "BITRATE": g.tagList.push([A, R]); break; case "DATERANGE": D = new Q(R), b = (at(n, D, ["ID", "CLASS", "START-DATE", "END-DATE", "SCTE35-CMD", "SCTE35-OUT", "SCTE35-IN"]), at(n, D, D.clientAttrs), new oi(D, n.dateRanges[D.ID])); b.isValid || n.skippedSegments ? n.dateRanges[b.id] = b : E.warn(`Ignoring invalid DATERANGE tag: "${R}"`), g.tagList.push(["EXT-X-DATERANGE", R]); break; case "DEFINE": var k = new Q(R); at(n, k, ["NAME", "VALUE", "IMPORT", "QUERYPARAM"]), "IMPORT" in k ? qr(n, k, a) : ys(n, k, t); break; case "DISCONTINUITY-SEQUENCE": c = parseInt(R); break; case "KEY": k = As(R, t, n); if (k.isSupported()) { if ("NONE" === k.method) { v = void 0; break } (v = (v = v || {})[k.keyFormat] ? tt({}, v) : v)[k.keyFormat] = k } else E.warn(`[Keys] Ignoring invalid EXT-X-KEY tag: "${R}"`); break; case "START": n.startTimeOffset = Ls(R); break; case "MAP": var _ = new Q(R); at(n, _, ["BYTERANGE", "URI"]), g.duration ? (bs(w = new me(i, t), _, r, v), l = w, (g.initSegment = l).rawProgramDateTime && !g.rawProgramDateTime && (g.rawProgramDateTime = l.rawProgramDateTime)) : (bs(g, _, r, v), l = g, y = !0); break; case "SERVER-CONTROL": var w = new Q(R); n.canBlockReload = w.bool("CAN-BLOCK-RELOAD"), n.canSkipUntil = w.optionalFloat("CAN-SKIP-UNTIL", 0), n.canSkipDateRanges = 0 < n.canSkipUntil && w.bool("CAN-SKIP-DATERANGES"), n.partHoldBack = w.optionalFloat("PART-HOLD-BACK", 0), n.holdBack = w.optionalFloat("HOLD-BACK", 0); break; case "PART-INF": _ = new Q(R); n.partTarget = _.decimalFloatingPoint("PART-TARGET"); break; case "PART": { let e = n.partList; e = e || (n.partList = []); var C = 0 < d ? e[e.length - 1] : void 0, P = d++, x = new Q(R), x = (at(n, x, ["BYTERANGE", "URI"]), new gr(x, g, t, P, C)); e.push(x), g.duration += x.duration; break } case "PRELOAD-HINT": P = new Q(R); at(n, P, ["URI"]), n.preloadHint = P; break; case "RENDITION-REPORT": C = new Q(R); at(n, C, ["URI"]), n.renditionReports = n.renditionReports || [], n.renditionReports.push(C); break; default: E.warn("line parsed but not handled: " + m) } } else E.warn("No matches on slow regex match for level playlist!") } f && !f.relurl ? (o.pop(), u -= f.duration, n.partList && (n.fragmentHint = f)) : n.partList && (Is(g, f), g.cc = c, n.fragmentHint = g, v) && Ds(g, v, n); var O = o.length, M = o[0], N = o[O - 1]; return 0 < (u += n.skippedSegments * n.targetduration) && O && N ? (n.averagetargetduration = u / O, O = N.sn, n.endSN = "initSegment" !== O ? O : 0, n.live || (N.endList = !0), M && (n.startCC = M.cc)) : (n.endSN = 0, n.startCC = 0), n.fragmentHint && (u += n.fragmentHint.duration), n.totalduration = u, n.endCC = c, 0 < T && Zr(o, T), n } } function As(e, t, r) { var e = new Q(e), r = (at(r, e, ["KEYFORMAT", "KEYFORMATVERSIONS", "URI", "IV", "URI"]), null != (r = e.METHOD) ? r : ""), i = e.URI, s = e.hexadecimalInteger("IV"), a = e.KEYFORMATVERSIONS, n = null != (n = e.KEYFORMAT) ? n : "identity", e = (i && e.IV && !s && E.error("Invalid IV: " + e.IV), i ? yt.resolve(i, t) : ""), i = (a || "1").split("/").map(Number).filter(Number.isFinite); return new Wt(r, e, n, i, s) } function Ls(e) { e = new Q(e).decimalFloatingPoint("TIME-OFFSET"); return F(e) ? e : null } function Jr(i, s) { ["video", "audio", "text"].forEach(t => { let r = i.filter(e => Xr(e, t)); var e; r.length && (e = r.filter(e => 0 === e.lastIndexOf("avc1", 0) || 0 === e.lastIndexOf("mp4a", 0)), s[t + "Codec"] = (0 < e.length ? e : r)[0], i = i.filter(e => -1 === r.indexOf(e))) }), s.unknownCodecs = i } function Rs(e, t, r) { t = t[r]; t && (e[r] = t) } function Zr(t, r) { let i = t[r]; for (let e = r; e--;) { var s = t[e]; if (!s) return; s.programDateTime = i.programDateTime - 1e3 * s.duration, i = s } } function Is(e, t) { e.rawProgramDateTime ? e.programDateTime = Date.parse(e.rawProgramDateTime) : null != t && t.programDateTime && (e.programDateTime = t.endProgramDateTime), F(e.programDateTime) || (e.programDateTime = null, e.rawProgramDateTime = null) } function bs(e, t, r, i) { e.relurl = t.URI, t.BYTERANGE && e.setByteRange(t.BYTERANGE), e.level = r, e.sn = "initSegment", i && (e.levelkeys = i), e.initSegment = null } function Ds(e, t, r) { e.levelkeys = t; r = r.encryptedFragments; r.length && r[r.length - 1].levelkeys === t || !Object.keys(t).some(e => t[e].isCommonEncryption) || r.push(e) } var G = { MANIFEST: "manifest", LEVEL: "level", AUDIO_TRACK: "audioTrack", SUBTITLE_TRACK: "subtitleTrack" }, U = { MAIN: "main", AUDIO: "audio", SUBTITLE: "subtitle" }; function Cs(e) { e = e.type; switch (e) { case G.AUDIO_TRACK: return U.AUDIO; case G.SUBTITLE_TRACK: return U.SUBTITLE; default: return U.MAIN } } function xe(e, t) { let r = e.url; return r = void 0 !== r && 0 !== r.indexOf("data:") ? r : t.url } class tn { constructor(e) { this.hls = void 0, this.loaders = Object.create(null), this.variableList = null, this.hls = e, this.registerListeners() } startLoad(e) { } stopLoad() { this.destroyInternalLoaders() } registerListeners() { var e = this.hls; e.on(m.MANIFEST_LOADING, this.onManifestLoading, this), e.on(m.LEVEL_LOADING, this.onLevelLoading, this), e.on(m.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this), e.on(m.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this) } unregisterListeners() { var e = this.hls; e.off(m.MANIFEST_LOADING, this.onManifestLoading, this), e.off(m.LEVEL_LOADING, this.onLevelLoading, this), e.off(m.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this), e.off(m.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this) } createInternalLoader(e) { var t = this.hls.config, t = new (t.pLoader || t.loader)(t); return this.loaders[e.type] = t } getInternalLoader(e) { return this.loaders[e.type] } resetInternalLoader(e) { this.loaders[e] && delete this.loaders[e] } destroyInternalLoaders() { for (var e in this.loaders) { var t = this.loaders[e]; t && t.destroy(), this.resetInternalLoader(e) } } destroy() { this.variableList = null, this.unregisterListeners(), this.destroyInternalLoaders() } onManifestLoading(e, t) { t = t.url; this.variableList = null, this.load({ id: null, level: 0, responseType: "text", type: G.MANIFEST, url: t, deliveryDirectives: null }) } onLevelLoading(e, t) { var { id: t, level: r, url: i, deliveryDirectives: s } = t; this.load({ id: t, level: r, responseType: "text", type: G.LEVEL, url: i, deliveryDirectives: s }) } onAudioTrackLoading(e, t) { var { id: t, groupId: r, url: i, deliveryDirectives: s } = t; this.load({ id: t, groupId: r, level: null, responseType: "text", type: G.AUDIO_TRACK, url: i, deliveryDirectives: s }) } onSubtitleTrackLoading(e, t) { var { id: t, groupId: r, url: i, deliveryDirectives: s } = t; this.load({ id: t, groupId: r, level: null, responseType: "text", type: G.SUBTITLE_TRACK, url: i, deliveryDirectives: s }) } load(t) { var r = this.hls.config; let e = this.getInternalLoader(t); if (e) { var i = e.context; if (i && i.url === t.url) return void E.trace("[playlist-loader]: playlist request ongoing"); E.log("[playlist-loader]: aborting previous loader for type: " + t.type), e.abort() } let s; if (s = t.type === G.MANIFEST ? r.manifestLoadPolicy.default : tt({}, r.playlistLoadPolicy.default, { timeoutRetry: null, errorRetry: null }), e = this.createInternalLoader(t), null != (i = t.deliveryDirectives) && i.part) { let e; t.type === G.LEVEL && null !== t.level ? e = this.hls.levels[t.level].details : t.type === G.AUDIO_TRACK && null !== t.id ? e = this.hls.audioTracks[t.id].details : t.type === G.SUBTITLE_TRACK && null !== t.id && (e = this.hls.subtitleTracks[t.id].details), e && (r = e.partTarget, i = e.targetduration, r) && i && (r = 1e3 * Math.max(3 * r, .8 * i), s = tt({}, s, { maxTimeToFirstByteMs: Math.min(r, s.maxTimeToFirstByteMs), maxLoadTimeMs: Math.min(r, s.maxTimeToFirstByteMs) })) } i = s.errorRetry || s.timeoutRetry || {}, r = { loadPolicy: s, timeout: s.maxLoadTimeMs, maxRetry: i.maxNumRetry || 0, retryDelay: i.retryDelayMs || 0, maxRetryDelay: i.maxRetryDelayMs || 0 }; e.load(t, r, { onSuccess: (e, t, r, i) => { var s = this.getInternalLoader(r), a = (this.resetInternalLoader(r.type), e.data); 0 !== a.indexOf("#EXTM3U") ? this.handleManifestParsingError(e, r, new Error("no EXTM3U delimiter"), i || null, t) : (t.parsing.start = performance.now(), yt.isMediaPlaylist(a) ? this.handleTrackOrLevelPlaylist(e, t, r, i || null, s) : this.handleMasterPlaylist(e, t, r, i)) }, onError: (e, t, r, i) => { this.handleNetworkError(t, r, !1, e, i) }, onTimeout: (e, t, r) => { this.handleNetworkError(t, r, !0, void 0, e) } }) } handleMasterPlaylist(e, t, r, i) { var s, a, n, o, l, h = this.hls, d = e.data, u = xe(e, r), c = yt.parseMasterPlaylist(d, u); c.playlistParsingError ? this.handleManifestParsingError(e, r, c.playlistParsingError, i, t) : ({ contentSteering: e, levels: r, sessionData: s, sessionKeys: a, startTimeOffset: n, variableList: o } = c, { AUDIO: d = [], SUBTITLES: c, "CLOSED-CAPTIONS": l } = (this.variableList = o, yt.parseMasterPlaylistMedia(d, u, c)), d.length && !d.some(e => !e.url) && r[0].audioCodec && !r[0].attrs.AUDIO && (E.log("[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one"), d.unshift({ type: "main", name: "main", groupId: "main", default: !1, autoselect: !1, forced: !1, id: -1, attrs: new Q({}), bitrate: 0, url: "" })), h.trigger(m.MANIFEST_LOADED, { levels: r, audioTracks: d, subtitles: c, captions: l, contentSteering: e, url: u, stats: t, networkDetails: i, sessionData: s, sessionKeys: a, startTimeOffset: n, variableList: o })) } handleTrackOrLevelPlaylist(e, t, r, i, s) { var a = this.hls, { id: n, level: o, type: l } = r, h = xe(e, r), n = F(n) ? n : 0, o = F(o) ? o : n, d = Cs(r), o = yt.parseLevelPlaylist(e.data, h, o, d, n, this.variableList); l === G.MANIFEST && (d = { attrs: new Q({}), bitrate: 0, details: o, name: "", url: h }, a.trigger(m.MANIFEST_LOADED, { levels: [d], audioTracks: [], url: h, stats: t, networkDetails: i, sessionData: null, sessionKeys: null, contentSteering: null, startTimeOffset: null, variableList: null })), t.parsing.end = performance.now(), r.levelDetails = o, this.handlePlaylistLoaded(o, e, t, r, i, s) } handleManifestParsingError(e, t, r, i, s) { this.hls.trigger(m.ERROR, { type: N.NETWORK_ERROR, details: L.MANIFEST_PARSING_ERROR, fatal: t.type === G.MANIFEST, url: e.url, err: r, error: r, reason: r.message, response: e, context: t, networkDetails: i, stats: s }) } handleNetworkError(e, t, r = !1, i, s) { let a = `A network ${r ? "timeout" : "error" + (i ? " (status " + i.code + ")" : "")} occurred while loading ` + e.type; e.type === G.LEVEL ? a += `: ${e.level} id: ` + e.id : e.type !== G.AUDIO_TRACK && e.type !== G.SUBTITLE_TRACK || (a += ` id: ${e.id} group-id: "${e.groupId}"`); var n = new Error(a); E.warn("[playlist-loader]: " + a); let o = L.UNKNOWN, l = !1; var h = this.getInternalLoader(e); switch (e.type) { case G.MANIFEST: o = r ? L.MANIFEST_LOAD_TIMEOUT : L.MANIFEST_LOAD_ERROR, l = !0; break; case G.LEVEL: o = r ? L.LEVEL_LOAD_TIMEOUT : L.LEVEL_LOAD_ERROR, l = !1; break; case G.AUDIO_TRACK: o = r ? L.AUDIO_TRACK_LOAD_TIMEOUT : L.AUDIO_TRACK_LOAD_ERROR, l = !1; break; case G.SUBTITLE_TRACK: o = r ? L.SUBTITLE_TRACK_LOAD_TIMEOUT : L.SUBTITLE_LOAD_ERROR, l = !1 }h && this.resetInternalLoader(e.type); h = { type: N.NETWORK_ERROR, details: o, fatal: l, url: e.url, loader: h, context: e, error: n, networkDetails: t, stats: s }; i && (n = (null == t ? void 0 : t.url) || e.url, h.response = ct({ url: n, data: void 0 }, i)), this.hls.trigger(m.ERROR, h) } handlePlaylistLoaded(e, t, r, i, s, a) { var n = this.hls, { type: o, level: l, id: h, groupId: d, deliveryDirectives: u } = i, c = xe(t, i), f = Cs(i), g = "number" == typeof i.level && f === U.MAIN ? l : void 0; if (e.fragments.length) { e.targetduration || (e.playlistParsingError = new Error("Missing Target Duration")); var l = e.playlistParsingError; if (l) n.trigger(m.ERROR, { type: N.NETWORK_ERROR, details: L.LEVEL_PARSING_ERROR, fatal: !1, url: c, error: l, reason: l.message, response: t, context: i, level: g, parent: f, networkDetails: s, stats: r }); else switch (e.live && a && (a.getCacheAge && (e.ageHeader = a.getCacheAge() || 0), !a.getCacheAge || isNaN(e.ageHeader)) && (e.ageHeader = 0), o) { case G.MANIFEST: case G.LEVEL: n.trigger(m.LEVEL_LOADED, { details: e, level: g || 0, id: h || 0, stats: r, networkDetails: s, deliveryDirectives: u }); break; case G.AUDIO_TRACK: n.trigger(m.AUDIO_TRACK_LOADED, { details: e, id: h || 0, groupId: d || "", stats: r, networkDetails: s, deliveryDirectives: u }); break; case G.SUBTITLE_TRACK: n.trigger(m.SUBTITLE_TRACK_LOADED, { details: e, id: h || 0, groupId: d || "", stats: r, networkDetails: s, deliveryDirectives: u }) } } else l = new Error("No Segments found in Playlist"), n.trigger(m.ERROR, { type: N.NETWORK_ERROR, details: L.LEVEL_EMPTY_ERROR, fatal: !1, url: c, error: l, reason: l.message, response: t, context: i, level: g, parent: f, networkDetails: s, stats: r }) } } function Ai(e, t) { let r; try { r = new Event("addtrack") } catch { (r = document.createEvent("Event")).initEvent("addtrack", !1, !1) } r.track = e, t.dispatchEvent(r) } function Li(t, r) { var e = t.mode; if ("disabled" === e && (t.mode = "hidden"), t.cues && !t.cues.getCueById(r.id)) try { if (t.addCue(r), !t.cues.getCueById(r.id)) throw new Error("addCue is failed for: " + r) } catch (e) { E.debug("[texttrack-utils]: " + e); var i = new self.TextTrackCue(r.startTime, r.endTime, r.text); i.id = r.id, t.addCue(i) } "disabled" === e && (t.mode = e) } function Bt(t) { var e = t.mode; if ("disabled" === e && (t.mode = "hidden"), t.cues) for (let e = t.cues.length; e--;)t.removeCue(t.cues[e]); "disabled" === e && (t.mode = e) } function Ge(t, e, r, i) { var s = t.mode; if ("disabled" === s && (t.mode = "hidden"), t.cues && 0 < t.cues.length) { var a = sn(t.cues, e, r); for (let e = 0; e < a.length; e++)i && !i(a[e]) || t.removeCue(a[e]) } "disabled" === s && (t.mode = s) } function en(e, t) { if (t < e[0].startTime) return 0; var r = e.length - 1; if (t > e[r].endTime) return -1; let i = 0, s = r; for (; i <= s;) { var a = Math.floor((s + i) / 2); if (t < e[a].startTime) s = a - 1; else { if (!(t > e[a].startTime && i < r)) return a; i = a + 1 } } return e[i].startTime - t < t - e[s].startTime ? i : s } function sn(r, i, s) { var a = [], n = en(r, i); if (-1 < n) for (let e = n, t = r.length; e < t; e++) { var o = r[e]; if (o.startTime >= i && o.endTime <= s) a.push(o); else if (o.startTime > s) return a } return a } var Tt = { audioId3: "org.id3", dateRange: "com.apple.quicktime.HLS", emsg: "https://aomedia.org/emsg/ID3" }; let rn = .25; function Ke() { if (!("u" < typeof self)) return self.WebKitDataCue || self.VTTCue || self.TextTrackCue } let Xt = (() => { var e = Ke(); try { new e(0, Number.POSITIVE_INFINITY, "") } catch { return Number.MAX_VALUE } return Number.POSITIVE_INFINITY })(); function Se(e, t) { return e.getTime() / 1e3 - t } function nn(e) { return Uint8Array.from(e.replace(/^0x/, "").replace(/([\da-fA-F]{2}) ?/g, "0x$1 ").replace(/ +$/, "").split(" ")).buffer } class an { constructor(e) { this.hls = void 0, this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {}, this.hls = e, this._registerListeners() } destroy() { this._unregisterListeners(), this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {}, this.hls = null } _registerListeners() { var e = this.hls; e.on(m.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(m.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(m.MANIFEST_LOADING, this.onManifestLoading, this), e.on(m.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this), e.on(m.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on(m.LEVEL_UPDATED, this.onLevelUpdated, this) } _unregisterListeners() { var e = this.hls; e.off(m.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(m.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(m.MANIFEST_LOADING, this.onManifestLoading, this), e.off(m.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this), e.off(m.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off(m.LEVEL_UPDATED, this.onLevelUpdated, this) } onMediaAttached(e, t) { this.media = t.media } onMediaDetaching() { this.id3Track && (Bt(this.id3Track), this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {}) } onManifestLoading() { this.dateRangeCuesAppended = {} } createTrack(e) { e = this.getID3Track(e.textTracks); return e.mode = "hidden", e } getID3Track(t) { if (this.media) { for (let e = 0; e < t.length; e++) { var r = t[e]; if ("metadata" === r.kind && "id3" === r.label) return Ai(r, this.media), r } return this.media.addTextTrack("metadata", "id3") } } onFragParsingMetadata(e, t) { if (this.media) { var { config: { enableEmsgMetadataCues: r, enableID3MetadataCues: i } } = this.hls; if (r || i) { var s = t.samples, a = (this.id3Track || (this.id3Track = this.createTrack(this.media)), Ke()); for (let e = 0; e < s.length; e++) { var n = s[e].type; if ((n !== Tt.emsg || r) && i) { var o = gi(s[e].data); if (o) { var l = s[e].pts; let t = l + s[e].duration; (t = t > Xt ? Xt : t) - l <= 0 && (t = l + rn); for (let e = 0; e < o.length; e++) { var h, d = o[e]; fi(d) || (this.updateId3CueEnds(l), (h = new a(l, t, "")).value = d, n && (h.type = n), this.id3Track.addCue(h)) } } } } } } } updateId3CueEnds(t) { var e, r = null == (e = this.id3Track) ? void 0 : e.cues; if (r) for (let e = r.length; e--;) { var i = r[e]; i.startTime < t && i.endTime === Xt && (i.endTime = t) } } onBufferFlushing(e, { startOffset: i, endOffset: s, type: a }) { var { id3Track: n, hls: o } = this; if (o) { let { enableEmsgMetadataCues: t, enableID3MetadataCues: r } = o.config; if (n && (t || r)) { let e; Ge(n, i, s, e = "audio" === a ? e => e.type === Tt.audioId3 && r : "video" === a ? e => e.type === Tt.emsg && t : e => e.type === Tt.audioId3 && r || e.type === Tt.emsg && t) } } } onLevelUpdated(e, { details: i }) { if (this.media && i.hasProgramDateTime && this.hls.config.enableDateRangeMetadataCues) { let { dateRangeCuesAppended: l, id3Track: r } = this, h = i.dateRanges, t = Object.keys(h); if (r) { var s = Object.keys(l).filter(e => !t.includes(e)); for (let e = s.length; e--;) { let t = s[e]; Object.keys(l[t].cues).forEach(e => { r.removeCue(l[t].cues[e]) }), delete l[t] } } i = i.fragments[i.fragments.length - 1]; if (0 !== t.length && F(null == i ? void 0 : i.programDateTime)) { this.id3Track || (this.id3Track = this.createTrack(this.media)); var d = i.programDateTime / 1e3 - i.start, u = Ke(); for (let e = 0; e < t.length; e++) { let r = t[e], i = h[r], s = l[r], a = (null == s ? void 0 : s.cues) || {}, n = (null == s ? void 0 : s.durationKnown) || !1; var c = Se(i.startDate, d); let o = Xt; var f = i.endDate, g = (f ? (o = Se(f, d), n = !0) : i.endOnNext && !n && (f = t.reduce((e, t) => { var r = h[t]; return r.class === i.class && r.id !== t && r.startDate > i.startDate && e.push(r), e }, []).sort((e, t) => e.startDate.getTime() - t.startDate.getTime())[0]) && (o = Se(f.startDate, d), n = !0), Object.keys(i.attr)); for (let e = 0; e < g.length; e++) { var m = g[e]; if (ur(m)) { let t = a[m]; if (t) n && !s.durationKnown && (t.endTime = o); else { let e = i.attr[m]; t = new u(c, o, ""), fr(m) && (e = nn(e)), t.value = { key: m, data: e }, t.type = Tt.dateRange, t.id = r, this.id3Track.addCue(t), a[m] = t } } } l[r] = { cues: a, dateRange: i, durationKnown: n } } } } } } class on { constructor(e) { this.hls = void 0, this.config = void 0, this.media = null, this.levelDetails = null, this.currentTime = 0, this.stallCount = 0, this._latency = null, this.timeupdateHandler = () => this.timeupdate(), this.hls = e, this.config = e.config, this.registerListeners() } get latency() { return this._latency || 0 } get maxLatency() { var { config: e, levelDetails: t } = this; return void 0 !== e.liveMaxLatencyDuration ? e.liveMaxLatencyDuration : t ? e.liveMaxLatencyDurationCount * t.targetduration : 0 } get targetLatency() { var e = this.levelDetails; if (null === e) return null; var { holdBack: e, partHoldBack: t, targetduration: r } = e, { liveSyncDuration: i, liveSyncDurationCount: s, lowLatencyMode: a } = this.config, n = this.hls.userConfig; let o = a && t || e; return (o = n.liveSyncDuration || n.liveSyncDurationCount || 0 === o ? void 0 !== i ? i : s * r : o) + Math.min(+this.stallCount, r) } get liveSyncPosition() { var e, t = this.estimateLiveEdge(), r = this.targetLatency, i = this.levelDetails; return null === t || null === r || null === i ? null : (e = i.edge, t = t - r - this.edgeStalled, r = e - (this.config.lowLatencyMode && i.partTarget || i.targetduration), Math.min(Math.max(e - i.totalduration, t), r)) } get drift() { var e = this.levelDetails; return null === e ? 1 : e.drift } get edgeStalled() { var e, t = this.levelDetails; return null === t ? 0 : (e = 3 * (this.config.lowLatencyMode && t.partTarget || t.targetduration), Math.max(t.age - e, 0)) } get forwardBufferLength() { var e, { media: t, levelDetails: r } = this; return t && r ? ((e = t.buffered.length) ? t.buffered.end(e - 1) : r.edge) - this.currentTime : 0 } destroy() { this.unregisterListeners(), this.onMediaDetaching(), this.levelDetails = null, this.hls = this.timeupdateHandler = null } registerListeners() { this.hls.on(m.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.on(m.MEDIA_DETACHING, this.onMediaDetaching, this), this.hls.on(m.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.on(m.LEVEL_UPDATED, this.onLevelUpdated, this), this.hls.on(m.ERROR, this.onError, this) } unregisterListeners() { this.hls.off(m.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.off(m.MEDIA_DETACHING, this.onMediaDetaching, this), this.hls.off(m.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.off(m.LEVEL_UPDATED, this.onLevelUpdated, this), this.hls.off(m.ERROR, this.onError, this) } onMediaAttached(e, t) { this.media = t.media, this.media.addEventListener("timeupdate", this.timeupdateHandler) } onMediaDetaching() { this.media && (this.media.removeEventListener("timeupdate", this.timeupdateHandler), this.media = null) } onManifestLoading() { this.levelDetails = null, this._latency = null, this.stallCount = 0 } onLevelUpdated(e, { details: t }) { (this.levelDetails = t).advanced && this.timeupdate(), !t.live && this.media && this.media.removeEventListener("timeupdate", this.timeupdateHandler) } onError(e, t) { t.details === L.BUFFER_STALLED_ERROR && (this.stallCount++, null != (t = this.levelDetails)) && t.live && E.warn("[playback-rate-controller]: Stall detected, adjusting target latency") } timeupdate() { var e, t, r, { media: i, levelDetails: s } = this; i && s && (this.currentTime = i.currentTime, null !== (t = this.computeLatency())) && (this._latency = t, { lowLatencyMode: r, maxLiveSyncPlaybackRate: e } = this.config, r) && 1 !== e && null !== (r = this.targetLatency) && (t = t - r, r = Math.min(this.maxLatency, r + s.targetduration), s.live && t < r && .05 < t && 1 < this.forwardBufferLength ? (s = Math.min(2, Math.max(1, e)), r = Math.round(2 / (1 + Math.exp(-.75 * t - this.edgeStalled)) * 20) / 20, i.playbackRate = Math.min(s, Math.max(1, r))) : 1 !== i.playbackRate && 0 !== i.playbackRate && (i.playbackRate = 1)) } estimateLiveEdge() { var e = this.levelDetails; return null === e ? null : e.edge + e.age } computeLatency() { var e = this.estimateLiveEdge(); return null === e ? null : e - this.currentTime } } let He = ["NONE", "TYPE-0", "TYPE-1", null]; var Vt = { No: "", Yes: "YES", v2: "v2" }; function ln(e, t) { var { canSkipUntil: e, canSkipDateRanges: r, endSN: i } = e; return e && (void 0 !== t ? t - i : 0) < e ? r ? Vt.v2 : Vt.Yes : Vt.No } class ks { constructor(e, t, r) { this.msn = void 0, this.part = void 0, this.skip = void 0, this.msn = e, this.part = t, this.skip = r } addDirectives(e) { e = new self.URL(e); return void 0 !== this.msn && e.searchParams.set("_HLS_msn", this.msn.toString()), void 0 !== this.part && e.searchParams.set("_HLS_part", this.part.toString()), this.skip && e.searchParams.set("_HLS_skip", this.skip), e.href } } class Yt { constructor(e) { this._attrs = void 0, this.audioCodec = void 0, this.bitrate = void 0, this.codecSet = void 0, this.height = void 0, this.id = void 0, this.name = void 0, this.videoCodec = void 0, this.width = void 0, this.unknownCodecs = void 0, this.audioGroupIds = void 0, this.details = void 0, this.fragmentError = 0, this.loadError = 0, this.loaded = void 0, this.realBitrate = 0, this.textGroupIds = void 0, this.url = void 0, this._urlId = 0, this.url = [e.url], this._attrs = [e.attrs], this.bitrate = e.bitrate, e.details && (this.details = e.details), this.id = e.id || 0, this.name = e.name, this.width = e.width || 0, this.height = e.height || 0, this.audioCodec = e.audioCodec, this.videoCodec = e.videoCodec, this.unknownCodecs = e.unknownCodecs, this.codecSet = [e.videoCodec, e.audioCodec].filter(e => e).join(",").replace(/\.[^.,]+/g, "") } get maxBitrate() { return Math.max(this.realBitrate, this.bitrate) } get attrs() { return this._attrs[this._urlId] } get pathwayId() { return this.attrs["PATHWAY-ID"] || "." } get uri() { return this.url[this._urlId] || "" } get urlId() { return this._urlId } set urlId(e) { e %= this.url.length; this._urlId !== e && (this.fragmentError = 0, this.loadError = 0, this.details = void 0, this._urlId = e) } get audioGroupId() { var e; return null == (e = this.audioGroupIds) ? void 0 : e[this.urlId] } get textGroupId() { var e; return null == (e = this.textGroupIds) ? void 0 : e[this.urlId] } addFallback(e) { this.url.push(e.url), this._attrs.push(e.attrs) } } function ve(r, i) { var s = i.startPTS; if (F(s)) { let e = 0, t; (t = i.sn > r.sn ? (e = s - r.start, r) : (e = r.start - s, i)).duration !== e && (t.duration = e) } else i.sn > r.sn ? r.cc === i.cc && r.minEndPTS ? i.start = r.start + (r.minEndPTS - r.start) : i.start = r.start + r.duration : i.start = Math.max(r.start - i.duration, 0) } function Ri(e, t, r, i, s, a) { i - r <= 0 && (E.warn("Fragment should have a positive duration", t), i = r + t.duration, a = s + t.duration); let n = r, o = i; var l = t.startPTS, h = t.endPTS, d = (F(l) && (d = Math.abs(l - r), F(t.deltaPTS) ? t.deltaPTS = Math.max(d, t.deltaPTS) : t.deltaPTS = d, n = Math.max(r, l), r = Math.min(r, l), s = Math.min(s, t.startDTS), o = Math.min(i, h), i = Math.max(i, h), a = Math.max(a, t.endDTS)), r - t.start), l = (0 !== t.start && (t.start = r), t.duration = i - t.start, t.startPTS = r, t.maxStartPTS = n, t.startDTS = s, t.endPTS = i, t.minEndPTS = o, t.endDTS = a, t.sn); if (!e || l < e.startSN || l > e.endSN) return 0; let u; var h = l - e.startSN, c = e.fragments; for (c[h] = t, u = h; 0 < u; u--)ve(c[u], c[u - 1]); for (u = h; u < c.length - 1; u++)ve(c[u], c[u + 1]); return e.fragmentHint && ve(c[c.length - 1], e.fragmentHint), e.PTSKnown = e.alignedSliding = !0, d } function cn(e, r) { let i = null; var t = e.fragments; for (let e = t.length - 1; 0 <= e; e--) { var s = t[e].initSegment; if (s) { i = s; break } } e.fragmentHint && delete e.fragmentHint.endPTS; let a = 0, n; if (un(e, r, (e, t) => { e.relurl && (a = e.cc - t.cc), F(e.startPTS) && F(e.endPTS) && (t.start = t.startPTS = e.startPTS, t.startDTS = e.startDTS, t.maxStartPTS = e.maxStartPTS, t.endPTS = e.endPTS, t.endDTS = e.endDTS, t.minEndPTS = e.minEndPTS, t.duration = e.endPTS - e.startPTS, t.duration && (n = t), r.PTSKnown = r.alignedSliding = !0), t.elementaryStreams = e.elementaryStreams, t.loader = e.loader, t.stats = e.stats, t.urlId = e.urlId, e.initSegment && (t.initSegment = e.initSegment, i = e.initSegment) }), i && (r.fragmentHint ? r.fragments.concat(r.fragmentHint) : r.fragments).forEach(e => { var t; e.initSegment && e.initSegment.relurl !== (null == (t = i) ? void 0 : t.relurl) || (e.initSegment = i) }), r.skippedSegments) if (r.deltaUpdateFailed = r.fragments.some(e => !e), r.deltaUpdateFailed) { E.warn("[level-helper] Previous playlist missing segments skipped in delta playlist"); for (let e = r.skippedSegments; e--;)r.fragments.shift(); r.startSN = r.fragments[0].sn, r.startCC = r.fragments[0].cc } else r.canSkipDateRanges && (r.dateRanges = hn(e.dateRanges, r.dateRanges, r.recentlyRemovedDateranges)); var o = r.fragments; if (a) { E.warn("discontinuity sliding from playlist, take drift into account"); for (let e = 0; e < o.length; e++)o[e].cc += a } r.skippedSegments && (r.startCC = r.fragments[0].cc), dn(e.partList, r.partList, (e, t) => { t.elementaryStreams = e.elementaryStreams, t.stats = e.stats }), n ? Ri(r, n, n.startPTS, n.endPTS, n.startDTS, n.endDTS) : Ii(e, r), o.length && (r.totalduration = r.edge - o[0].start), r.driftStartTime = e.driftStartTime, r.driftStart = e.driftStart; var l, h = r.advancedDateTime; r.advanced && h ? (l = r.edge, r.driftStart || (r.driftStartTime = h, r.driftStart = l), r.driftEndTime = h, r.driftEnd = l) : (r.driftEndTime = e.driftEndTime, r.driftEnd = e.driftEnd, r.advancedDateTime = e.advancedDateTime) } function hn(e, r, t) { let i = tt({}, e); return t && t.forEach(e => { delete i[e] }), Object.keys(r).forEach(e => { var t = new oi(r[e].attr, i[e]); t.isValid ? i[e] = t : E.warn(`Ignoring invalid Playlist Delta Update DATERANGE tag: "${JSON.stringify(r[e].attr)}"`) }), i } function dn(i, s, a) { if (i && s) { let r = 0; for (let e = 0, t = i.length; e <= t; e++) { var n = i[e], o = s[e + r]; n && o && n.index === o.index && n.fragment.sn === o.fragment.sn ? a(n, o) : r-- } } } function un(e, r, i) { var s = r.skippedSegments, a = Math.max(e.startSN, r.startSN) - r.startSN, n = (e.fragmentHint ? 1 : 0) + (s ? r.endSN : Math.min(e.endSN, r.endSN)) - r.startSN, o = r.startSN - e.startSN, l = r.fragmentHint ? r.fragments.concat(r.fragmentHint) : r.fragments, h = e.fragmentHint ? e.fragments.concat(e.fragmentHint) : e.fragments; for (let t = a; t <= n; t++) { var d = h[o + t]; let e = l[t]; s && !e && t < s && (e = r.fragments[t] = d), d && e && i(d, e) } } function Ii(e, t) { var r = t.startSN + t.skippedSegments - e.startSN, e = e.fragments; r < 0 || r >= e.length || Ve(t, e[r].start) } function Ve(t, r) { if (r) { var i = t.fragments; for (let e = t.skippedSegments; e < i.length; e++)i[e].start += r; t.fragmentHint && (t.fragmentHint.start += r) } } function fn(e, t = 1 / 0) { let r = 1e3 * e.targetduration; return e.updated ? (e = e.fragments).length && 4 * r > t && (t = 1e3 * e[e.length - 1].duration) < r && (r = t) : r /= 2, Math.round(r) } function gn(e, t, r) { if (null == e || !e.details) return null; e = e.details; let i = e.fragments[t - e.startSN]; return i || (i = e.fragmentHint) && i.sn === t ? i : t < e.startSN && r && r.sn === t ? r : null } function _s(e, t, r) { return null != e && e.details ? bi(null == (e = e.details) ? void 0 : e.partList, t, r) : null } function bi(t, r, i) { if (t) for (let e = t.length; e--;) { var s = t[e]; if (s.index === i && s.fragment.sn === r) return s } return null } function oe(e) { switch (e.details) { case L.FRAG_LOAD_TIMEOUT: case L.KEY_LOAD_TIMEOUT: case L.LEVEL_LOAD_TIMEOUT: case L.MANIFEST_LOAD_TIMEOUT: return !0 }return !1 } function ws(e, t) { t = oe(t); return e.default[`${t ? "timeout" : "error"}Retry`] } function Ze(e, t) { t = "linear" === e.backoff ? 1 : Math.pow(2, t); return Math.min(t * e.retryDelayMs, e.maxRetryDelayMs) } function Ps(e) { return ct(ct({}, e), { errorRetry: null, timeoutRetry: null }) } function le(e, t, r, i) { return !!e && t < e.maxNumRetry && (mn(i) || !!r) } function mn(e) { return 0 === e && !1 === navigator.onLine || !!e && (e < 400 || 499 < e) } let Di = { search: function (e, t) { let r = 0, i = e.length - 1, s, a; for (; r <= i;) { var n = t(a = e[s = (r + i) / 2 | 0]); if (0 < n) r = 1 + s; else { if (!(n < 0)) return a; i = s - 1 } } return null } }; function pn(t, r, i) { if (null !== r && Array.isArray(t) && t.length && F(r)) { var e = t[0].programDateTime; if (!(r < (e || 0))) { e = t[t.length - 1].endProgramDateTime; if (!((e || 0) <= r)) { i = i || 0; for (let e = 0; e < t.length; ++e) { var s = t[e]; if (Tn(r, i, s)) return s } } } } return null } function qt(e, t, r = 0, i = 0) { let s = null; return e ? s = t[e.sn - t[0].sn + 1] || null : 0 === r && 0 === t[0].start && (s = t[0]), s && 0 === We(r, i, s) || !(t = Di.search(t, We.bind(null, r, i))) || t === e && s ? s : t } function We(e = 0, t = 0, r) { return r.start <= e && r.start + r.duration > e ? 0 : (t = Math.min(t, r.duration + (r.deltaPTS || 0)), r.start + r.duration - t <= e ? 1 : r.start - t > e && r.start ? -1 : 0) } function Tn(e, t, r) { t = 1e3 * Math.min(t, r.duration + (r.deltaPTS || 0)); return (r.endProgramDateTime || 0) - t > e } function yn(e, t) { return Di.search(e, e => e.cc < t ? 1 : e.cc > t ? -1 : 0) } let En = 3e5; var ot = { DoNothing: 0, SendEndCallback: 1, SendAlternateToPenaltyBox: 2, RemoveAlternatePermanently: 3, InsertDiscontinuity: 4, RetryRequest: 5 }, mt = { None: 0, MoveAllAlternatesMatchingHost: 1, MoveAllAlternatesMatchingHDCP: 2, SwitchToSDR: 4 }; class xn { constructor(e) { this.hls = void 0, this.playlistError = 0, this.penalizedRenditions = {}, this.log = void 0, this.warn = void 0, this.error = void 0, this.hls = e, this.log = E.log.bind(E, "[info]:"), this.warn = E.warn.bind(E, "[warning]:"), this.error = E.error.bind(E, "[error]:"), this.registerListeners() } registerListeners() { var e = this.hls; e.on(m.ERROR, this.onError, this), e.on(m.MANIFEST_LOADING, this.onManifestLoading, this), e.on(m.LEVEL_UPDATED, this.onLevelUpdated, this) } unregisterListeners() { var e = this.hls; e && (e.off(m.ERROR, this.onError, this), e.off(m.ERROR, this.onErrorOut, this), e.off(m.MANIFEST_LOADING, this.onManifestLoading, this), e.off(m.LEVEL_UPDATED, this.onLevelUpdated, this)) } destroy() { this.unregisterListeners(), this.hls = null, this.penalizedRenditions = {} } startLoad(e) { this.playlistError = 0 } stopLoad() { } getVariantLevelIndex(e) { return (null == e ? void 0 : e.type) === U.MAIN ? e.level : this.hls.loadLevel } onManifestLoading() { this.playlistError = 0, this.penalizedRenditions = {} } onLevelUpdated() { this.playlistError = 0 } onError(e, t) { if (!t.fatal) { var r, i = this.hls, s = t.context; switch (t.details) { case L.FRAG_LOAD_ERROR: case L.FRAG_LOAD_TIMEOUT: case L.KEY_LOAD_ERROR: case L.KEY_LOAD_TIMEOUT: return void (t.errorAction = this.getFragRetryOrSwitchAction(t)); case L.FRAG_GAP: case L.FRAG_PARSING_ERROR: case L.FRAG_DECRYPT_ERROR: return t.errorAction = this.getFragRetryOrSwitchAction(t), void (t.errorAction.action = ot.SendAlternateToPenaltyBox); case L.LEVEL_EMPTY_ERROR: case L.LEVEL_PARSING_ERROR: var a = t.parent === U.MAIN ? t.level : i.loadLevel; return void (t.details === L.LEVEL_EMPTY_ERROR && null != (n = t.context) && null != (n = n.levelDetails) && n.live ? t.errorAction = this.getPlaylistRetryOrSwitchAction(t, a) : (t.levelRetry = !1, t.errorAction = this.getLevelSwitchAction(t, a))); case L.LEVEL_LOAD_ERROR: case L.LEVEL_LOAD_TIMEOUT: return void ("number" == typeof (null == s ? void 0 : s.level) && (t.errorAction = this.getPlaylistRetryOrSwitchAction(t, s.level))); case L.AUDIO_TRACK_LOAD_ERROR: case L.AUDIO_TRACK_LOAD_TIMEOUT: case L.SUBTITLE_LOAD_ERROR: case L.SUBTITLE_TRACK_LOAD_TIMEOUT: if (s) { var n = i.levels[i.loadLevel]; if (n && (s.type === G.AUDIO_TRACK && s.groupId === n.audioGroupId || s.type === G.SUBTITLE_TRACK && s.groupId === n.textGroupId)) return t.errorAction = this.getPlaylistRetryOrSwitchAction(t, i.loadLevel), t.errorAction.action = ot.SendAlternateToPenaltyBox, void (t.errorAction.flags = mt.MoveAllAlternatesMatchingHost) } return; case L.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED: var a = i.levels[i.loadLevel], n = null == a ? void 0 : a.attrs["HDCP-LEVEL"]; return void (n && (t.errorAction = { action: ot.SendAlternateToPenaltyBox, flags: mt.MoveAllAlternatesMatchingHDCP, hdcpLevel: n })); case L.BUFFER_ADD_CODEC_ERROR: case L.REMUX_ALLOC_ERROR: return void (t.errorAction = this.getLevelSwitchAction(t, null != (a = t.level) ? a : i.loadLevel)); case L.INTERNAL_EXCEPTION: case L.BUFFER_APPENDING_ERROR: case L.BUFFER_APPEND_ERROR: case L.BUFFER_FULL_ERROR: case L.LEVEL_SWITCH_ERROR: case L.BUFFER_STALLED_ERROR: case L.BUFFER_SEEK_OVER_HOLE: case L.BUFFER_NUDGE_ON_STALL: return void (t.errorAction = { action: ot.DoNothing, flags: mt.None }) }t.type === N.KEY_SYSTEM_ERROR && (r = this.getVariantLevelIndex(t.frag), t.levelRetry = !1, t.errorAction = this.getLevelSwitchAction(t, r)) } } getPlaylistRetryOrSwitchAction(e, t) { var r = ws(this.hls.config.playlistLoadPolicy, e), i = this.playlistError++, s = null == (s = e.response) ? void 0 : s.code; return le(r, i, oe(e), s) ? { action: ot.RetryRequest, flags: mt.None, retryConfig: r, retryCount: i } : (s = this.getLevelSwitchAction(e, t), r && (s.retryConfig = r, s.retryCount = i), s) } getFragRetryOrSwitchAction(e) { var t = this.hls, r = this.getVariantLevelIndex(e.frag), i = t.levels[r], { fragLoadPolicy: s, keyLoadPolicy: a } = t.config, a = ws(e.details.startsWith("key") ? a : s, e), s = t.levels.reduce((e, t) => e + t.fragmentError, 0); if (i) { e.details !== L.FRAG_GAP && i.fragmentError++; i = null == (t = e.response) ? void 0 : t.code; if (le(a, s, oe(e), i)) return { action: ot.RetryRequest, flags: mt.None, retryConfig: a, retryCount: s } } t = this.getLevelSwitchAction(e, r); return a && (t.retryConfig = a, t.retryCount = s), t } getLevelSwitchAction(i, e) { var s = this.hls, a = (null == e && (e = s.loadLevel), this.hls.levels[e]); if (a && (a.loadError++, s.autoLevelEnabled)) { let e, t, r = -1; var n = s.levels, o = null == (e = i.frag) ? void 0 : e.type, { type: l, groupId: h } = null != (t = i.context) ? t : {}; for (let e = n.length; e--;) { var d = (e + s.loadLevel) % n.length; if (d !== s.loadLevel && 0 === n[d].loadError) { var u = n[d]; if (i.details === L.FRAG_GAP && i.frag) { var c = n[d].details; if (c) { c = qt(i.frag, c.fragments, i.frag.start); if (null != c && c.gap) continue } } else { if (l === G.AUDIO_TRACK && h === u.audioGroupId || l === G.SUBTITLE_TRACK && h === u.textGroupId) continue; if (o === U.AUDIO && a.audioGroupId === u.audioGroupId || o === U.SUBTITLE && a.textGroupId === u.textGroupId) continue } r = d; break } } if (-1 < r && s.loadLevel !== r) return i.levelRetry = !0, this.playlistError = 0, { action: ot.SendAlternateToPenaltyBox, flags: mt.None, nextAutoLevel: r } } return { action: ot.SendAlternateToPenaltyBox, flags: mt.MoveAllAlternatesMatchingHost } } onErrorOut(e, t) { var r; switch (null == (r = t.errorAction) ? void 0 : r.action) { case ot.DoNothing: break; case ot.SendAlternateToPenaltyBox: this.sendAlternateToPenaltyBox(t), t.errorAction.resolved || t.details === L.FRAG_GAP || (t.fatal = !0) }t.fatal && this.hls.stopLoad() } sendAlternateToPenaltyBox(e) { var t = this.hls, r = e.errorAction; if (r) { var { flags: i, hdcpLevel: s, nextAutoLevel: a } = r; switch (i) { case mt.None: this.switchLevel(e, a); break; case mt.MoveAllAlternatesMatchingHost: r.resolved || (r.resolved = this.redundantFailover(e)); break; case mt.MoveAllAlternatesMatchingHDCP: s && (t.maxHdcpLevel = He[He.indexOf(s) - 1], r.resolved = !0), this.warn(`Restricting playback to HDCP-LEVEL of "${t.maxHdcpLevel}" or lower`) }r.resolved || this.switchLevel(e, a) } } switchLevel(e, t) { void 0 !== t && e.errorAction && (this.warn(`switching to level ${t} after ` + e.details), this.hls.nextAutoLevel = t, e.errorAction.resolved = !0, this.hls.nextLoadLevel = this.hls.nextAutoLevel) } redundantFailover(i) { var { hls: s, penalizedRenditions: a } = this, n = i.parent === U.MAIN ? i.level : s.loadLevel, o = s.levels[n], l = o.url.length, h = (i.frag || o).urlId; o.urlId !== h || i.frag && !o.details || this.penalizeRendition(o, i); for (let r = 1; r < l; r++) { let t = (h + r) % l, e = a[t]; if (!e || Sn(e, i, a[h])) return this.warn(`Switching to Redundant Stream ${1 + t}/${l}: "${o.url[t]}" after ` + i.details), this.playlistError = 0, s.levels.forEach(e => { e.urlId = t }), s.nextLoadLevel = n, !0 } return !1 } penalizeRendition(e, t) { var r = this.penalizedRenditions, i = r[e.urlId] || { lastErrorPerfMs: 0, errors: [], details: void 0 }; i.lastErrorPerfMs = performance.now(), i.errors.push(t), i.details = e.details, r[e.urlId] = i } } function Sn(e, t, r) { if (performance.now() - e.lastErrorPerfMs > En) return !0; var i = e.details; if (t.details === L.FRAG_GAP && i && t.frag) { var s = t.frag.start, s = qt(null, i.fragments, s); if (s && !s.gap) return !0 } if (r && e.errors.length < r.errors.length) { s = e.errors[e.errors.length - 1]; if (i && s.frag && t.frag && Math.abs(s.frag.start - t.frag.start) > 3 * i.targetduration) return !0 } return !1 } class ts { constructor(e, t) { this.hls = void 0, this.timer = -1, this.requestScheduled = -1, this.canLoad = !1, this.log = void 0, this.warn = void 0, this.log = E.log.bind(E, t + ":"), this.warn = E.warn.bind(E, t + ":"), this.hls = e } destroy() { this.clearTimer(), this.hls = this.log = this.warn = null } clearTimer() { clearTimeout(this.timer), this.timer = -1 } startLoad() { this.canLoad = !0, this.requestScheduled = -1, this.loadPlaylist() } stopLoad() { this.canLoad = !1, this.clearTimer() } switchParams(i, s) { var a = null == s ? void 0 : s.renditionReports; if (a) { let r = -1; for (let e = 0; e < a.length; e++) { var n = a[e]; let t; try { t = new self.URL(n.URI, s.url).href } catch (e) { E.warn("Could not construct new URL for Rendition Report: " + e), t = n.URI || "" } if (t === i) { r = e; break } t === i.substring(0, t.length) && (r = e) } if (-1 !== r) { var t = a[r], o = parseInt(t["LAST-MSN"]) || (null == s ? void 0 : s.lastPartSn); let e = parseInt(t["LAST-PART"]) || (null == s ? void 0 : s.lastPartIndex); return this.hls.config.lowLatencyMode && (t = Math.min(s.age - s.partTarget, s.targetduration), 0 <= e) && t > s.partTarget && (e += 1), new ks(o, 0 <= e ? e : void 0, Vt.No) } } } loadPlaylist(e) { -1 === this.requestScheduled && (this.requestScheduled = self.performance.now()) } shouldLoadPlaylist(e) { return this.canLoad && !!e && !!e.url && (!e.details || e.details.live) } shouldReloadPlaylist(e) { return -1 === this.timer && -1 === this.requestScheduled && this.shouldLoadPlaylist(e) } playlistLoaded(e, s, a) { var { details: n, stats: o } = s, l = self.performance.now(), h = o.loading.first ? Math.max(0, l - o.loading.first) : 0; if (n.advancedDateTime = Date.now() - h, n.live || null != a && a.live) { if (n.reloaded(a), a && this.log(`live playlist ${e} ` + (n.advanced ? "REFRESHED " + n.lastPartSn + "-" + n.lastPartIndex : "MISSED")), a && 0 < n.fragments.length && cn(a, n), this.canLoad && n.live) { let t, r, i; if (n.canBlockReload && n.endSN && n.advanced) { var h = this.hls.config.lowLatencyMode, d = n.lastPartSn, u = n.endSN, c = n.lastPartIndex, f = d === u, d = (-1 !== c ? (r = f ? u + 1 : d, i = f ? h ? 0 : c : c + 1) : r = u + 1, n.age), c = d + n.ageHeader; let e = Math.min(c - n.partTarget, 1.5 * n.targetduration); if (0 < e && (a && e > a.tuneInGoal ? (this.warn(`CDN Tune-in goal increased from: ${a.tuneInGoal} to: ${e} with playlist age: ` + n.age), e = 0) : (u = Math.floor(e / n.targetduration), r += u, void 0 !== i && (c = Math.round(e % n.targetduration / n.partTarget), i += c), this.log(`CDN Tune-in age: ${n.ageHeader}s last advanced ${d.toFixed(2)}s goal: ${e} skip sn ${u} to part ` + i)), n.tuneInGoal = e), t = this.getDeliveryDirectives(n, s.deliveryDirectives, r, i), h || !f) return void this.loadPlaylist(t) } else n.canBlockReload && (t = this.getDeliveryDirectives(n, s.deliveryDirectives, r, i)); a = this.hls.mainForwardBufferInfo, c = a ? a.end - a.len : 0, d = fn(n, 1e3 * (n.edge - c)), u = (n.updated && l > this.requestScheduled + d && (this.requestScheduled = o.loading.start), void 0 !== r && n.canBlockReload ? this.requestScheduled = o.loading.first + d - (1e3 * n.partTarget || 1e3) : -1 === this.requestScheduled || this.requestScheduled + d < l ? this.requestScheduled = l : this.requestScheduled - l <= 0 && (this.requestScheduled += d), this.requestScheduled - l), u = Math.max(0, u); this.log(`reload live playlist ${e} in ${Math.round(u)} ms`), this.timer = self.setTimeout(() => this.loadPlaylist(t), u) } } else this.clearTimer() } getDeliveryDirectives(e, t, r, i) { let s = ln(e, r); return null != t && t.skip && e.deltaUpdateFailed && (r = t.msn, i = t.part, s = Vt.No), new ks(r, i, s) } checkRetry(e) { var t = e.details, r = oe(e), i = e.errorAction, { action: s, retryCount: a = 0, retryConfig: n } = i || {}, s = !!i && !!n && (s === ot.RetryRequest || !i.resolved && s === ot.SendAlternateToPenaltyBox); if (s) { if (this.requestScheduled = -1, a >= n.maxNumRetry) return !1; r && null != (r = e.context) && r.deliveryDirectives ? (this.warn(`Retrying playlist loading ${a + 1}/${n.maxNumRetry} after "${t}" without delivery-directives`), this.loadPlaylist()) : (r = Ze(n, a), this.timer = self.setTimeout(() => this.loadPlaylist(), r), this.warn(`Retrying playlist loading ${a + 1}/${n.maxNumRetry} after "${t}" in ${r}ms`)), e.levelRetry = !0, i.resolved = !0 } return s } } let Ae; class vn extends ts { constructor(e, t) { super(e, "[level-controller]"), this._levels = [], this._firstLevel = -1, this._startLevel = void 0, this.currentLevel = null, this.currentLevelIndex = -1, this.manualLevelIndex = -1, this.steering = void 0, this.onParsedComplete = void 0, this.steering = t, this._registerListeners() } _registerListeners() { var e = this.hls; e.on(m.MANIFEST_LOADING, this.onManifestLoading, this), e.on(m.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(m.LEVEL_LOADED, this.onLevelLoaded, this), e.on(m.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(m.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), e.on(m.FRAG_LOADED, this.onFragLoaded, this), e.on(m.ERROR, this.onError, this) } _unregisterListeners() { var e = this.hls; e.off(m.MANIFEST_LOADING, this.onManifestLoading, this), e.off(m.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(m.LEVEL_LOADED, this.onLevelLoaded, this), e.off(m.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(m.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), e.off(m.FRAG_LOADED, this.onFragLoaded, this), e.off(m.ERROR, this.onError, this) } destroy() { this._unregisterListeners(), this.steering = null, this.resetLevels(), super.destroy() } startLoad() { this._levels.forEach(e => { e.loadError = 0, e.fragmentError = 0 }), super.startLoad() } resetLevels() { this._startLevel = void 0, this.manualLevelIndex = -1, this.currentLevelIndex = -1, this.currentLevel = null, this._levels = [] } onManifestLoading(e, t) { this.resetLevels() } onManifestLoaded(e, t) { let o = [], l = {}, h; t.levels.forEach(e => { var t = e.attrs, { AUDIO: r, CODECS: t, "FRAME-RATE": i, "PATHWAY-ID": s, RESOLUTION: a, SUBTITLES: n } = (-1 !== (null == (r = e.audioCodec) ? void 0 : r.indexOf("mp4a.40.34")) && (Ae = Ae || /chrome|firefox/i.test(navigator.userAgent)) && (e.audioCodec = void 0), t), s = `${s || "."}-` + e.bitrate + `-${a}-${i}-` + t; (h = l[s]) ? h.addFallback(e) : (h = new Yt(e), l[s] = h, o.push(h)), ce(h, "audio", r), ce(h, "text", n) }), this.filterAndSortMediaOptions(o, t) } filterAndSortMediaOptions(e, r) { let i = [], s = [], a = !1, n = !1, o = !1, l = e.filter(({ audioCodec: e, videoCodec: t, width: r, height: i, unknownCodecs: s }) => (a = a || !(!r || !i), n = n || !!t, o = o || !!e, !(null != s && s.length) && (!e || Ee(e, "audio")) && (!t || Ee(t, "video")))); if (0 === (l = (a || n) && o ? l.filter(({ videoCodec: e, width: t, height: r }) => !!e || !(!t || !r)) : l).length) Promise.resolve().then(() => { var e; this.hls && (e = new Error("no level with compatible codecs found in manifest"), this.hls.trigger(m.ERROR, { type: N.MEDIA_ERROR, details: L.MANIFEST_INCOMPATIBLE_CODECS_ERROR, fatal: !0, url: r.url, error: e, reason: e.message })) }); else { r.audioTracks && Fs(i = r.audioTracks.filter(e => !e.audioCodec || Ee(e.audioCodec, "audio"))), r.subtitles && Fs(s = r.subtitles); var h = l.slice(0); l.sort((e, t) => e.attrs["HDCP-LEVEL"] !== t.attrs["HDCP-LEVEL"] ? (e.attrs["HDCP-LEVEL"] || "") > (t.attrs["HDCP-LEVEL"] || "") ? 1 : -1 : e.bitrate !== t.bitrate ? e.bitrate - t.bitrate : e.attrs["FRAME-RATE"] !== t.attrs["FRAME-RATE"] ? e.attrs.decimalFloatingPoint("FRAME-RATE") - t.attrs.decimalFloatingPoint("FRAME-RATE") : e.attrs.SCORE !== t.attrs.SCORE ? e.attrs.decimalFloatingPoint("SCORE") - t.attrs.decimalFloatingPoint("SCORE") : a && e.height !== t.height ? e.height - t.height : 0); let t = h[0]; if (this.steering && (l = this.steering.filterParsedLevels(l)).length !== h.length) for (let e = 0; e < h.length; e++)if (h[e].pathwayId === l[0].pathwayId) { t = h[e]; break } this._levels = l; for (let e = 0; e < l.length; e++)if (l[e] === t) { this._firstLevel = e, this.log(`manifest loaded, ${l.length} level(s) found, first bitrate: ` + t.bitrate); break } e = o && !n, e = { levels: l, audioTracks: i, subtitleTracks: s, sessionData: r.sessionData, sessionKeys: r.sessionKeys, firstLevel: this._firstLevel, stats: r.stats, audio: o, video: n, altAudio: !e && i.some(e => !!e.url) }; this.hls.trigger(m.MANIFEST_PARSED, e), (this.hls.config.autoStartLoad || this.hls.forceStartLoad) && this.hls.startLoad(this.hls.config.startPosition) } } get levels() { return 0 === this._levels.length ? null : this._levels } get level() { return this.currentLevelIndex } set level(e) { var t = this._levels; if (0 !== t.length) { if (e < 0 || e >= t.length) { var r = new Error("invalid level idx"), i = e < 0; if (this.hls.trigger(m.ERROR, { type: N.OTHER_ERROR, details: L.LEVEL_SWITCH_ERROR, level: e, fatal: i, error: r, reason: r.message }), i) return; e = Math.min(e, t.length - 1) } var r = this.currentLevelIndex, i = this.currentLevel, s = i ? i.attrs["PATHWAY-ID"] : void 0, t = t[e], a = t.attrs["PATHWAY-ID"]; this.currentLevelIndex = e, this.currentLevel = t, r === e && t.details && i && s === a || (this.log(`Switching to level ${e}${a ? " with Pathway " + a : ""} from level ` + r + (s ? " with Pathway " + s : "")), delete (a = tt({}, t, { level: e, maxBitrate: t.maxBitrate, attrs: t.attrs, uri: t.uri, urlId: t.urlId }))._attrs, delete a._urlId, this.hls.trigger(m.LEVEL_SWITCHING, a), (r = t.details) && !r.live) || (s = this.switchParams(t.uri, null == i ? void 0 : i.details), this.loadPlaylist(s)) } } get manualLevel() { return this.manualLevelIndex } set manualLevel(e) { this.manualLevelIndex = e, void 0 === this._startLevel && (this._startLevel = e), -1 !== e && (this.level = e) } get firstLevel() { return this._firstLevel } set firstLevel(e) { this._firstLevel = e } get startLevel() { var e; return void 0 === this._startLevel ? void 0 !== (e = this.hls.config.startLevel) ? e : this._firstLevel : this._startLevel } set startLevel(e) { this._startLevel = e } onError(e, t) { !t.fatal && t.context && t.context.type === G.LEVEL && t.context.level === this.level && this.checkRetry(t) } onFragLoaded(e, { frag: t }) { void 0 !== t && t.type === U.MAIN && void 0 !== (t = this._levels[t.level]) && (t.loadError = 0) } onLevelLoaded(e, t) { var { level: r, details: i } = t, s = this._levels[r]; s ? r === this.currentLevelIndex ? (0 === s.fragmentError && (s.loadError = 0), this.playlistLoaded(r, t, s.details)) : null != (s = t.deliveryDirectives) && s.skip && (i.deltaUpdateFailed = !0) : (this.warn("Invalid level index " + r), null != (s = t.deliveryDirectives) && s.skip && (i.deltaUpdateFailed = !0)) } onAudioTrackSwitched(e, t) { var r = this.currentLevel; if (r) { var i = this.hls.audioTracks[t.id].groupId; if (r.audioGroupIds && r.audioGroupId !== i) { let t = -1; for (let e = 0; e < r.audioGroupIds.length; e++)if (r.audioGroupIds[e] === i) { t = e; break } -1 !== t && t !== r.urlId && (r.urlId = t, this.canLoad) && this.startLoad() } } } loadPlaylist(t) { super.loadPlaylist(); var r = this.currentLevelIndex, i = this.currentLevel; if (i && this.shouldLoadPlaylist(i)) { var s = i.urlId; let e = i.uri; if (t) try { e = t.addDirectives(e) } catch (e) { this.warn("Could not construct new URL with HLS Delivery Directives: " + e) } var a = i.attrs["PATHWAY-ID"]; this.log(`Loading level index ${r}${void 0 !== (null == t ? void 0 : t.msn) ? " at sn " + t.msn + " part " + t.part : ""} with${a ? " Pathway " + a : ""} URI ${s + 1}/${i.url.length} ` + e), this.clearTimer(), this.hls.trigger(m.LEVEL_LOADING, { url: e, level: r, id: s, deliveryDirectives: t || null }) } } get nextLoadLevel() { return -1 !== this.manualLevelIndex ? this.manualLevelIndex : this.hls.nextAutoLevel } set nextLoadLevel(e) { this.level = e, -1 === this.manualLevelIndex && (this.hls.nextAutoLevel = e) } removeLevel(r, i) { let s = (e, t) => t !== i, e = this._levels.filter((e, t) => t !== r || (1 < e.url.length && void 0 !== i ? (e.url = e.url.filter(s), e.audioGroupIds && (e.audioGroupIds = e.audioGroupIds.filter(s)), e.textGroupIds && (e.textGroupIds = e.textGroupIds.filter(s)), !(e.urlId = 0)) : (this.steering && this.steering.removeLevel(e), !1))); this.hls.trigger(m.LEVELS_UPDATED, { levels: e }) } onLevelsUpdated(e, { levels: t }) { t.forEach((e, t) => { e = e.details; null != e && e.fragments && e.fragments.forEach(e => { e.level = t }) }), this._levels = t } } function ce(e, t, r) { r && ("audio" === t ? (e.audioGroupIds || (e.audioGroupIds = []), e.audioGroupIds[e.url.length - 1] = r) : "text" === t && (e.textGroupIds || (e.textGroupIds = []), e.textGroupIds[e.url.length - 1] = r)) } function Fs(e) { let r = {}; e.forEach(e => { var t = e.groupId || ""; e.id = r[t] = r[t] || 0, r[t]++ }) } var st = { NOT_LOADED: "NOT_LOADED", APPENDING: "APPENDING", PARTIAL: "PARTIAL", OK: "OK" }; class An { constructor(e) { this.activePartLists = Object.create(null), this.endListFragments = Object.create(null), this.fragments = Object.create(null), this.timeRanges = Object.create(null), this.bufferPadding = .2, this.hls = void 0, this.hasGaps = !1, this.hls = e, this._registerListeners() } _registerListeners() { var e = this.hls; e.on(m.BUFFER_APPENDED, this.onBufferAppended, this), e.on(m.FRAG_BUFFERED, this.onFragBuffered, this), e.on(m.FRAG_LOADED, this.onFragLoaded, this) } _unregisterListeners() { var e = this.hls; e.off(m.BUFFER_APPENDED, this.onBufferAppended, this), e.off(m.FRAG_BUFFERED, this.onFragBuffered, this), e.off(m.FRAG_LOADED, this.onFragLoaded, this) } destroy() { this._unregisterListeners(), this.fragments = this.activePartLists = this.endListFragments = this.timeRanges = null } getAppendedFrag(t, e) { var r = this.activePartLists[e]; if (r) for (let e = r.length; e--;) { var i = r[e]; if (!i) break; var s = i.end; if (i.start <= t && null !== s && t <= s) return i } return this.getBufferedFrag(t, e) } getBufferedFrag(t, r) { var i = this.fragments, s = Object.keys(i); for (let e = s.length; e--;) { var a = i[s[e]]; if ((null == a ? void 0 : a.body.type) === r && a.buffered) { a = a.body; if (a.start <= t && t <= a.end) return a } } return null } detectEvictedFragments(r, i, s, e) { this.timeRanges && (this.timeRanges[r] = i); let a = (null == e ? void 0 : e.fragment.sn) || -1; Object.keys(this.fragments).forEach(e => { let t = this.fragments[e]; !t || a >= t.body.sn || (t.buffered || t.loaded ? (e = t.range[r]) && e.time.some(e => { e = !this.isTimeBuffered(e.startPTS, e.endPTS, i); return e && this.removeFragment(t.body), e }) : t.body.type === s && this.removeFragment(t.body)) }) } detectPartialFragments(e) { let a = this.timeRanges, { frag: n, part: o } = e; if (a && "initSegment" !== n.sn) { let e = Ft(n), s = this.fragments[e]; if (s) { let i = !n.relurl; Object.keys(a).forEach(e => { var t, r = n.elementaryStreams[e]; r && (t = a[e], r = i || !0 === r.partial, s.range[e] = this.getBufferedTimes(n, o, r, t)) }), s.loaded = null, Object.keys(s.range).length ? (s.buffered = !0, s.body.endList && (this.endListFragments[s.body.type] = s), zt(s) || this.removeParts(n.sn - 1, n.type)) : this.removeFragment(s.body) } } } removeParts(t, e) { var r = this.activePartLists[e]; r && (this.activePartLists[e] = r.filter(e => e.fragment.sn >= t)) } fragBuffered(e, t) { var r = Ft(e); let i = this.fragments[r]; !i && t && (i = this.fragments[r] = { body: e, appendedPTS: null, loaded: null, buffered: !1, range: Object.create(null) }, e.gap) && (this.hasGaps = !0), i && (i.loaded = null, i.buffered = !0) } getBufferedTimes(e, t, r, i) { var s = { time: [], partial: r }, a = e.start, n = e.end, o = e.minEndPTS || n, l = e.maxStartPTS || a; for (let e = 0; e < i.length; e++) { var h = i.start(e) - this.bufferPadding, d = i.end(e) + this.bufferPadding; if (h <= l && o <= d) { s.time.push({ startPTS: Math.max(a, i.start(e)), endPTS: Math.min(n, i.end(e)) }); break } if (a < d && h < n) s.partial = !0, s.time.push({ startPTS: Math.max(a, i.start(e)), endPTS: Math.min(n, i.end(e)) }); else if (n <= h) break } return s } getPartialFragment(t) { let r = null, i, s, a, n = 0, { bufferPadding: o, fragments: l } = this; return Object.keys(l).forEach(e => { e = l[e]; e && zt(e) && (s = e.body.start - o, a = e.body.end + o, t >= s) && t <= a && (i = Math.min(t - s, a - t), n <= i) && (r = e.body, n = i) }), r } isEndListAppended(e) { e = this.endListFragments[e]; return void 0 !== e && (e.buffered || zt(e)) } getState(e) { e = Ft(e), e = this.fragments[e]; return e ? e.buffered ? zt(e) ? st.PARTIAL : st.OK : st.APPENDING : st.NOT_LOADED } isTimeBuffered(t, r, i) { var s, a; for (let e = 0; e < i.length; e++) { if (s = i.start(e) - this.bufferPadding, a = i.end(e) + this.bufferPadding, s <= t && r <= a) return !0; if (r <= s) return !1 } return !1 } onFragLoaded(e, t) { var { frag: r, part: i } = t; "initSegment" === r.sn || r.bitrateTest || (i = i ? null : t, t = Ft(r), this.fragments[t] = { body: r, appendedPTS: null, loaded: i, buffered: !1, range: Object.create(null) }) } onBufferAppended(e, t) { let { frag: i, part: s, timeRanges: a } = t; if ("initSegment" !== i.sn) { let r = i.type; if (s) { let e = this.activePartLists[r]; e || (this.activePartLists[r] = e = []), e.push(s) } this.timeRanges = a, Object.keys(a).forEach(e => { var t = a[e]; this.detectEvictedFragments(e, t, r, s) }) } } onFragBuffered(e, t) { this.detectPartialFragments(t) } hasFragment(e) { e = Ft(e); return !!this.fragments[e] } hasParts(e) { return !(null == (e = this.activePartLists[e]) || !e.length) } removeFragmentsInRange(r, i, s, a, n) { a && !this.hasGaps || Object.keys(this.fragments).forEach(e => { var t, e = this.fragments[e]; !e || (t = e.body).type !== s || a && !t.gap || t.start < i && t.end > r && (e.buffered || n) && this.removeFragment(t) }) } removeFragment(e) { var t = Ft(e), r = (e.stats.loaded = 0, e.clearElementaryStreamInfo(), this.activePartLists[e.type]); if (r) { let t = e.sn; this.activePartLists[e.type] = r.filter(e => e.fragment.sn !== t) } delete this.fragments[t], e.endList && delete this.endListFragments[e.type] } removeAllFragments() { this.fragments = Object.create(null), this.endListFragments = Object.create(null), this.activePartLists = Object.create(null), this.hasGaps = !1 } } function zt(e) { var t; return e.buffered && (e.body.gap || (null == (t = e.range.video) ? void 0 : t.partial) || (null == (t = e.range.audio) ? void 0 : t.partial) || (null == (t = e.range.audiovideo) ? void 0 : t.partial)) } function Ft(e) { return e.type + `_${e.level}_${e.urlId}_` + e.sn } let Os = Math.pow(2, 17); class Ln { constructor(e) { this.config = void 0, this.loader = null, this.partLoadTimeout = -1, this.config = e } destroy() { this.loader && (this.loader.destroy(), this.loader = null) } abort() { this.loader && this.loader.abort() } load(o, l) { let h = o.url; if (!h) return Promise.reject(new At({ type: N.NETWORK_ERROR, details: L.FRAG_LOAD_ERROR, fatal: !1, frag: o, error: new Error("Fragment does not have a " + (h ? "part list" : "url")), networkDetails: null })); this.abort(); let r = this.config, d = r.fLoader, u = r.loader; return new Promise((n, s) => { if (this.loader && this.loader.destroy(), o.gap) s(Ns(o)); else { let a = this.loader = o.loader = new (d || u)(r), e = Ms(o), t = Ps(r.fragLoadPolicy.default), i = { loadPolicy: t, timeout: t.maxLoadTimeMs, maxRetry: 0, retryDelay: 0, maxRetryDelay: 0, highWaterMark: "initSegment" === o.sn ? 1 / 0 : Os }; o.stats = a.stats, a.load(e, i, { onSuccess: (e, t, r, i) => { this.resetLoader(o, a); let s = e.data; r.resetIV && o.decryptdata && (o.decryptdata.iv = new Uint8Array(s.slice(0, 16)), s = s.slice(16)), n({ frag: o, part: null, payload: s, networkDetails: i }) }, onError: (e, t, r, i) => { this.resetLoader(o, a), s(new At({ type: N.NETWORK_ERROR, details: L.FRAG_LOAD_ERROR, fatal: !1, frag: o, response: ct({ url: h, data: void 0 }, e), error: new Error(`HTTP Error ${e.code} ` + e.text), networkDetails: r, stats: i })) }, onAbort: (e, t, r) => { this.resetLoader(o, a), s(new At({ type: N.NETWORK_ERROR, details: L.INTERNAL_ABORTED, fatal: !1, frag: o, error: new Error("Aborted"), networkDetails: r, stats: e })) }, onTimeout: (e, t, r) => { this.resetLoader(o, a), s(new At({ type: N.NETWORK_ERROR, details: L.FRAG_LOAD_TIMEOUT, fatal: !1, frag: o, error: new Error(`Timeout after ${i.timeout}ms`), networkDetails: r, stats: e })) }, onProgress: (e, t, r, i) => { l && l({ frag: o, part: null, payload: r, networkDetails: i }) } }) } }) } loadPart(l, h, d) { this.abort(); let t = this.config, r = t.fLoader, u = t.loader; return new Promise((n, o) => { if (this.loader && this.loader.destroy(), l.gap || h.gap) o(Ns(l, h)); else { let s = this.loader = l.loader = new (r || u)(t), a = Ms(l, h), e = Ps(t.fragLoadPolicy.default), i = { loadPolicy: e, timeout: e.maxLoadTimeMs, maxRetry: 0, retryDelay: 0, maxRetryDelay: 0, highWaterMark: Os }; h.stats = s.stats, s.load(a, i, { onSuccess: (e, t, r, i) => { this.resetLoader(l, s), this.updateStatsFromPart(l, h); e = { frag: l, part: h, payload: e.data, networkDetails: i }; d(e), n(e) }, onError: (e, t, r, i) => { this.resetLoader(l, s), o(new At({ type: N.NETWORK_ERROR, details: L.FRAG_LOAD_ERROR, fatal: !1, frag: l, part: h, response: ct({ url: a.url, data: void 0 }, e), error: new Error(`HTTP Error ${e.code} ` + e.text), networkDetails: r, stats: i })) }, onAbort: (e, t, r) => { l.stats.aborted = h.stats.aborted, this.resetLoader(l, s), o(new At({ type: N.NETWORK_ERROR, details: L.INTERNAL_ABORTED, fatal: !1, frag: l, part: h, error: new Error("Aborted"), networkDetails: r, stats: e })) }, onTimeout: (e, t, r) => { this.resetLoader(l, s), o(new At({ type: N.NETWORK_ERROR, details: L.FRAG_LOAD_TIMEOUT, fatal: !1, frag: l, part: h, error: new Error(`Timeout after ${i.timeout}ms`), networkDetails: r, stats: e })) } }) } }) } updateStatsFromPart(e, t) { var r = e.stats, i = t.stats, s = i.total, e = (r.loaded += i.loaded, s ? (s = ((e = Math.round(e.duration / t.duration)) - (t = Math.min(Math.round(r.loaded / s), e))) * Math.round(r.loaded / t), r.total = r.loaded + s) : r.total = Math.max(r.loaded, r.total), r.loading), t = i.loading; e.start ? e.first += t.first - t.start : (e.start = t.start, e.first = t.first), e.end = t.end } resetLoader(e, t) { e.loader = null, this.loader === t && (self.clearTimeout(this.partLoadTimeout), this.loader = null), t.destroy() } } function Ms(i, s = null) { var a = s || i, s = { frag: i, part: s, responseType: "arraybuffer", url: a.url, headers: {}, rangeStart: 0, rangeEnd: 0 }, n = a.byteRangeStartOffset, a = a.byteRangeEndOffset; if (F(n) && F(a)) { let e, t = n, r = a; "initSegment" === i.sn && "AES-128" === (null == (e = i.decryptdata) ? void 0 : e.method) && ((i = a - n) % 16 && (r = a + (16 - i % 16)), 0 !== n) && (s.resetIV = !0, t = n - 16), s.rangeStart = t, s.rangeEnd = r } return s } function Ns(e, t) { var r = new Error(`GAP ${e.gap ? "tag" : "attribute"} found`), r = { type: N.MEDIA_ERROR, details: L.FRAG_GAP, fatal: !1, frag: e, error: r, networkDetails: null }; return t && (r.part = t), (t || e).stats.aborted = !0, new At(r) } class At extends Error { constructor(e) { super(e.error.message), this.data = void 0, this.data = e } } class Rn { constructor(e) { this.config = void 0, this.keyUriToKeyInfo = {}, this.emeController = null, this.config = e } abort(e) { for (var t in this.keyUriToKeyInfo) { t = this.keyUriToKeyInfo[t].loader; if (t) { if (e && e !== t.context.frag.type) return; t.abort() } } } detach() { for (var e in this.keyUriToKeyInfo) { var t = this.keyUriToKeyInfo[e]; (t.mediaKeySessionContext || t.decryptdata.isCommonEncryption) && delete this.keyUriToKeyInfo[e] } } destroy() { for (var e in this.detach(), this.keyUriToKeyInfo) { e = this.keyUriToKeyInfo[e].loader; e && e.destroy() } this.keyUriToKeyInfo = {} } createKeyLoadError(e, t = L.KEY_LOAD_ERROR, r, i, s) { return new At({ type: N.NETWORK_ERROR, details: t, fatal: !1, frag: e, response: s, error: r, networkDetails: i }) } loadClear(e, r) { if (this.emeController && this.config.emeEnabled) { var { sn: i, cc: s } = e; for (let e = 0; e < r.length; e++) { let t = r[e]; if (s <= t.cc && ("initSegment" === i || "initSegment" === t.sn || i < t.sn)) { this.emeController.selectKeySystemFormat(t).then(e => { t.setKeyFormat(e) }); break } } } } load(t) { return !t.decryptdata && t.encrypted && this.emeController ? this.emeController.selectKeySystemFormat(t).then(e => this.loadInternal(t, e)) : this.loadInternal(t) } loadInternal(t, e) { e && t.setKeyFormat(e); let r = t.decryptdata; if (!r) return e = new Error(e ? "Expected frag.decryptdata to be defined after setting format " + e : "Missing decryption data on fragment in onKeyLoading"), Promise.reject(this.createKeyLoadError(t, L.KEY_LOAD_ERROR, e)); var i, e = r.uri; if (!e) return Promise.reject(this.createKeyLoadError(t, L.KEY_LOAD_ERROR, new Error(`Invalid key URI: "${e}"`))); let s = this.keyUriToKeyInfo[e]; if (null != (i = s) && i.decryptdata.key) return r.key = s.decryptdata.key, Promise.resolve({ frag: t, keyInfo: s }); if (null != (i = s) && i.keyLoadPromise) switch (null == (i = s.mediaKeySessionContext) ? void 0 : i.keyStatus) { case void 0: case "status-pending": case "usable": case "usable-in-future": return s.keyLoadPromise.then(e => (r.key = e.keyInfo.decryptdata.key, { frag: t, keyInfo: s })) }switch (s = this.keyUriToKeyInfo[e] = { decryptdata: r, keyLoadPromise: null, loader: null, mediaKeySessionContext: null }, r.method) { case "ISO-23001-7": case "SAMPLE-AES": case "SAMPLE-AES-CENC": case "SAMPLE-AES-CTR": return "identity" === r.keyFormat ? this.loadKeyHTTP(s, t) : this.loadKeyEME(s, t); case "AES-128": return this.loadKeyHTTP(s, t); default: return Promise.reject(this.createKeyLoadError(t, L.KEY_LOAD_ERROR, new Error(`Key supplied with unsupported METHOD: "${r.method}"`))) } } loadKeyEME(t, e) { let r = { frag: e, keyInfo: t }; if (this.emeController && this.config.emeEnabled) { e = this.emeController.loadKey(r); if (e) return (t.keyLoadPromise = e.then(e => (t.mediaKeySessionContext = e, r))).catch(e => { throw t.keyLoadPromise = null, e }) } return Promise.resolve(r) } loadKeyHTTP(i, a) { let l = this.config, e = l.loader, h = new e(l); return a.keyLoader = i.loader = h, i.keyLoadPromise = new Promise((n, o) => { let s = { keyInfo: i, frag: a, responseType: "arraybuffer", url: i.decryptdata.uri }, e = l.keyLoadPolicy.default, t = { loadPolicy: e, timeout: e.maxLoadTimeMs, maxRetry: 0, retryDelay: 0, maxRetryDelay: 0 }, r = { onSuccess: (e, t, r, i) => { var { frag: r, keyInfo: s, url: a } = r; if (!r.decryptdata || s !== this.keyUriToKeyInfo[a]) return o(this.createKeyLoadError(r, L.KEY_LOAD_ERROR, new Error("after key load, decryptdata unset or changed"), i)); s.decryptdata.key = r.decryptdata.key = new Uint8Array(e.data), r.keyLoader = null, s.loader = null, n({ frag: r, keyInfo: s }) }, onError: (e, t, r, i) => { this.resetLoader(t), o(this.createKeyLoadError(a, L.KEY_LOAD_ERROR, new Error(`HTTP Error ${e.code} loading key ` + e.text), r, ct({ url: s.url, data: void 0 }, e))) }, onTimeout: (e, t, r) => { this.resetLoader(t), o(this.createKeyLoadError(a, L.KEY_LOAD_TIMEOUT, new Error("key loading timed out"), r)) }, onAbort: (e, t, r) => { this.resetLoader(t), o(this.createKeyLoadError(a, L.INTERNAL_ABORTED, new Error("key loading aborted"), r)) } }; h.load(s, t, r) }) } resetLoader(e) { var { frag: e, keyInfo: t, url: r } = e, i = t.loader; e.keyLoader === i && (e.keyLoader = null, t.loader = null), delete this.keyUriToKeyInfo[r], i && i.destroy() } } class In { constructor() { this._boundTick = void 0, this._tickTimer = null, this._tickInterval = null, this._tickCallCount = 0, this._boundTick = this.tick.bind(this) } destroy() { this.onHandlerDestroying(), this.onHandlerDestroyed() } onHandlerDestroying() { this.clearNextTick(), this.clearInterval() } onHandlerDestroyed() { } hasInterval() { return !!this._tickInterval } hasNextTick() { return !!this._tickTimer } setInterval(e) { return !this._tickInterval && (this._tickCallCount = 0, this._tickInterval = self.setInterval(this._boundTick, e), !0) } clearInterval() { return !!this._tickInterval && (self.clearInterval(this._tickInterval), !(this._tickInterval = null)) } clearNextTick() { return !!this._tickTimer && (self.clearTimeout(this._tickTimer), !(this._tickTimer = null)) } tick() { this._tickCallCount++, 1 === this._tickCallCount && (this.doTick(), 1 < this._tickCallCount && this.tickImmediate(), this._tickCallCount = 0) } tickImmediate() { this.clearNextTick(), this._tickTimer = self.setTimeout(this._boundTick, 0) } doTick() { } } let bn = { length: 0, start: () => 0, end: () => 0 }; class q { static isBuffered(e, t) { try { if (e) { var r = q.getBuffered(e); for (let e = 0; e < r.length; e++)if (t >= r.start(e) && t <= r.end(e)) return !0 } } catch { } return !1 } static bufferInfo(t, r, i) { try { if (t) { var s = q.getBuffered(t), a = []; let e; for (e = 0; e < s.length; e++)a.push({ start: s.start(e), end: s.end(e) }); return this.bufferedInfo(a, r, i) } } catch { } return { len: 0, start: r, end: r, nextStart: void 0 } } static bufferedInfo(t, r, i) { r = Math.max(0, r), t.sort(function (e, t) { return e.start - t.start || t.end - e.end }); let s = []; if (i) for (let e = 0; e < t.length; e++) { var a, n = s.length; n && (a = s[n - 1].end, t[e].start - a < i) ? t[e].end > a && (s[n - 1].end = t[e].end) : s.push(t[e]) } else s = t; let o = 0, l, h = r, d = r; for (let e = 0; e < s.length; e++) { var u = s[e].start, c = s[e].end; if (u <= r + i && r < c) h = u, d = c, o = d - r; else if (r + i < u) { l = u; break } } return { len: o, start: h || 0, end: d || 0, nextStart: l } } static getBuffered(e) { try { return e.buffered } catch (e) { return E.log("failed to get media.buffered", e), bn } } } class es { constructor(e, t, r, i = 0, s = -1, a = !1) { this.level = void 0, this.sn = void 0, this.part = void 0, this.id = void 0, this.size = void 0, this.partial = void 0, this.transmuxing = Qt(), this.buffering = { audio: Qt(), video: Qt(), audiovideo: Qt() }, this.level = e, this.sn = t, this.id = r, this.size = i, this.part = s, this.partial = a } } function Qt() { return { start: 0, executeStart: 0, executeEnd: 0, end: 0 } } function Ci(r, i) { let s = null; for (let e = 0, t = r.length; e < t; e++) { var a = r[e]; if (a && a.cc === i) { s = a; break } } return s } function Dn(e, t, r) { return !(!t.details || !(r.endCC > r.startCC || e && e.cc < r.startCC)) } function Cn(e, t, r = 0) { e = e.fragments, t = t.fragments; if (t.length && e.length) { e = Ci(e, t[0].cc); if (e && e.startPTS) return e; E.log("No frag in previous level to align on") } else E.log("No fragments to align") } function Us(e, t) { e && (t = e.start + t, e.start = e.startPTS = t, e.endPTS = t + e.duration) } function ss(r, e) { var i = e.fragments; for (let e = 0, t = i.length; e < t; e++)Us(i[e], r); e.fragmentHint && Us(e.fragmentHint, r), e.alignedSliding = !0 } function kn(e, t, r) { t && (_n(e, r, t), !r.alignedSliding && t.details && wn(r, t.details), !r.alignedSliding) && t.details && !r.skippedSegments && Ii(t.details, r) } function _n(e, t, r) { Dn(e, r, t) && (e = Cn(r.details, t)) && F(e.start) && (E.log("Adjusting PTS using last level due to CC increase within current level " + t.url), ss(e.start, t)) } function wn(e, t) { var r, i; t.fragments.length && e.hasProgramDateTime && t.hasProgramDateTime && (r = t.fragments[0].programDateTime, t = ((i = e.fragments[0].programDateTime) - r) / 1e3 + t.fragments[0].start) && F(t) && (E.log(`Adjusting PTS using programDateTime delta ${i - r}ms, sliding:${t.toFixed(3)} ${e.url} `), ss(t, e)) } function ki(e, t) { var r, i, s; e.hasProgramDateTime && t.hasProgramDateTime && (t = t.fragments, (r = e.fragments).length) && t.length && (r = Ci(r, (t = t[Math.round(t.length / 2) - 1]).cc) || r[Math.round(r.length / 2) - 1], i = t.programDateTime, s = r.programDateTime, null !== i) && null !== s && ss((s - i) / 1e3 - (r.start - t.start), e) } class Pn { constructor(e, t) { this.subtle = void 0, this.aesIV = void 0, this.subtle = e, this.aesIV = t } decrypt(e, t) { return this.subtle.decrypt({ name: "AES-CBC", iv: this.aesIV }, t, e) } } class Fn { constructor(e, t) { this.subtle = void 0, this.key = void 0, this.subtle = e, this.key = t } expandKey() { return this.subtle.importKey("raw", this.key, { name: "AES-CBC" }, !1, ["encrypt", "decrypt"]) } } function On(e) { var t = e.byteLength, r = t && new DataView(e.buffer).getUint8(t - 1); return r ? wt(e, 0, t - r) : e } class Mn { constructor() { this.rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.sBox = new Uint32Array(256), this.invSBox = new Uint32Array(256), this.key = new Uint32Array(0), this.ksRows = 0, this.keySize = 0, this.keySchedule = void 0, this.invKeySchedule = void 0, this.initTable() } uint8ArrayToUint32Array_(e) { var t = new DataView(e), r = new Uint32Array(4); for (let e = 0; e < 4; e++)r[e] = t.getUint32(4 * e); return r } initTable() { var e = this.sBox, t = this.invSBox, r = this.subMix, i = r[0], s = r[1], a = r[2], n = r[3], r = this.invSubMix, o = r[0], l = r[1], h = r[2], d = r[3], u = new Uint32Array(256); let c = 0, f = 0, g = 0; for (g = 0; g < 256; g++)g < 128 ? u[g] = g << 1 : u[g] = g << 1 ^ 283; for (g = 0; g < 256; g++) { var m = (m = f ^ f << 1 ^ f << 2 ^ f << 3 ^ f << 4) >>> 8 ^ 255 & m ^ 99, p = u[t[e[c] = m] = c], v = u[p], E = u[v], T = 257 * u[m] ^ 16843008 * m; i[c] = T << 24 | T >>> 8, s[c] = T << 16 | T >>> 16, a[c] = T << 8 | T >>> 24, n[c] = T, T = 16843009 * E ^ 65537 * v ^ 257 * p ^ 16843008 * c, o[m] = T << 24 | T >>> 8, l[m] = T << 16 | T >>> 16, h[m] = T << 8 | T >>> 24, d[m] = T, c ? (c = p ^ u[u[u[E ^ p]]], f ^= u[u[f]]) : c = f = 1 } } expandKey(s) { var a = this.uint8ArrayToUint32Array_(s); let e = !0, t = 0; for (; t < a.length && e;)e = a[t] === this.key[t], t++; if (!e) { this.key = a; var n = this.keySize = a.length; if (4 !== n && 6 !== n && 8 !== n) throw new Error("Invalid aes key size=" + n); var o = this.ksRows = 4 * (n + 6 + 1); let e, t; var l = this.keySchedule = new Uint32Array(o), h = this.invKeySchedule = new Uint32Array(o), d = this.sBox, u = this.rcon, s = this.invSubMix, c = s[0], f = s[1], g = s[2], m = s[3]; let r, i; for (e = 0; e < o; e++)e < n ? r = l[e] = a[e] : (i = r, e % n == 0 ? (i = d[(i = i << 8 | i >>> 24) >>> 24] << 24 | d[i >>> 16 & 255] << 16 | d[i >>> 8 & 255] << 8 | d[255 & i], i ^= u[e / n | 0] << 24) : 6 < n && e % n == 4 && (i = d[i >>> 24] << 24 | d[i >>> 16 & 255] << 16 | d[i >>> 8 & 255] << 8 | d[255 & i]), l[e] = r = (l[e - n] ^ i) >>> 0); for (t = 0; t < o; t++)e = o - t, i = 3 & t ? l[e] : l[e - 4], t < 4 || e <= 4 ? h[t] = i : h[t] = c[d[i >>> 24]] ^ f[d[i >>> 16 & 255]] ^ g[d[i >>> 8 & 255]] ^ m[d[255 & i]], h[t] = h[t] >>> 0 } } networkToHostOrderSwap(e) { return e << 24 | (65280 & e) << 8 | (16711680 & e) >> 8 | e >>> 24 } decrypt(e, t, r) { var i = this.keySize + 6, s = this.invKeySchedule, a = this.invSBox, n = this.invSubMix, o = n[0], l = n[1], h = n[2], d = n[3], n = this.uint8ArrayToUint32Array_(r); let u = n[0], c = n[1], f = n[2], g = n[3]; var m = new Int32Array(e), p = new Int32Array(m.length); let v, E, T, y, L, S, A, R, I, D, b, k, _, w; for (var C = this.networkToHostOrderSwap; t < m.length;) { for (I = C(m[t]), D = C(m[t + 1]), b = C(m[t + 2]), k = C(m[t + 3]), L = I ^ s[0], S = k ^ s[1], A = b ^ s[2], R = D ^ s[3], _ = 4, w = 1; w < i; w++)v = o[L >>> 24] ^ l[S >> 16 & 255] ^ h[A >> 8 & 255] ^ d[255 & R] ^ s[_], E = o[S >>> 24] ^ l[A >> 16 & 255] ^ h[R >> 8 & 255] ^ d[255 & L] ^ s[_ + 1], T = o[A >>> 24] ^ l[R >> 16 & 255] ^ h[L >> 8 & 255] ^ d[255 & S] ^ s[_ + 2], y = o[R >>> 24] ^ l[L >> 16 & 255] ^ h[S >> 8 & 255] ^ d[255 & A] ^ s[_ + 3], L = v, S = E, A = T, R = y, _ += 4; v = a[L >>> 24] << 24 ^ a[S >> 16 & 255] << 16 ^ a[A >> 8 & 255] << 8 ^ a[255 & R] ^ s[_], E = a[S >>> 24] << 24 ^ a[A >> 16 & 255] << 16 ^ a[R >> 8 & 255] << 8 ^ a[255 & L] ^ s[_ + 1], T = a[A >>> 24] << 24 ^ a[R >> 16 & 255] << 16 ^ a[L >> 8 & 255] << 8 ^ a[255 & S] ^ s[_ + 2], y = a[R >>> 24] << 24 ^ a[L >> 16 & 255] << 16 ^ a[S >> 8 & 255] << 8 ^ a[255 & A] ^ s[_ + 3], p[t] = C(v ^ u), p[t + 1] = C(y ^ c), p[t + 2] = C(T ^ f), p[t + 3] = C(E ^ g), u = I, c = D, f = b, g = k, t += 4 } return p.buffer } } let Nn = 16; class is { constructor(e, { removePKCS7Padding: t = !0 } = {}) { if (this.logEnabled = !0, this.removePKCS7Padding = void 0, this.subtle = null, this.softwareDecrypter = null, this.key = null, this.fastAesKey = null, this.remainderData = null, this.currentIV = null, this.currentResult = null, this.useSoftware = void 0, this.useSoftware = e.enableSoftwareAES, this.removePKCS7Padding = t) try { var r = self.crypto; r && (this.subtle = r.subtle || r.webkitSubtle) } catch { } null === this.subtle && (this.useSoftware = !0) } destroy() { this.subtle = null, this.softwareDecrypter = null, this.key = null, this.fastAesKey = null, this.remainderData = null, this.currentIV = null, this.currentResult = null } isSync() { return this.useSoftware } flush() { var { currentResult: e, remainderData: t } = this; return !e || t ? (this.reset(), null) : (t = new Uint8Array(e), this.reset(), this.removePKCS7Padding ? On(t) : t) } reset() { this.currentResult = null, this.currentIV = null, this.remainderData = null, this.softwareDecrypter && (this.softwareDecrypter = null) } decrypt(i, s, a) { return this.useSoftware ? new Promise((e, t) => { this.softwareDecrypt(new Uint8Array(i), s, a); var r = this.flush(); r ? e(r.buffer) : t(new Error("[softwareDecrypt] Failed to decrypt data")) }) : this.webCryptoDecrypt(new Uint8Array(i), s, a) } softwareDecrypt(e, t, r) { var { currentIV: i, currentResult: s, remainderData: a } = this, a = (this.logOnce("JS AES decrypt"), a && (e = Pt(a, e), this.remainderData = null), this.getValidChunk(e)); if (!a.length) return null; i && (r = i); let n = this.softwareDecrypter; (n = n || (this.softwareDecrypter = new Mn)).expandKey(t); e = s; return this.currentResult = n.decrypt(a.buffer, 0, r), this.currentIV = wt(a, -16).buffer, e || null } webCryptoDecrypt(t, r, i) { let s = this.subtle; return this.key === r && this.fastAesKey || (this.key = r, this.fastAesKey = new Fn(s, r)), this.fastAesKey.expandKey().then(e => s ? (this.logOnce("WebCrypto AES decrypt"), new Pn(s, new Uint8Array(i)).decrypt(t.buffer, e)) : Promise.reject(new Error("web crypto not initialized"))).catch(e => (E.warn(`[decrypter]: WebCrypto Error, disable WebCrypto API, ${e.name}: ` + e.message), this.onWebCryptoError(t, r, i))) } onWebCryptoError(e, t, r) { this.useSoftware = !0, this.logEnabled = !0, this.softwareDecrypt(e, t, r); e = this.flush(); if (e) return e.buffer; throw new Error("WebCrypto and softwareDecrypt: failed to decrypt data") } getValidChunk(e) { let t = e; var r = e.length - e.length % Nn; return r !== e.length && (t = wt(e, 0, r), this.remainderData = wt(e, r)), t } logOnce(e) { this.logEnabled && (E.log("[decrypter]: " + e), this.logEnabled = !1) } } let Un = { toString: function (t) { let r = ""; var i = t.length; for (let e = 0; e < i; e++)r += `[${t.start(e).toFixed(3)}-${t.end(e).toFixed(3)}]`; return r } }, b = { STOPPED: "STOPPED", IDLE: "IDLE", KEY_LOADING: "KEY_LOADING", FRAG_LOADING: "FRAG_LOADING", FRAG_LOADING_WAITING_RETRY: "FRAG_LOADING_WAITING_RETRY", WAITING_TRACK: "WAITING_TRACK", PARSING: "PARSING", PARSED: "PARSED", ENDED: "ENDED", ERROR: "ERROR", WAITING_INIT_PTS: "WAITING_INIT_PTS", WAITING_LEVEL: "WAITING_LEVEL" }; class rs extends In { constructor(e, t, r, i, s) { super(), this.hls = void 0, this.fragPrevious = null, this.fragCurrent = null, this.fragmentTracker = void 0, this.transmuxer = null, this._state = b.STOPPED, this.playlistType = void 0, this.media = null, this.mediaBuffer = null, this.config = void 0, this.bitrateTest = !1, this.lastCurrentTime = 0, this.nextLoadPosition = 0, this.startPosition = 0, this.startTimeOffset = null, this.loadedmetadata = !1, this.retryDate = 0, this.levels = null, this.fragmentLoader = void 0, this.keyLoader = void 0, this.levelLastLoaded = null, this.startFragRequested = !1, this.decrypter = void 0, this.initPTS = [], this.onvseeking = null, this.onvended = null, this.logPrefix = "", this.log = void 0, this.warn = void 0, this.playlistType = s, this.logPrefix = i, this.log = E.log.bind(E, i + ":"), this.warn = E.warn.bind(E, i + ":"), this.hls = e, this.fragmentLoader = new Ln(e.config), this.keyLoader = r, this.fragmentTracker = t, this.config = e.config, this.decrypter = new is(e.config), e.on(m.MANIFEST_LOADED, this.onManifestLoaded, this) } doTick() { this.onTickEnd() } onTickEnd() { } startLoad(e) { } stopLoad() { this.fragmentLoader.abort(), this.keyLoader.abort(this.playlistType); var e = this.fragCurrent; null != e && e.loader && (e.abortRequests(), this.fragmentTracker.removeFragment(e)), this.resetTransmuxer(), this.fragCurrent = null, this.fragPrevious = null, this.clearInterval(), this.clearNextTick(), this.state = b.STOPPED } _streamEnded(e, t) { return !(t.live || e.nextStart || !e.end || !this.media) && (null != (e = t.partList) && e.length ? (e = e[e.length - 1], q.isBuffered(this.media, e.start + e.duration / 2)) : (e = t.fragments[t.fragments.length - 1].type, this.fragmentTracker.isEndListAppended(e))) } getLevelDetails() { var e; return !this.levels || null === this.levelLastLoaded || null == (e = this.levels[this.levelLastLoaded]) ? void 0 : e.details } onMediaAttached(e, t) { t = this.media = this.mediaBuffer = t.media, this.onvseeking = this.onMediaSeeking.bind(this), this.onvended = this.onMediaEnded.bind(this), t.addEventListener("seeking", this.onvseeking), t.addEventListener("ended", this.onvended), t = this.config; this.levels && t.autoStartLoad && this.state === b.STOPPED && this.startLoad(t.startPosition) } onMediaDetaching() { var e = this.media; null != e && e.ended && (this.log("MSE detaching and video ended, reset startPosition"), this.startPosition = this.lastCurrentTime = 0), e && this.onvseeking && this.onvended && (e.removeEventListener("seeking", this.onvseeking), e.removeEventListener("ended", this.onvended), this.onvseeking = this.onvended = null), this.keyLoader && this.keyLoader.detach(), this.media = this.mediaBuffer = null, this.loadedmetadata = !1, this.fragmentTracker.removeAllFragments(), this.stopLoad() } onMediaSeeking() { var { config: e, fragCurrent: t, media: r, mediaBuffer: i, state: s } = this, a = r ? r.currentTime : 0, i = q.bufferInfo(i || r, a, e.maxBufferHole); this.log(`media seeking to ${F(a) ? a.toFixed(3) : a}, state: ` + s), this.state === b.ENDED ? this.resetLoadingState() : t && (s = e.maxFragLookUpTolerance, e = t.start - s, s = t.start + t.duration + s, !i.len || s < i.start || e > i.end) && (s = s < a, a < e || s) && (s && t.loader && (this.log("seeking outside of buffer while fragment load in progress, cancel fragment load"), t.abortRequests(), this.resetLoadingState()), this.fragPrevious = null), r && (this.fragmentTracker.removeFragmentsInRange(a, 1 / 0, this.playlistType, !0), this.lastCurrentTime = a), this.loadedmetadata || i.len || (this.nextLoadPosition = this.startPosition = a), this.tickImmediate() } onMediaEnded() { this.startPosition = this.lastCurrentTime = 0 } onManifestLoaded(e, t) { this.startTimeOffset = t.startTimeOffset, this.initPTS = [] } onHandlerDestroying() { this.stopLoad(), super.onHandlerDestroying() } onHandlerDestroyed() { this.state = b.STOPPED, this.fragmentLoader && this.fragmentLoader.destroy(), this.keyLoader && this.keyLoader.destroy(), this.decrypter && this.decrypter.destroy(), this.hls = this.log = this.warn = this.decrypter = this.keyLoader = this.fragmentLoader = this.fragmentTracker = null, super.onHandlerDestroyed() } loadFragment(e, t, r) { this._loadFragForPlayback(e, t, r) } _loadFragForPlayback(r, e, t) { this._doFragLoad(r, e, t, e => { this.fragContextChanged(r) ? (this.warn(`Fragment ${r.sn}${e.part ? " p: " + e.part.index : ""} of level ${r.level} was dropped during download.`), this.fragmentTracker.removeFragment(r)) : (r.stats.chunkCount++, this._handleFragmentLoadProgress(e)) }).then(e => { var t; e && (t = this.state, this.fragContextChanged(r) ? t !== b.FRAG_LOADING && (this.fragCurrent || t !== b.PARSING) || (this.fragmentTracker.removeFragment(r), this.state = b.IDLE) : ("payload" in e && (this.log(`Loaded fragment ${r.sn} of level ` + r.level), this.hls.trigger(m.FRAG_LOADED, e)), this._handleFragmentLoadComplete(e))) }).catch(e => { this.state !== b.STOPPED && this.state !== b.ERROR && (this.warn(e), this.resetFragmentLoading(r)) }) } clearTrackerIfNeeded(e) { var t, r = this.fragmentTracker; r.getState(e) === st.APPENDING ? (t = e.type, t = this.getFwdBufferInfo(this.mediaBuffer, t), t = Math.max(e.duration, t ? t.len : this.config.maxBufferLength), this.reduceMaxBufferLength(t) && r.removeFragment(e)) : 0 === (null == (t = this.mediaBuffer) ? void 0 : t.buffered.length) ? r.removeAllFragments() : r.hasParts(e.type) && (r.detectPartialFragments({ frag: e, part: null, stats: e.stats, id: e.type }), r.getState(e) === st.PARTIAL) && r.removeFragment(e) } flushMainBuffer(e, t, r = null) { e - t && (e = { startOffset: e, endOffset: t, type: r }, this.hls.trigger(m.BUFFER_FLUSHING, e)) } _loadInitSegment(a, s) { this._doFragLoad(a, s).then(e => { if (e && !this.fragContextChanged(a) && this.levels) return e; throw new Error("init load aborted") }).then(i => { let s = this.hls, e = i.payload, t = a.decryptdata; if (e && 0 < e.byteLength && t && t.key && t.iv && "AES-128" === t.method) { let r = self.performance.now(); return this.decrypter.decrypt(new Uint8Array(e), t.key.buffer, t.iv.buffer).catch(e => { throw s.trigger(m.ERROR, { type: N.MEDIA_ERROR, details: L.FRAG_DECRYPT_ERROR, fatal: !1, error: e, reason: e.message, frag: a }), e }).then(e => { var t = self.performance.now(); return s.trigger(m.FRAG_DECRYPTED, { frag: a, payload: e, stats: { tstart: r, tdecrypt: t } }), i.payload = e, i }) } return i }).then(e => { var { fragCurrent: t, hls: r, levels: i } = this; if (!i) throw new Error("init load aborted, missing levels"); i = a.stats; this.state = b.IDLE, s.fragmentError = 0, a.data = new Uint8Array(e.payload), i.parsing.start = i.buffering.start = self.performance.now(), i.parsing.end = i.buffering.end = self.performance.now(), e.frag === t && r.trigger(m.FRAG_BUFFERED, { stats: i, frag: t, part: null, id: a.type }), this.tick() }).catch(e => { this.state !== b.STOPPED && this.state !== b.ERROR && (this.warn(e), this.resetFragmentLoading(a)) }) } fragContextChanged(e) { var t = this.fragCurrent; return !e || !t || e.level !== t.level || e.sn !== t.sn || e.urlId !== t.urlId } fragBufferedComplete(e, t) { var r = this.mediaBuffer || this.media; this.log(`Buffered ${e.type} sn: ${e.sn}${t ? " part: " + t.index : ""} of ${this.playlistType === U.MAIN ? "level" : "track"} ${e.level} (frag:[${(null != (t = e.startPTS) ? t : NaN).toFixed(3)}-${(null != (t = e.endPTS) ? t : NaN).toFixed(3)}] > buffer:${r ? Un.toString(q.getBuffered(r)) : "(detached)"})`), this.state = b.IDLE, r && (!this.loadedmetadata && e.type == U.MAIN && r.buffered.length && (null == (t = this.fragCurrent) ? void 0 : t.sn) === (null == (e = this.fragPrevious) ? void 0 : e.sn) && (this.loadedmetadata = !0, this.seekToStartPos()), this.tick()) } seekToStartPos() { } _handleFragmentLoadComplete(e) { var t, r, i = this.transmuxer; i && ({ frag: e, part: t, partsLoaded: r } = e, r = !r || 0 === r.length || r.some(e => !e), e = new es(e.level, e.sn, e.stats.chunkCount + 1, 0, t ? t.index : -1, !r), i.flush(e)) } _handleFragmentLoadProgress(e) { } _doFragLoad(r, i, s = null, a) { var n = null == i ? void 0 : i.details; if (!this.levels || !n) throw new Error(`frag load aborted, missing level${n ? "" : " detail"}s`); let o = null; if (!r.encrypted || null != (l = r.decryptdata) && l.key ? !r.encrypted && n.encryptedFragments.length && this.keyLoader.loadClear(r, n.encryptedFragments) : (this.log(`Loading key for ${r.sn} of [${n.startSN}-${n.endSN}], ${"[stream-controller]" === this.logPrefix ? "level" : "track"} ` + r.level), this.state = b.KEY_LOADING, this.fragCurrent = r, o = this.keyLoader.load(r).then(e => { if (!this.fragContextChanged(e.frag)) return this.hls.trigger(m.KEY_LOADED, e), this.state === b.KEY_LOADING && (this.state = b.IDLE), e }), this.hls.trigger(m.KEY_LOADING, { frag: r }), null === this.fragCurrent && (o = Promise.reject(new Error("frag load aborted, context changed in KEY_LOADING")))), s = Math.max(r.start, s || 0), this.config.lowLatencyMode && "initSegment" !== r.sn) { var l = n.partList; if (l && a) { s > r.end && n.fragmentHint && (r = n.fragmentHint); var h = this.getNextPart(l, r, s); if (-1 < h) { let t = l[h]; this.log(`Loading part sn: ${r.sn} p: ${t.index} cc: ${r.cc} of playlist [${n.startSN}-${n.endSN}] parts [0-${h}-${l.length - 1}] ${"[stream-controller]" === this.logPrefix ? "level" : "track"}: ${r.level}, target: ` + parseFloat(s.toFixed(3))), this.nextLoadPosition = t.start + t.duration, this.state = b.FRAG_LOADING; let e; return e = o ? o.then(e => !e || this.fragContextChanged(e.frag) ? null : this.doFragPartsLoad(r, t, i, a)).catch(e => this.handleFragLoadError(e)) : this.doFragPartsLoad(r, t, i, a).catch(e => this.handleFragLoadError(e)), this.hls.trigger(m.FRAG_LOADING, { frag: r, part: t, targetBufferTime: s }), null === this.fragCurrent ? Promise.reject(new Error("frag load aborted, context changed in FRAG_LOADING parts")) : e } if (!r.url || this.loadedEndOfParts(l, s)) return Promise.resolve(null) } } this.log(`Loading fragment ${r.sn} cc: ${r.cc} ${n ? "of [" + n.startSN + "-" + n.endSN + "] " : ""}${"[stream-controller]" === this.logPrefix ? "level" : "track"}: ${r.level}, target: ` + parseFloat(s.toFixed(3))), F(r.sn) && !this.bitrateTest && (this.nextLoadPosition = r.start + r.duration), this.state = b.FRAG_LOADING; let t = this.config.progressive, e; return e = t && o ? o.then(e => !e || this.fragContextChanged(null == e ? void 0 : e.frag) ? null : this.fragmentLoader.load(r, a)).catch(e => this.handleFragLoadError(e)) : Promise.all([this.fragmentLoader.load(r, t ? a : void 0), o]).then(([e]) => (!t && e && a && a(e), e)).catch(e => this.handleFragLoadError(e)), this.hls.trigger(m.FRAG_LOADING, { frag: r, targetBufferTime: s }), null === this.fragCurrent ? Promise.reject(new Error("frag load aborted, context changed in FRAG_LOADING")) : e } doFragPartsLoad(o, r, l, h) { return new Promise((i, e) => { let t, s = [], a = null == (t = l.details) ? void 0 : t.partList, n = r => { this.fragmentLoader.loadPart(o, r, h).then(e => { var t = (s[r.index] = e).part, e = (this.hls.trigger(m.FRAG_LOADED, e), _s(l, o.sn, r.index + 1) || bi(a, o.sn, r.index + 1)); if (!e) return i({ frag: o, part: t, partsLoaded: s }); n(e) }).catch(e) }; n(r) }) } handleFragLoadError(e) { var t; return "data" in e ? (t = e.data, e.data && t.details === L.INTERNAL_ABORTED ? this.handleFragLoadAborted(t.frag, t.part) : this.hls.trigger(m.ERROR, t)) : this.hls.trigger(m.ERROR, { type: N.OTHER_ERROR, details: L.INTERNAL_EXCEPTION, err: e, error: e, fatal: !0 }), null } _handleTransmuxerFlush(e) { var t, r, i, s = this.getCurrentContext(e); s && this.state === b.PARSING ? ({ frag: s, part: t, level: r } = s, i = self.performance.now(), s.stats.parsing.end = i, t && (t.stats.parsing.end = i), this.updateLevelTiming(s, t, r, e.partial)) : this.fragCurrent || this.state === b.STOPPED || this.state === b.ERROR || (this.state = b.IDLE) } getCurrentContext(e) { var t, { levels: r, fragCurrent: i } = this, { level: e, sn: s, part: a } = e; return null != r && r[e] ? (r = r[e], (t = (a = -1 < a ? _s(r, s, a) : null) ? a.fragment : gn(r, s, i)) ? (i && i !== t && (t.stats = i.stats), { frag: t, part: a, level: r }) : null) : (this.warn(`Levels object was unset while buffering fragment ${s} of level ${e}. The current chunk will not be buffered.`), null) } bufferFragmentData(t, r, i, s) { if (t && this.state === b.PARSING) { var { data1: a, data2: n } = t; let e = a; null != (a = e = a && n ? Pt(a, n) : e) && a.length && (n = { type: t.type, frag: r, part: i, chunkMeta: s, parent: r.type, data: e }, this.hls.trigger(m.BUFFER_APPENDING, n), t.dropped) && t.independent && !i && this.flushBufferGap(r) } } flushBufferGap(e) { var t, r, i = this.media; i && (q.isBuffered(i, i.currentTime) ? (t = i.currentTime, i = q.bufferInfo(i, t, 0), r = e.duration, r = Math.min(2 * this.config.maxFragLookUpTolerance, .25 * r), i = Math.max(Math.min(e.start - r, i.end - r), t + r), e.start - i > r && this.flushMainBuffer(i, e.start)) : this.flushMainBuffer(0, e.start)) } getFwdBufferInfo(e, t) { var r = this.getLoadPosition(); return F(r) ? this.getFwdBufferInfoAtPos(e, r, t) : null } getFwdBufferInfoAtPos(e, t, r) { var i = this.config.maxBufferHole, s = q.bufferInfo(e, t, i); if (0 === s.len && void 0 !== s.nextStart) { r = this.fragmentTracker.getBufferedFrag(t, r); if (r && s.nextStart < r.end) return q.bufferInfo(e, t, Math.max(s.nextStart, i)) } return s } getMaxBufferLength(e) { var t = this.config; let r; return r = e ? Math.max(8 * t.maxBufferSize / e, t.maxBufferLength) : t.maxBufferLength, Math.min(r, t.maxMaxBufferLength) } reduceMaxBufferLength(e) { var t = this.config, e = e || t.maxBufferLength; return t.maxMaxBufferLength >= e && (t.maxMaxBufferLength /= 2, this.warn(`Reduce max buffer length to ${t.maxMaxBufferLength}s`), !0) } getAppendedFrag(e, t = U.MAIN) { e = this.fragmentTracker.getAppendedFrag(e, U.MAIN); return e && "fragment" in e ? e.fragment : e } getNextFragment(e, t) { var r = t.fragments, i = r.length; if (!i) return null; var s = this.config, a = r[0].start; let n; if (t.live) { var o = s.initialLiveManifestSize; if (i < o) return this.warn(`Not enough fragments to start playback (have: ${i}, need: ${o})`), null; t.PTSKnown || this.startFragRequested || -1 !== this.startPosition || (n = this.getInitialLiveFragment(t, r), this.startPosition = n ? this.hls.liveSyncPosition || n.start : e) } else e <= a && (n = r[0]); return n || (i = s.lowLatencyMode ? t.partEnd : t.fragmentEnd, n = this.getFragmentAtPosition(e, i, t)), this.mapToInitFragWhenRequired(n) } isLoopLoading(e, t) { var r = this.fragmentTracker.getState(e); return (r === st.OK || r === st.PARTIAL && !!e.gap) && this.nextLoadPosition > t } getNextFragmentLoopLoading(e, t, r, i, s) { var a = e.gap, t = this.getNextFragment(this.nextLoadPosition, t); if (null === t) return t; if (e = t, a && e && !e.gap && r.nextStart) { t = this.getFwdBufferInfoAtPos(this.mediaBuffer || this.media, r.nextStart, i); if (null !== t && r.len + t.len >= s) return this.log(`buffer full after gaps in "${i}" playlist starting at sn: ` + e.sn), null } return e } mapToInitFragWhenRequired(e) { return null == e || !e.initSegment || null != e && e.initSegment.data || this.bitrateTest ? e : e.initSegment } getNextPart(r, i, s) { let a = -1, n = !1, o = !0; for (let e = 0, t = r.length; e < t; e++) { var l = r[e]; if (o = o && !l.independent, -1 < a && s < l.start) break; var h = l.loaded; h ? a = -1 : (n || l.independent || o) && l.fragment === i && (a = e), n = h } return a } loadedEndOfParts(e, t) { e = e[e.length - 1]; return e && t > e.start && e.loaded } getInitialLiveFragment(e, t) { var r, i = this.fragPrevious; let s = null; return i ? (e.hasProgramDateTime && (this.log("Live playlist, switching playlist, load frag with same PDT: " + i.programDateTime), s = pn(t, i.endProgramDateTime, this.config.maxFragLookUpTolerance)), s || ((r = i.sn + 1) >= e.startSN && r <= e.endSN && (r = t[r - e.startSN], i.cc === r.cc) && (s = r, this.log("Live playlist, switching playlist, load frag with next SN: " + s.sn)), s) || (s = yn(t, i.cc)) && this.log("Live playlist, switching playlist, load frag with same CC: " + s.sn)) : null !== (r = this.hls.liveSyncPosition) && (s = this.getFragmentAtPosition(r, this.bitrateTest ? e.fragmentEnd : e.edge, e)), s } getFragmentAtPosition(e, t, r) { var i = this.config; let s = this.fragPrevious, { fragments: a, endSN: n } = r; var o = r.fragmentHint, l = i.maxFragLookUpTolerance, h = r.partList, i = !!(i.lowLatencyMode && null != h && h.length && o); i && o && !this.bitrateTest && (a = a.concat(o), n = o.sn); let d; return (d = e < t ? qt(s, a, e, t - l < e ? 0 : l) : a[a.length - 1]) && (o = d.sn - r.startSN, t = this.fragmentTracker.getState(d), s = t === st.OK || t === st.PARTIAL && d.gap ? d : s) && d.sn === s.sn && (!i || h[0].fragment.sn > d.sn) && s && d.level === s.level && (e = a[1 + o], d = d.sn < n && this.fragmentTracker.getState(e) !== st.OK ? e : null), d } synchronizeToLiveEdge(e) { var t, r, i, s, { config: a, media: n } = this; n && (t = this.hls.liveSyncPosition, r = n.currentTime, s = e.fragments[0].start, i = e.edge, s = r >= s - a.maxFragLookUpTolerance && r <= i, null !== t) && n.duration > t && (r < t || !s) && (a = void 0 !== a.liveMaxLatencyDuration ? a.liveMaxLatencyDuration : a.liveMaxLatencyDurationCount * e.targetduration, !s && n.readyState < 4 || r < i - a) && (this.loadedmetadata || (this.nextLoadPosition = t), n.readyState) && (this.warn(`Playback: ${r.toFixed(3)} is located too far from the end of live sliding playlist: ${i}, reset currentTime to : ` + t.toFixed(3)), n.currentTime = t) } alignPlaylists(e, t) { var r, i, s, { levels: a, levelLastLoaded: n, fragPrevious: o } = this, a = null !== n ? a[n] : null, n = e.fragments.length; return n ? (r = e.fragments[0].start, s = !t, i = e.alignedSliding && F(r), s || !i && !r ? (kn(o, a, e), s = e.fragments[0].start, this.log(`Live playlist sliding: ${s.toFixed(2)} start-sn: ${t ? t.startSN : "na"}->${e.startSN} prev-sn: ${o ? o.sn : "na"} fragments: ` + n), s) : r) : (this.warn("No fragments in live playlist"), 0) } waitForCdnTuneIn(e) { return e.live && e.canBlockReload && e.partTarget && e.tuneInGoal > Math.max(e.partHoldBack, 3 * e.partTarget) } setStartPosition(e, t) { let r = this.startPosition; var i, s; -1 !== (r = r < t ? -1 : r) && -1 !== this.lastCurrentTime || (null !== (s = ((i = null !== this.startTimeOffset) ? this : e).startTimeOffset) && F(s) ? (r = t + s, s < 0 && (r += e.totalduration), r = Math.min(Math.max(t, r), t + e.totalduration), this.log(`Start time offset ${s} found in ${i ? "multivariant" : "media"} playlist, adjust startPosition to ` + r), this.startPosition = r) : e.live ? r = this.hls.liveSyncPosition || t : this.startPosition = r = 0, this.lastCurrentTime = r), this.nextLoadPosition = r } getLoadPosition() { var e = this.media; let t = 0; return this.loadedmetadata && e ? t = e.currentTime : this.nextLoadPosition && (t = this.nextLoadPosition), t } handleFragLoadAborted(e, t) { this.transmuxer && "initSegment" !== e.sn && e.stats.aborted && (this.warn(`Fragment ${e.sn}${t ? " part " + t.index : ""} of level ${e.level} was aborted`), this.resetFragmentLoading(e)) } resetFragmentLoading(e) { this.fragCurrent && (this.fragContextChanged(e) || this.state === b.FRAG_LOADING_WAITING_RETRY) || (this.state = b.IDLE) } onFragmentOrKeyLoadError(e, t) { t.chunkMeta && !t.frag && (o = this.getCurrentContext(t.chunkMeta)) && (t.frag = o.frag); var r, i, s, a, n, o = t.frag; o && o.type === e && this.levels && (this.fragContextChanged(o) ? this.warn(`Frag load error must match current frag to retry ${o.url} > ` + (null == (r = this.fragCurrent) ? void 0 : r.url)) : ((r = t.details === L.FRAG_GAP) && this.fragmentTracker.fragBuffered(o, !0), { action: n, retryCount: s = 0, retryConfig: a } = (i = t.errorAction) || {}, i && n === ot.RetryRequest && a ? (this.loadedmetadata || (this.startFragRequested = !1, this.nextLoadPosition = this.startPosition), n = Ze(a, s), this.warn(`Fragment ${o.sn} of ${e} ${o.level} errored with ${t.details}, retrying loading ${s + 1}/${a.maxNumRetry} in ${n}ms`), i.resolved = !0, this.retryDate = self.performance.now() + n, this.state = b.FRAG_LOADING_WAITING_RETRY) : a && i ? (this.resetFragmentErrors(e), s < a.maxNumRetry ? r || (i.resolved = !0) : E.warn(t.details + ` reached or exceeded max retry (${s})`)) : this.state = b.ERROR, this.tickImmediate())) } reduceLengthAndFlushBuffer(e) { var t, r, i; return (this.state === b.PARSING || this.state === b.PARSED) && (t = e.parent, (r = (i = this.getFwdBufferInfo(this.mediaBuffer, t)) && .5 < i.len) && this.reduceMaxBufferLength(i.len), (i = !r) && this.warn(`Buffer full error while media.currentTime is not buffered, flush ${t} buffer`), e.frag && (this.fragmentTracker.removeFragment(e.frag), this.nextLoadPosition = e.frag.start), this.resetLoadingState(), i) } resetFragmentErrors(e) { e === U.AUDIO && (this.fragCurrent = null), this.loadedmetadata || (this.startFragRequested = !1), this.state !== b.STOPPED && (this.state = b.IDLE) } afterBufferFlushed(e, t, r) { e && (e = q.getBuffered(e), this.fragmentTracker.detectEvictedFragments(t, e, r), this.state === b.ENDED) && this.resetLoadingState() } resetLoadingState() { this.log("Reset loading state"), this.fragCurrent = null, this.fragPrevious = null, this.state = b.IDLE } resetStartWhenNotLoaded(e) { this.loadedmetadata || (this.startFragRequested = !1, null != (e = this.levels ? this.levels[e].details : null) && e.live ? (this.startPosition = -1, this.setStartPosition(e, 0), this.resetLoadingState()) : this.nextLoadPosition = this.startPosition) } resetWhenMissingContext(e) { this.warn(`The loading context changed while buffering fragment ${e.sn} of level ${e.level}. This chunk will not be buffered.`), this.removeUnbufferedFrags(), this.resetStartWhenNotLoaded(e.level), this.resetLoadingState() } removeUnbufferedFrags(e = 0) { this.fragmentTracker.removeFragmentsInRange(e, 1 / 0, this.playlistType, !1, !0) } updateLevelTiming(s, e, a, n) { let t, o = a.details; if (o) { if (Object.keys(s.elementaryStreams).reduce((e, t) => { var r, i = s.elementaryStreams[t]; return i ? (r = i.endPTS - i.startPTS) <= 0 ? (this.warn(`Could not parse fragment ${s.sn} ${t} duration reliably (${r})`), e || !1) : (r = n ? 0 : Ri(o, s, i.startPTS, i.endPTS, i.startDTS, i.endDTS), this.hls.trigger(m.LEVEL_PTS_UPDATED, { details: o, level: a, drift: r, type: t, frag: s, start: i.startPTS, end: i.endPTS }), !0) : e }, !1)) a.fragmentError = 0; else if (null === (null == (t = this.transmuxer) ? void 0 : t.error)) { var r = new Error(`Found no media in fragment ${s.sn} of level ${a.id} resetting transmuxer to fallback to playlist timing`); if (this.warn(r.message), this.hls.trigger(m.ERROR, { type: N.MEDIA_ERROR, details: L.FRAG_PARSING_ERROR, fatal: !1, error: r, frag: s, reason: `Found no media in msn ${s.sn} of level "${a.url}"` }), !this.hls) return; this.resetTransmuxer() } this.state = b.PARSED, this.hls.trigger(m.FRAG_PARSED, { frag: s, part: e }) } else this.warn("level.details undefined") } resetTransmuxer() { this.transmuxer && (this.transmuxer.destroy(), this.transmuxer = null) } recoverWorkerError(e) { "demuxerWorker" === e.event && (this.resetTransmuxer(), this.resetLoadingState()) } set state(e) { var t = this._state; t !== e && (this._state = e, this.log(t + "->" + e)) } get state() { return this._state } } function _i() { return self.SourceBuffer || self.WebKitSourceBuffer } function Bn() { var e, t = fe(); return !!t && (e = _i(), t = t && "function" == typeof t.isTypeSupported && t.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"'), e = !e || e.prototype && "function" == typeof e.prototype.appendBuffer && "function" == typeof e.prototype.remove, !!t) && !!e } function $n() { var e = _i(); return "function" == typeof (null == e || null == (e = e.prototype) ? void 0 : e.changeType) } function Gn() { return "function" == typeof __HLS_WORKER_BUNDLE__ } function Kn() { var e = new self.Blob([`var exports={};var module={exports:exports};function define(f){f()};define.amd=true;(${__HLS_WORKER_BUNDLE__.toString()})(true);`], { type: "text/javascript" }), e = self.URL.createObjectURL(e); return { worker: new self.Worker(e), objectURL: e } } function Hn(e) { e = new self.URL(e, self.location.href).href; return { worker: new self.Worker(e), scriptURL: e } } function xt(e = "", t = 9e4) { return { type: e, id: -1, pid: -1, inputTimeScale: t, sequenceNumber: -1, samples: [], dropped: 0 } } class wi { constructor() { this._audioTrack = void 0, this._id3Track = void 0, this.frameIndex = 0, this.cachedData = null, this.basePTS = null, this.initPTS = null, this.lastPTS = null } resetInitSegment(e, t, r, i) { this._id3Track = { type: "id3", id: 3, pid: -1, inputTimeScale: 9e4, sequenceNumber: 0, samples: [], dropped: 0 } } resetTimeStamp(e) { this.initPTS = e, this.resetContiguity() } resetContiguity() { this.basePTS = null, this.lastPTS = null, this.frameIndex = 0 } canParse(e, t) { return !1 } appendFrame(e, t, r) { } demux(e, t) { this.cachedData && (e = Pt(this.cachedData, e), this.cachedData = null); let r = ne(e, 0), i = r ? r.length : 0, s; var a, n = this._audioTrack, o = this._id3Track, l = r ? Lr(r) : void 0, h = e.length; for ((null === this.basePTS || 0 === this.frameIndex && F(l)) && (this.basePTS = Vn(l, t, this.initPTS), this.lastPTS = this.basePTS), null === this.lastPTS && (this.lastPTS = this.basePTS), r && 0 < r.length && o.samples.push({ pts: this.lastPTS, dts: this.lastPTS, data: r, type: Tt.audioId3, duration: Number.POSITIVE_INFINITY }); i < h;)this.canParse(e, i) ? (a = this.appendFrame(n, e, i)) ? (this.frameIndex++, this.lastPTS = a.sample.pts, i += a.length, s = i) : i = h : Ar(e, i) ? (r = ne(e, i), o.samples.push({ pts: this.lastPTS, dts: this.lastPTS, data: r, type: Tt.audioId3, duration: Number.POSITIVE_INFINITY }), i += r.length, s = i) : i++, i === h && s !== h && (a = wt(e, s), this.cachedData ? this.cachedData = Pt(this.cachedData, a) : this.cachedData = a); return { audioTrack: n, videoTrack: xt(), id3Track: o, textTrack: xt() } } demuxSampleAes(e, t, r) { return Promise.reject(new Error(`[${this}] This demuxer does not support Sample-AES decryption`)) } flush(e) { var t = this.cachedData; return t && (this.cachedData = null, this.demux(t, 0)), { audioTrack: this._audioTrack, videoTrack: xt(), id3Track: this._id3Track, textTrack: xt() } } destroy() { } } let Vn = (e, t, r) => F(e) ? 90 * e : 9e4 * t + (r ? 9e4 * r.baseTime / r.timescale : 0); function Wn(e, t, r, i) { let s, a, n, o; var l = navigator.userAgent.toLowerCase(), h = i, d = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350], u = (s = 1 + ((192 & t[r + 2]) >>> 6), (60 & t[r + 2]) >>> 2); if (!(d.length - 1 < u)) return n = (1 & t[r + 2]) << 2, n |= (192 & t[r + 3]) >>> 6, E.log(`manifest codec:${i}, ADTS type:${s}, samplingIndex:` + u), a = /firefox/i.test(l) ? 6 <= u ? (s = 5, o = new Array(4), u - 3) : (s = 2, o = new Array(2), u) : -1 !== l.indexOf("android") ? (s = 2, o = new Array(2), u) : (s = 5, o = new Array(4), i && (-1 !== i.indexOf("mp4a.40.29") || -1 !== i.indexOf("mp4a.40.5")) || !i && 6 <= u ? u - 3 : ((i && -1 !== i.indexOf("mp4a.40.2") && (6 <= u && 1 == n || /vivaldi/i.test(l)) || !i && 1 == n) && (s = 2, o = new Array(2)), u)), o[0] = s << 3, o[0] |= (14 & u) >> 1, o[1] |= (1 & u) << 7, o[1] |= n << 3, 5 === s && (o[1] |= (14 & a) >> 1, o[2] = (1 & a) << 7, o[2] |= 8, o[3] = 0), { config: o, samplerate: d[u], channelCount: n, codec: "mp4a.40." + s, manifestCodec: h }; e.trigger(m.ERROR, { type: N.MEDIA_ERROR, details: L.FRAG_PARSING_ERROR, fatal: !0, reason: "invalid ADTS sampling index:" + u }) } function Pi(e, t) { return 255 === e[t] && 240 == (246 & e[t + 1]) } function Fi(e, t) { return 1 & e[t + 1] ? 7 : 9 } function ns(e, t) { return (3 & e[t + 3]) << 11 | e[t + 4] << 3 | (224 & e[t + 5]) >>> 5 } function Yn(e, t) { return t + 5 < e.length } function he(e, t) { return t + 1 < e.length && Pi(e, t) } function qn(e, t) { return Yn(e, t) && Pi(e, t) && ns(e, t) <= e.length - t } function jn(e, t) { var r, i; return !!he(e, t) && !(t + (i = Fi(e, t)) >= e.length || (r = ns(e, t)) <= i) && ((i = t + r) === e.length || he(e, i)) } function Oi(e, t, r, i, s) { e.samplerate || (t = Wn(t, r, i, s)) && (e.config = t.config, e.samplerate = t.samplerate, e.channelCount = t.channelCount, e.codec = t.codec, e.manifestCodec = t.manifestCodec, E.log(`parsed codec:${e.codec}, rate:${t.samplerate}, channels:` + t.channelCount)) } function Mi(e) { return 9216e4 / e } function Xn(e, t) { var r = Fi(e, t); if (t + r <= e.length) { e = ns(e, t) - r; if (0 < e) return { headerLength: r, frameLength: e } } } function Ni(e, t, r, i, s) { var a, n, i = i + s * Mi(e.samplerate), s = Xn(t, r); let o; return s ? ({ frameLength: s, headerLength: n } = s, s = n + s, (a = Math.max(0, r + s - t.length)) ? (o = new Uint8Array(s - n)).set(t.subarray(r + n, t.length), 0) : o = t.subarray(r + n, r + s), n = { unit: o, pts: i }, a || e.samples.push(n), { sample: n, length: s, missing: a }) : (e = t.length - r, (o = new Uint8Array(e)).set(t.subarray(r, t.length), 0), { sample: { unit: o, pts: i }, length: e, missing: -1 }) } class zn extends wi { constructor(e, t) { super(), this.observer = void 0, this.config = void 0, this.observer = e, this.config = t } resetInitSegment(e, t, r, i) { super.resetInitSegment(e, t, r, i), this._audioTrack = { container: "audio/adts", type: "audio", id: 2, pid: -1, sequenceNumber: 0, segmentCodec: "aac", samples: [], manifestCodec: t, duration: i, inputTimeScale: 9e4, dropped: 0 } } static probe(t) { if (t) { let e = (ne(t, 0) || []).length; for (var r = t.length; e < r; e++)if (jn(t, e)) return E.log("ADTS sync word found !"), !0 } return !1 } canParse(e, t) { return qn(e, t) } appendFrame(e, t, r) { Oi(e, this.observer, t, r, e.manifestCodec); e = Ni(e, t, r, this.basePTS, this.frameIndex); if (e && 0 === e.missing) return e } } let Qn = /\/emsg[-/]ID3/i; class Jn { constructor(e, t) { this.remainderData = null, this.timeOffset = 0, this.config = void 0, this.videoTrack = void 0, this.audioTrack = void 0, this.id3Track = void 0, this.txtTrack = void 0, this.config = t } resetTimeStamp() { } resetInitSegment(e, t, r, i) { var s, a, n, o = this.videoTrack = xt("video", 1), l = this.audioTrack = xt("audio", 1), h = this.txtTrack = xt("text", 1); this.id3Track = xt("id3", 1), this.timeOffset = 0, null != e && e.byteLength && ((e = yi(e)).video && ({ id: s, timescale: a, codec: n } = e.video, o.id = s, o.timescale = h.timescale = a, o.codec = n), e.audio && ({ id: s, timescale: a, codec: n } = e.audio, l.id = s, l.timescale = a, l.codec = n), h.id = mi.text, o.sampleDuration = 0, o.duration = l.duration = i) } resetContiguity() { this.remainderData = null } static probe(e) { return 0 < $(e = 16384 < e.length ? e.subarray(0, 16384) : e, ["moof"]).length } demux(e, t) { this.timeOffset = t; let r = e; var i = this.videoTrack, s = this.txtTrack, e = (this.config.progressive ? (e = Br(r = this.remainderData ? Pt(this.remainderData, e) : r), this.remainderData = e.remainder, i.samples = e.valid || new Uint8Array) : i.samples = r, this.extractID3Track(i, t)); return s.samples = ps(t, i), { videoTrack: i, audioTrack: this.audioTrack, id3Track: e, textTrack: this.txtTrack } } flush() { var e = this.timeOffset, t = this.videoTrack, r = this.txtTrack, i = (t.samples = this.remainderData || new Uint8Array, this.remainderData = null, this.extractID3Track(t, this.timeOffset)); return r.samples = ps(e, t), { videoTrack: t, audioTrack: xt(), id3Track: i, textTrack: xt() } } extractID3Track(e, i) { let s = this.id3Track; return e.samples.length && (e = $(e.samples, ["emsg"])) && e.forEach(t => { t = Kr(t); if (Qn.test(t.schemeIdUri)) { var r = F(t.presentationTime) ? t.presentationTime / t.timeScale : i + t.presentationTimeDelta / t.timeScale; let e = 4294967295 === t.eventDuration ? Number.POSITIVE_INFINITY : t.eventDuration / t.timeScale; e <= .001 && (e = Number.POSITIVE_INFINITY); t = t.payload; s.samples.push({ data: t, len: t.byteLength, dts: r, pts: r, type: Tt.emsg, duration: e }) } }), s } demuxSampleAes(e, t, r) { return Promise.reject(new Error("The MP4 demuxer does not support SAMPLE-AES decryption")) } destroy() { } } let Jt = null, Zn = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160], ta = [44100, 48e3, 32e3, 22050, 24e3, 16e3, 11025, 12e3, 8e3], ea = [[0, 72, 144, 12], [0, 0, 0, 0], [0, 72, 144, 12], [0, 144, 144, 12]], sa = [0, 1, 1, 4]; function Ui(e, t, r, i, s) { var a; return !(r + 24 > t.length) && (a = Bi(t, r)) && r + a.frameLength <= t.length ? (i = i + s * (9e4 * a.samplesPerFrame / a.sampleRate), s = { unit: t.subarray(r, r + a.frameLength), pts: i, dts: i }, e.config = [], e.channelCount = a.channelCount, e.samplerate = a.sampleRate, e.samples.push(s), { sample: s, length: a.frameLength, missing: 0 }) : void 0 } function Bi(e, t) { var r, i, s, a, n, o = e[t + 1] >> 3 & 3, l = e[t + 1] >> 1 & 3, h = e[t + 2] >> 4 & 15, d = e[t + 2] >> 2 & 3; if (1 != o && 0 != h && 15 != h && 3 != d) return n = e[t + 2] >> 1 & 1, r = e[t + 3] >> 6, i = 3 == o ? 3 - l : 3 == l ? 3 : 4, i = 1e3 * Zn[14 * i + h - 1], h = ta[3 * (3 == o ? 0 : 2 == o ? 1 : 2) + d], d = 3 == r ? 1 : 2, a = 8 * (o = ea[o][l]) * (s = sa[l]), o = Math.floor(o * i / h + n) * s, null === Jt && (n = (navigator.userAgent || "").match(/Chrome\/(\d+)/i), Jt = n ? parseInt(n[1]) : 0), Jt && Jt <= 87 && 2 == l && 224e3 <= i && 0 == r && (e[t + 3] = 128 | e[t + 3]), { sampleRate: h, channelCount: d, frameLength: o, samplesPerFrame: a } } function as(e, t) { return 255 === e[t] && 224 == (224 & e[t + 1]) && 0 != (6 & e[t + 1]) } function $i(e, t) { return t + 1 < e.length && as(e, t) } function ia(e, t) { return as(e, t) && 4 <= e.length - t } function ra(t, r) { if (r + 1 < t.length && as(t, r)) { var i = Bi(t, r); let e = 4; r = r + (e = null != i && i.frameLength ? i.frameLength : e); return r === t.length || $i(t, r) } return !1 } class Bs { constructor(e) { this.data = void 0, this.bytesAvailable = void 0, this.word = void 0, this.bitsAvailable = void 0, this.data = e, this.bytesAvailable = e.byteLength, this.word = 0, this.bitsAvailable = 0 } loadWord() { var e = this.data, t = this.bytesAvailable, r = e.byteLength - t, i = new Uint8Array(4), t = Math.min(4, t); if (0 === t) throw new Error("no bytes available"); i.set(e.subarray(r, r + t)), this.word = new DataView(i.buffer).getUint32(0), this.bitsAvailable = 8 * t, this.bytesAvailable -= t } skipBits(e) { var t; e = Math.min(e, 8 * this.bytesAvailable + this.bitsAvailable), this.bitsAvailable > e || (e = (e -= this.bitsAvailable) - ((t = e >> 3) << 3), this.bytesAvailable -= t, this.loadWord()), this.word <<= e, this.bitsAvailable -= e } readBits(e) { var t = Math.min(this.bitsAvailable, e), r = this.word >>> 32 - t; if (32 < e && E.error("Cannot read more than 32 bits at a time"), this.bitsAvailable -= t, 0 < this.bitsAvailable) this.word <<= t; else { if (!(0 < this.bytesAvailable)) throw new Error("no bits available"); this.loadWord() } return 0 < (t = e - t) && this.bitsAvailable ? r << t | this.readBits(t) : r } skipLZ() { let e; for (e = 0; e < this.bitsAvailable; ++e)if (this.word & 2147483648 >>> e) return this.word <<= e, this.bitsAvailable -= e, e; return this.loadWord(), e + this.skipLZ() } skipUEG() { this.skipBits(1 + this.skipLZ()) } skipEG() { this.skipBits(1 + this.skipLZ()) } readUEG() { var e = this.skipLZ(); return this.readBits(e + 1) - 1 } readEG() { var e = this.readUEG(); return 1 & e ? 1 + e >>> 1 : -1 * (e >>> 1) } readBoolean() { return 1 === this.readBits(1) } readUByte() { return this.readBits(8) } readUShort() { return this.readBits(16) } readUInt() { return this.readBits(32) } skipScalingList(t) { let r = 8, i = 8, s; for (let e = 0; e < t; e++)0 !== i && (s = this.readEG(), i = (r + s + 256) % 256), r = 0 === i ? r : i } readSPS() { let e = 0, t = 0, r = 0, i = 0, s, a, n; var o = this.readUByte.bind(this), l = this.readBits.bind(this), h = this.readUEG.bind(this), d = this.readBoolean.bind(this), u = this.skipBits.bind(this), c = this.skipEG.bind(this), f = this.skipUEG.bind(this), g = this.skipScalingList.bind(this), m = (o(), o()); if (l(5), u(3), o(), f(), 100 === m || 110 === m || 122 === m || 244 === m || 44 === m || 83 === m || 86 === m || 118 === m || 128 === m) { m = h(); if (3 === m && u(1), f(), f(), u(1), d()) for (a = 3 !== m ? 8 : 12, n = 0; n < a; n++)d() && (n < 6 ? g(16) : g(64)) } f(); m = h(); if (0 === m) h(); else if (1 === m) for (u(1), c(), c(), s = h(), n = 0; n < s; n++)c(); f(), u(1); m = h(), f = h(), l = l(1); 0 === l && u(1), u(1), d() && (e = h(), t = h(), r = h(), i = h()); let p = [1, 1]; if (d() && d()) switch (o()) { case 1: p = [1, 1]; break; case 2: p = [12, 11]; break; case 3: p = [10, 11]; break; case 4: p = [16, 11]; break; case 5: p = [40, 33]; break; case 6: p = [24, 11]; break; case 7: p = [20, 11]; break; case 8: p = [32, 11]; break; case 9: p = [80, 33]; break; case 10: p = [18, 11]; break; case 11: p = [15, 11]; break; case 12: p = [64, 33]; break; case 13: p = [160, 99]; break; case 14: p = [4, 3]; break; case 15: p = [3, 2]; break; case 16: p = [2, 1]; break; case 255: p = [o() << 8 | o(), o() << 8 | o()] }return { width: Math.ceil(16 * (m + 1) - 2 * e - 2 * t), height: (2 - l) * (f + 1) * 16 - (l ? 2 : 4) * (r + i), pixelRatio: p } } readSliceType() { return this.readUByte(), this.readUEG(), this.readUEG() } } class na { constructor(e, t, r) { this.keyData = void 0, this.decrypter = void 0, this.keyData = r, this.decrypter = new is(t, { removePKCS7Padding: !1 }) } decryptBuffer(e) { return this.decrypter.decrypt(e, this.keyData.key.buffer, this.keyData.iv.buffer) } decryptAacSample(t, r, i) { let s = t[r].unit; var e; s.length <= 16 || (e = (e = s.subarray(16, s.length - s.length % 16)).buffer.slice(e.byteOffset, e.byteOffset + e.length), this.decryptBuffer(e).then(e => { e = new Uint8Array(e); s.set(e, 16), this.decrypter.isSync() || this.decryptAacSamples(t, r + 1, i) })) } decryptAacSamples(e, t, r) { for (; ; t++) { if (t >= e.length) return void r(); if (!(e[t].unit.length < 32 || (this.decryptAacSample(e, t, r), this.decrypter.isSync()))) return } } getAvcEncryptedData(t) { var e = 16 * Math.floor((t.length - 48) / 160) + 16, r = new Int8Array(e); let i = 0; for (let e = 32; e < t.length - 16; e += 160, i += 16)r.set(t.subarray(e, e + 16), i); return r } getAvcDecryptedUnit(t, e) { var r = new Uint8Array(e); let i = 0; for (let e = 32; e < t.length - 16; e += 160, i += 16)t.set(r.subarray(i, i + 16), e); return t } decryptAvcSample(t, r, i, s, a) { let n = Si(a.data), e = this.getAvcEncryptedData(n); this.decryptBuffer(e.buffer).then(e => { a.data = this.getAvcDecryptedUnit(n, e), this.decrypter.isSync() || this.decryptAvcSamples(t, r, i + 1, s) }) } decryptAvcSamples(e, t, r, i) { if (e instanceof Uint8Array) throw new Error("Cannot decrypt samples of type Uint8Array"); for (; ; t++, r = 0) { if (t >= e.length) return void i(); for (var s = e[t].units; !(r >= s.length); r++) { var a = s[r]; if (!(a.data.length <= 48 || 1 !== a.type && 5 !== a.type || (this.decryptAvcSample(e, t, r, i, a), this.decrypter.isSync()))) return } } } } let it = 188; class bt { constructor(e, t, r) { this.observer = void 0, this.config = void 0, this.typeSupported = void 0, this.sampleAes = null, this.pmtParsed = !1, this.audioCodec = void 0, this.videoCodec = void 0, this._duration = 0, this._pmtId = -1, this._avcTrack = void 0, this._audioTrack = void 0, this._id3Track = void 0, this._txtTrack = void 0, this.aacOverFlow = null, this.avcSample = null, this.remainderData = null, this.observer = e, this.config = t, this.typeSupported = r } static probe(e) { e = bt.syncOffset(e); return 0 < e && E.warn("MPEG2-TS detected but first sync word found @ offset " + e), -1 !== e } static syncOffset(s) { var a = s.length; let n = Math.min(5 * it, s.length - it) + 1, o = 0; for (; o < n;) { let t = !1, r = -1, i = 0; for (let e = o; e < a; e += it) { if (71 !== s[e]) { if (i) return -1; break } if (i++, -1 === r && 0 !== (r = e) && (n = Math.min(r + 99 * it, s.length - it) + 1), (t = t || 0 === Ye(s, e)) && 1 < i && (0 === r && 2 < i || e + it > n)) return r } o++ } return -1 } static createTrack(e, t) { return { container: "video" === e || "audio" === e ? "video/mp2t" : void 0, type: e, id: mi[e], pid: -1, inputTimeScale: 9e4, sequenceNumber: 0, samples: [], dropped: 0, duration: "audio" === e ? t : void 0 } } resetInitSegment(e, t, r, i) { this.pmtParsed = !1, this._pmtId = -1, this._avcTrack = bt.createTrack("video"), this._audioTrack = bt.createTrack("audio", i), this._id3Track = bt.createTrack("id3"), this._txtTrack = bt.createTrack("text"), this._audioTrack.segmentCodec = "aac", this.aacOverFlow = null, this.avcSample = null, this.remainderData = null, this.audioCodec = t, this.videoCodec = r, this._duration = i } resetTimeStamp() { } resetContiguity() { var { _audioTrack: e, _avcTrack: t, _id3Track: r } = this; e && (e.pesData = null), t && (t.pesData = null), r && (r.pesData = null), this.aacOverFlow = null, this.avcSample = null, this.remainderData = null } demux(r, e, i = !1, t = !1) { i || (this.sampleAes = null); let s; var a = this._avcTrack, n = this._audioTrack, o = this._id3Track, l = this._txtTrack; let h = a.pid, d = a.pesData, u = n.pid, c = o.pid, f = n.pesData, g = o.pesData, p = null, v = this.pmtParsed, T = this._pmtId, y = r.length; if (this.remainderData && (r = Pt(this.remainderData, r), y = r.length, this.remainderData = null), y < it && !t) return this.remainderData = r, { audioTrack: n, videoTrack: a, id3Track: o, textTrack: l }; var S = Math.max(0, bt.syncOffset(r)); (y -= (y - S) % it) < r.byteLength && !t && (this.remainderData = new Uint8Array(r.buffer, y, r.buffer.byteLength - y)); let A = 0; for (let t = S; t < y; t += it)if (71 === r[t]) { var R = !!(64 & r[t + 1]), I = Ye(r, t); let e; if (1 < (48 & r[t + 3]) >> 4) { if ((e = t + 5 + r[t + 4]) === t + it) continue } else e = t + 4; switch (I) { case h: R && (d && (s = Ot(d)) && this.parseAVCPES(a, l, s, !1), d = { data: [], size: 0 }), d && (d.data.push(r.subarray(e, t + it)), d.size += t + it - e); break; case u: if (R) { if (f && (s = Ot(f))) switch (n.segmentCodec) { case "aac": this.parseAACPES(n, s); break; case "mp3": this.parseMPEGPES(n, s) }f = { data: [], size: 0 } } f && (f.data.push(r.subarray(e, t + it)), f.size += t + it - e); break; case c: R && (g && (s = Ot(g)) && this.parseID3PES(o, s), g = { data: [], size: 0 }), g && (g.data.push(r.subarray(e, t + it)), g.size += t + it - e); break; case 0: R && (e += r[e] + 1), T = this._pmtId = aa(r, e); break; case T: R && (e += r[e] + 1); var D = oa(r, e, this.typeSupported, i); 0 < (h = D.avc) && (a.pid = h), 0 < (u = D.audio) && (n.pid = u, n.segmentCodec = D.segmentCodec), 0 < (c = D.id3) && (o.pid = c), null === p || v || (E.warn(`MPEG-TS PMT found at ${t} after unknown PID '${p}'. Backtracking to sync byte @${S} to parse all TS packets.`), p = null, t = S - 188), v = this.pmtParsed = !0; break; case 17: case 8191: break; default: p = I } } else A++; 0 < A && (b = new Error(`Found ${A} TS packet/s that do not start with 0x47`), this.observer.emit(m.ERROR, m.ERROR, { type: N.MEDIA_ERROR, details: L.FRAG_PARSING_ERROR, fatal: !1, error: b, reason: b.message })), a.pesData = d, n.pesData = f, o.pesData = g; var b = { audioTrack: n, videoTrack: a, id3Track: o, textTrack: l }; return t && this.extractRemainingSamples(b), b } flush() { var e = this.remainderData; this.remainderData = null; let t; return t = e ? this.demux(e, -1, !1, !0) : { videoTrack: this._avcTrack, audioTrack: this._audioTrack, id3Track: this._id3Track, textTrack: this._txtTrack }, this.extractRemainingSamples(t), this.sampleAes ? this.decrypt(t, this.sampleAes) : t } extractRemainingSamples(e) { var { audioTrack: t, videoTrack: e, id3Track: r, textTrack: i } = e, s = e.pesData, a = t.pesData, n = r.pesData; let o; if (s && (o = Ot(s)) ? (this.parseAVCPES(e, i, o, !0), e.pesData = null) : e.pesData = s, a && (o = Ot(a))) { switch (t.segmentCodec) { case "aac": this.parseAACPES(t, o); break; case "mp3": this.parseMPEGPES(t, o) }t.pesData = null } else null != a && a.size && E.log("last AAC PES packet truncated,might overlap between fragments"), t.pesData = a; n && (o = Ot(n)) ? (this.parseID3PES(r, o), r.pesData = null) : r.pesData = n } demuxSampleAes(e, t, r) { e = this.demux(e, r, !0, !this.config.progressive), r = this.sampleAes = new na(this.observer, this.config, t); return this.decrypt(e, r) } decrypt(i, s) { return new Promise(e => { let { audioTrack: t, videoTrack: r } = i; t.samples && "aac" === t.segmentCodec ? s.decryptAacSamples(t.samples, 0, () => { r.samples ? s.decryptAvcSamples(r.samples, 0, 0, () => { e(i) }) : e(i) }) : r.samples && s.decryptAvcSamples(r.samples, 0, 0, () => { e(i) }) }) } destroy() { this._duration = 0 } parseAVCPES(a, r, n, e) { var t = this.parseAVCNALu(a, n.data); let o = this.avcSample, l, h = !1; n.data = null, o && t.length && !a.audFound && (Le(o, a), o = this.avcSample = Zt(!1, n.pts, n.dts, "")), t.forEach(e => { switch (e.type) { case 1: l = !0, (o = o || (this.avcSample = Zt(!0, n.pts, n.dts, ""))).frame = !0; var t = e.data; h && 4 < t.length && (2 !== (t = new Bs(t).readSliceType()) && 4 !== t && 7 !== t && 9 !== t || (o.key = !0)); break; case 5: l = !0, (o = o || (this.avcSample = Zt(!0, n.pts, n.dts, ""))).key = !0, o.frame = !0; break; case 6: l = !0, xi(e.data, 1, n.pts, r.samples); break; case 7: if (l = !0, h = !0, !a.sps) { var t = e.data, i = new Bs(t).readSPS(), s = (a.width = i.width, a.height = i.height, a.pixelRatio = i.pixelRatio, a.sps = [t], a.duration = this._duration, t.subarray(1, 4)); let r = "avc1."; for (let t = 0; t < 3; t++) { let e = s[t].toString(16); e.length < 2 && (e = "0" + e), r += e } a.codec = r } break; case 8: l = !0, a.pps || (a.pps = [e.data]); break; case 9: l = !1, a.audFound = !0, o && Le(o, a), o = this.avcSample = Zt(!1, n.pts, n.dts, ""); break; case 12: l = !0; break; default: l = !1, o && (o.debug += "unknown NAL " + e.type + " ") }o && l && o.units.push(e) }), e && o && (Le(o, a), this.avcSample = null) } getLastNalUnit(e) { let t, r = this.avcSample, i; return null != (t = r = r && 0 !== r.units.length ? r : e[e.length - 1]) && t.units && (e = r.units, i = e[e.length - 1]), i } parseAVCNALu(e, t) { var r = t.byteLength; let i = e.naluState || 0; var s, a, n, o, l = i, h = []; let d = 0, u, c, f, g = -1, m = 0; for (-1 === i && (g = 0, m = 31 & t[0], i = 0, d = 1); d < r;)(u = t[d++], i) ? i = 1 === i ? u ? 0 : 2 : u ? 1 === u ? (0 <= g ? (s = { data: t.subarray(g, d - i - 1), type: m }, h.push(s)) : (s = this.getLastNalUnit(e.samples)) && (l && d <= 4 - l && s.state && (s.data = s.data.subarray(0, s.data.byteLength - l)), 0 < (c = d - i - 1)) && ((a = new Uint8Array(s.data.byteLength + c)).set(s.data, 0), a.set(t.subarray(0, c), s.data.byteLength), s.data = a, s.state = 0), d < r ? (f = 31 & t[d], g = d, m = f, 0) : -1) : 0 : 3 : i = u ? 0 : 1; return 0 <= g && 0 <= i && (n = { data: t.subarray(g, r), type: m, state: i }, h.push(n)), 0 === h.length && (n = this.getLastNalUnit(e.samples)) && ((o = new Uint8Array(n.data.byteLength + t.byteLength)).set(n.data, 0), o.set(t, n.data.byteLength), n.data = o), e.naluState = i, h } parseAACPES(e, t) { let r = 0; var i = this.aacOverFlow; let s = t.data; i && (this.aacOverFlow = null, l = i.missing, o = i.sample.unit.byteLength, -1 === l ? ((d = new Uint8Array(o + s.byteLength)).set(i.sample.unit, 0), d.set(s, o), s = d) : (d = o - l, i.sample.unit.set(s.subarray(0, l), d), e.samples.push(i.sample), r = i.missing)); let a, n; for (a = r, n = s.length; a < n - 1 && !he(s, a); a++); if (a !== r) { let e; var o = a < n - 1, l = (e = o ? "AAC PES did not start with ADTS header,offset:" + a : "No ADTS header found in AAC PES", new Error(e)); if (E.warn("parsing error: " + e), this.observer.emit(m.ERROR, m.ERROR, { type: N.MEDIA_ERROR, details: L.FRAG_PARSING_ERROR, fatal: !1, levelRetry: o, error: l, reason: e }), !o) return } Oi(e, this.observer, s, a, this.audioCodec); let h; if (void 0 !== t.pts) h = t.pts; else { if (!i) return void E.warn("[tsdemuxer]: AAC PES unknown PTS"); var d = Mi(e.samplerate); h = i.sample.pts + d } let u = 0, c; for (; a < n;) { if (c = Ni(e, s, a, h, u), a += c.length, c.missing) { this.aacOverFlow = c; break } for (u++; a < n - 1 && !he(s, a); a++); } } parseMPEGPES(e, t) { var r = t.data, i = r.length; let s = 0, a = 0; var n = t.pts; if (void 0 === n) E.warn("[tsdemuxer]: MPEG PES unknown PTS"); else for (; a < i;)if ($i(r, a)) { var o = Ui(e, r, a, n, s); if (!o) break; a += o.length, s++ } else a++ } parseID3PES(e, t) { void 0 === t.pts ? E.warn("[tsdemuxer]: ID3 PES unknown PTS") : (t = tt({}, t, { type: this._avcTrack ? Tt.emsg : Tt.audioId3, duration: Number.POSITIVE_INFINITY }), e.samples.push(t)) } } function Zt(e, t, r, i) { return { key: e, frame: !1, pts: t, dts: r, units: [], debug: i, length: 0 } } function Ye(e, t) { return ((31 & e[t + 1]) << 8) + e[t + 2] } function aa(e, t) { return (31 & e[t + 10]) << 8 | e[t + 11] } function oa(e, t, r, i) { var s = { audio: -1, avc: -1, id3: -1, segmentCodec: "aac" }, a = t + 3 + ((15 & e[t + 1]) << 8 | e[t + 2]) - 4; for (t += 12 + ((15 & e[t + 10]) << 8 | e[t + 11]); t < a;) { var n = Ye(e, t); switch (e[t]) { case 207: if (!i) { E.log("ADTS AAC with AES-128-CBC frame encryption found in unencrypted stream"); break } case 15: -1 === s.audio && (s.audio = n); break; case 21: -1 === s.id3 && (s.id3 = n); break; case 219: if (!i) { E.log("H.264 with AES-128-CBC slice encryption found in unencrypted stream"); break } case 27: -1 === s.avc && (s.avc = n); break; case 3: case 4: !0 !== r.mpeg && !0 !== r.mp3 ? E.log("MPEG audio found, not supported in this browser") : -1 === s.audio && (s.audio = n, s.segmentCodec = "mp3"); break; case 36: E.warn("Unsupported HEVC stream type found") }t += 5 + ((15 & e[t + 3]) << 8 | e[t + 4]) } return s } function Ot(e) { let i = 0, s, t, a, n, o; var l = e.data; if (!e || 0 === e.size) return null; for (; l[0].length < 19 && 1 < l.length;) { var r = new Uint8Array(l[0].length + l[1].length); r.set(l[0]), r.set(l[1], l[0].length), l[0] = r, l.splice(1, 1) } if (((s = l[0])[0] << 16) + (s[1] << 8) + s[2] !== 1) return null; { if ((t = (s[4] << 8) + s[5]) && t > e.size - 6) return null; var h = s[7]; 192 & h && (n = 536870912 * (14 & s[9]) + 4194304 * (255 & s[10]) + 16384 * (254 & s[11]) + 128 * (255 & s[12]) + (254 & s[13]) / 2, 64 & h ? (o = 536870912 * (14 & s[14]) + 4194304 * (255 & s[15]) + 16384 * (254 & s[16]) + 128 * (255 & s[17]) + (254 & s[18]) / 2, 54e5 < n - o && (E.warn(Math.round((n - o) / 9e4) + "s delta between PTS and DTS, align them"), n = o)) : o = n); let r = (a = s[8]) + 9; if (e.size <= r) return null; e.size -= r; var d = new Uint8Array(e.size); for (let t = 0, e = l.length; t < e; t++) { let e = (s = l[t]).byteLength; if (r) { if (r > e) { r -= e; continue } s = s.subarray(r), e -= r, r = 0 } d.set(s, i), i += e } return t && (t -= a + 3), { data: d, pts: n, dts: o, len: t } } } function Le(e, t) { if (e.units.length && e.frame) { if (void 0 === e.pts) { var r = t.samples, i = r.length; if (!i) return void t.dropped++; r = r[i - 1]; e.pts = r.pts, e.dts = r.dts } t.samples.push(e) } e.debug.length && E.log(e.pts + "/" + e.dts + ":" + e.debug) } class la extends wi { resetInitSegment(e, t, r, i) { super.resetInitSegment(e, t, r, i), this._audioTrack = { container: "audio/mpeg", type: "audio", id: 2, pid: -1, sequenceNumber: 0, segmentCodec: "mp3", samples: [], manifestCodec: t, duration: i, inputTimeScale: 9e4, dropped: 0 } } static probe(t) { if (t) { let e = (ne(t, 0) || []).length; for (var r = t.length; e < r; e++)if (ra(t, e)) return E.log("MPEG Audio sync word found !"), !0 } return !1 } canParse(e, t) { return ia(e, t) } appendFrame(e, t, r) { if (null !== this.basePTS) return Ui(e, t, r, this.basePTS, this.frameIndex) } } class $s { static getSilentFrame(e, t) { if ("mp4a.40.2" === e) return 1 === t ? new Uint8Array([0, 200, 0, 128, 35, 128]) : 2 === t ? new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]) : 3 === t ? new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]) : 4 === t ? new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]) : 5 === t ? new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]) : 6 === t ? new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224]) : void 0; else return 1 === t ? new Uint8Array([1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]) : 2 === t || 3 === t ? new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]) : void 0 } } let It = Math.pow(2, 32) - 1; class v { static init() { v.types = { avc1: [], avcC: [], btrt: [], dinf: [], dref: [], esds: [], ftyp: [], hdlr: [], mdat: [], mdhd: [], mdia: [], mfhd: [], minf: [], moof: [], moov: [], mp4a: [], ".mp3": [], mvex: [], mvhd: [], pasp: [], sdtp: [], stbl: [], stco: [], stsc: [], stsd: [], stsz: [], stts: [], tfdt: [], tfhd: [], traf: [], trak: [], trun: [], trex: [], tkhd: [], vmhd: [], smhd: [] }; let e; for (e in v.types) v.types.hasOwnProperty(e) && (v.types[e] = [e.charCodeAt(0), e.charCodeAt(1), e.charCodeAt(2), e.charCodeAt(3)]); var t = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 118, 105, 100, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 105, 100, 101, 111, 72, 97, 110, 100, 108, 101, 114, 0]), r = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 111, 117, 110, 100, 72, 97, 110, 100, 108, 101, 114, 0]), t = (v.HDLR_TYPES = { video: t, audio: r }, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0, 0, 0, 1])), r = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]), r = (v.STTS = v.STSC = v.STCO = r, v.STSZ = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), v.VMHD = new Uint8Array([0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]), v.SMHD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]), v.STSD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1]), new Uint8Array([105, 115, 111, 109])), i = new Uint8Array([97, 118, 99, 49]), s = new Uint8Array([0, 0, 0, 1]); v.FTYP = v.box(v.types.ftyp, r, s, r, i), v.DINF = v.box(v.types.dinf, v.box(v.types.dref, t)) } static box(e, ...t) { let r = 8, i = t.length; for (var s = i; i--;)r += t[i].byteLength; var a = new Uint8Array(r); for (a[0] = r >> 24 & 255, a[1] = r >> 16 & 255, a[2] = r >> 8 & 255, a[3] = 255 & r, a.set(e, 4), i = 0, r = 8; i < s; i++)a.set(t[i], r), r += t[i].byteLength; return a } static hdlr(e) { return v.box(v.types.hdlr, v.HDLR_TYPES[e]) } static mdat(e) { return v.box(v.types.mdat, e) } static mdhd(e, t) { t *= e; var r = Math.floor(t / (It + 1)), t = Math.floor(t % (It + 1)); return v.box(v.types.mdhd, new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, 255 & e, r >> 24, r >> 16 & 255, r >> 8 & 255, 255 & r, t >> 24, t >> 16 & 255, t >> 8 & 255, 255 & t, 85, 196, 0, 0])) } static mdia(e) { return v.box(v.types.mdia, v.mdhd(e.timescale, e.duration), v.hdlr(e.type), v.minf(e)) } static mfhd(e) { return v.box(v.types.mfhd, new Uint8Array([0, 0, 0, 0, e >> 24, e >> 16 & 255, e >> 8 & 255, 255 & e])) } static minf(e) { return "audio" === e.type ? v.box(v.types.minf, v.box(v.types.smhd, v.SMHD), v.DINF, v.stbl(e)) : v.box(v.types.minf, v.box(v.types.vmhd, v.VMHD), v.DINF, v.stbl(e)) } static moof(e, t, r) { return v.box(v.types.moof, v.mfhd(e), v.traf(r, t)) } static moov(e) { let t = e.length; for (var r = []; t--;)r[t] = v.trak(e[t]); return v.box.apply(null, [v.types.moov, v.mvhd(e[0].timescale, e[0].duration)].concat(r).concat(v.mvex(e))) } static mvex(e) { let t = e.length; for (var r = []; t--;)r[t] = v.trex(e[t]); return v.box.apply(null, [v.types.mvex, ...r]) } static mvhd(e, t) { t *= e; var r = Math.floor(t / (It + 1)), t = Math.floor(t % (It + 1)), e = new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, 255 & e, r >> 24, r >> 16 & 255, r >> 8 & 255, 255 & r, t >> 24, t >> 16 & 255, t >> 8 & 255, 255 & t, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255]); return v.box(v.types.mvhd, e) } static sdtp(e) { var t = e.samples || [], r = new Uint8Array(4 + t.length); let i, s; for (i = 0; i < t.length; i++)s = t[i].flags, r[i + 4] = s.dependsOn << 4 | s.isDependedOn << 2 | s.hasRedundancy; return v.box(v.types.sdtp, r) } static stbl(e) { return v.box(v.types.stbl, v.stsd(e), v.box(v.types.stts, v.STTS), v.box(v.types.stsc, v.STSC), v.box(v.types.stsz, v.STSZ), v.box(v.types.stco, v.STCO)) } static avc1(e) { let t = [], r = [], i, s, a; for (i = 0; i < e.sps.length; i++)s = e.sps[i], a = s.byteLength, t.push(a >>> 8 & 255), t.push(255 & a), t = t.concat(Array.prototype.slice.call(s)); for (i = 0; i < e.pps.length; i++)s = e.pps[i], a = s.byteLength, r.push(a >>> 8 & 255), r.push(255 & a), r = r.concat(Array.prototype.slice.call(s)); var n = v.box(v.types.avcC, new Uint8Array([1, t[3], t[4], t[5], 255, 224 | e.sps.length].concat(t).concat([e.pps.length]).concat(r))), o = e.width, l = e.height, h = e.pixelRatio[0], d = e.pixelRatio[1]; return v.box(v.types.avc1, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, o >> 8 & 255, 255 & o, l >> 8 & 255, 255 & l, 0, 72, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 1, 18, 100, 97, 105, 108, 121, 109, 111, 116, 105, 111, 110, 47, 104, 108, 115, 46, 106, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 17, 17]), n, v.box(v.types.btrt, new Uint8Array([0, 28, 156, 128, 0, 45, 198, 192, 0, 45, 198, 192])), v.box(v.types.pasp, new Uint8Array([h >> 24, h >> 16 & 255, h >> 8 & 255, 255 & h, d >> 24, d >> 16 & 255, d >> 8 & 255, 255 & d]))) } static esds(e) { var t = e.config.length; return new Uint8Array([0, 0, 0, 0, 3, 23 + t, 0, 1, 0, 4, 15 + t, 64, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5].concat([t]).concat(e.config).concat([6, 1, 2])) } static mp4a(e) { var t = e.samplerate; return v.box(v.types.mp4a, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, e.channelCount, 0, 16, 0, 0, 0, 0, t >> 8 & 255, 255 & t, 0, 0]), v.box(v.types.esds, v.esds(e))) } static mp3(e) { var t = e.samplerate; return v.box(v.types[".mp3"], new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, e.channelCount, 0, 16, 0, 0, 0, 0, t >> 8 & 255, 255 & t, 0, 0])) } static stsd(e) { return "audio" === e.type ? "mp3" === e.segmentCodec && "mp3" === e.codec ? v.box(v.types.stsd, v.STSD, v.mp3(e)) : v.box(v.types.stsd, v.STSD, v.mp4a(e)) : v.box(v.types.stsd, v.STSD, v.avc1(e)) } static tkhd(e) { var t = e.id, r = e.duration * e.timescale, i = e.width, e = e.height, s = Math.floor(r / (It + 1)), r = Math.floor(r % (It + 1)); return v.box(v.types.tkhd, new Uint8Array([1, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, 255 & t, 0, 0, 0, 0, s >> 24, s >> 16 & 255, s >> 8 & 255, 255 & s, r >> 24, r >> 16 & 255, r >> 8 & 255, 255 & r, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, i >> 8 & 255, 255 & i, 0, 0, e >> 8 & 255, 255 & e, 0, 0])) } static traf(e, t) { var r = v.sdtp(e), i = e.id, s = Math.floor(t / (It + 1)), t = Math.floor(t % (It + 1)); return v.box(v.types.traf, v.box(v.types.tfhd, new Uint8Array([0, 0, 0, 0, i >> 24, i >> 16 & 255, i >> 8 & 255, 255 & i])), v.box(v.types.tfdt, new Uint8Array([1, 0, 0, 0, s >> 24, s >> 16 & 255, s >> 8 & 255, 255 & s, t >> 24, t >> 16 & 255, t >> 8 & 255, 255 & t])), v.trun(e, r.length + 16 + 20 + 8 + 16 + 8 + 8), r) } static trak(e) { return e.duration = e.duration || 4294967295, v.box(v.types.trak, v.tkhd(e), v.mdia(e)) } static trex(e) { e = e.id; return v.box(v.types.trex, new Uint8Array([0, 0, 0, 0, e >> 24, e >> 16 & 255, e >> 8 & 255, 255 & e, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1])) } static trun(e, t) { var r = e.samples || [], i = r.length, s = 12 + 16 * i, a = new Uint8Array(s); let n, o, l, h, d, u; for (a.set(["video" === e.type ? 1 : 0, 0, 15, 1, i >>> 24 & 255, i >>> 16 & 255, i >>> 8 & 255, 255 & i, (t += 8 + s) >>> 24 & 255, t >>> 16 & 255, t >>> 8 & 255, 255 & t], 0), n = 0; n < i; n++)l = (o = r[n]).duration, a.set([l >>> 24 & 255, l >>> 16 & 255, l >>> 8 & 255, 255 & l, (h = o.size) >>> 24 & 255, h >>> 16 & 255, h >>> 8 & 255, 255 & h, (d = o.flags).isLeading << 2 | d.dependsOn, d.isDependedOn << 6 | d.hasRedundancy << 4 | d.paddingValue << 1 | d.isNonSync, 61440 & d.degradPrio, 15 & d.degradPrio, (u = o.cts) >>> 24 & 255, u >>> 16 & 255, u >>> 8 & 255, 255 & u], 12 + 16 * n); return v.box(v.types.trun, a) } static initSegment(e) { v.types || v.init(); var e = v.moov(e), t = new Uint8Array(v.FTYP.byteLength + e.byteLength); return t.set(v.FTYP), t.set(e, v.FTYP.byteLength), t } } v.types = void 0, v.HDLR_TYPES = void 0, v.STTS = void 0, v.STSC = void 0, v.STCO = void 0, v.STSZ = void 0, v.VMHD = void 0, v.SMHD = void 0, v.STSD = void 0, v.FTYP = void 0, v.DINF = void 0; let Gi = 9e4; function os(e, t, r = 1, i = !1) { e = e * t * r; return i ? Math.round(e) : e } function ca(e, t, r = 1, i = !1) { return os(e, t, 1 / r, i) } function Gt(e, t = !1) { return os(e, 1e3, 1 / Gi, t) } function ha(e, t = 1) { return os(e, Gi, 1 / t) } let da = 1e4, Gs = 1024, ua = 1152, te = null, Re = null; class Ie { constructor(e, t, r, i = 0) { this.observer = void 0, this.config = void 0, this.typeSupported = void 0, this.ISGenerated = !1, this._initPTS = null, this._initDTS = null, this.nextAvcDts = null, this.nextAudioPts = null, this.videoSampleDuration = null, this.isAudioContiguous = !1, this.isVideoContiguous = !1, this.observer = e, this.config = t, this.typeSupported = r, this.ISGenerated = !1, null === te && (e = (navigator.userAgent || "").match(/Chrome\/(\d+)/i), te = e ? parseInt(e[1]) : 0), null === Re && (t = navigator.userAgent.match(/Safari\/(\d+)/i), Re = t ? parseInt(t[1]) : 0) } destroy() { } resetTimeStamp(e) { E.log("[mp4-remuxer]: initPTS & initDTS reset"), this._initPTS = this._initDTS = e } resetNextTimestamp() { E.log("[mp4-remuxer]: reset next timestamp"), this.isVideoContiguous = !1, this.isAudioContiguous = !1 } resetInitSegment() { E.log("[mp4-remuxer]: ISGenerated flag reset"), this.ISGenerated = !1 } getVideoStartPts(e) { let i = !1; e = e.reduce((e, t) => { var r = t.pts - e; return r < -4294967296 ? (i = !0, ft(e, t.pts)) : 0 < r ? e : t.pts }, e[0].pts); return i && E.debug("PTS rollover detected"), e } remux(r, i, e, t, s, a, n, o) { let l, h, d, u, c, f, g = s, m = s; var p = -1 < r.pid, v = -1 < i.pid, T = i.samples.length, y = 0 < r.samples.length, L = n && 0 < T || 1 < T; if ((!p || y) && (!v || L) || this.ISGenerated || n) { this.ISGenerated || (d = this.generateIS(r, i, s, a)); p = this.isVideoContiguous; let e = -1, t; L && (e = fa(i.samples), !p) && this.config.forceKeyFrameOnDiscontinuity && (f = !0, 0 < e ? (E.warn(`[mp4-remuxer]: Dropped ${e} out of ${T} video samples due to a missing keyframe`), n = this.getVideoStartPts(i.samples), i.samples = i.samples.slice(e), i.dropped += e, m += (i.samples[0].pts - n) / i.inputTimeScale, t = m) : -1 === e && (E.warn(`[mp4-remuxer]: No keyframe found out of ${T} video samples`), f = !1)), this.ISGenerated && (y && L && (n = this.getVideoStartPts(i.samples), T = (ft(r.samples[0].pts, n) - n) / i.inputTimeScale, g += Math.max(0, T), m += Math.max(0, -T)), y ? (r.samplerate || (E.warn("[mp4-remuxer]: regenerate InitSegment as audio detected"), d = this.generateIS(r, i, s, a)), h = this.remuxAudio(r, g, this.isAudioContiguous, a, v || L || o === U.AUDIO ? m : void 0), L && (n = h ? h.endPTS - h.startPTS : 0, i.inputTimeScale || (E.warn("[mp4-remuxer]: regenerate InitSegment as video detected"), d = this.generateIS(r, i, s, a)), l = this.remuxVideo(i, m, p, n))) : L && (l = this.remuxVideo(i, m, p, 0)), l) && (l.firstKeyFrame = e, l.independent = -1 !== e, l.firstKeyFramePTS = t) } return this.ISGenerated && this._initPTS && this._initDTS && (e.samples.length && (c = Ki(e, s, this._initPTS, this._initDTS)), t.samples.length) && (u = Hi(t, s, this._initPTS)), { audio: h, video: l, initSegment: d, independent: f, text: u, id3: c } } generateIS(e, t, r, i) { var s = e.samples, a = t.samples, n = this.typeSupported, o = {}, l = this._initPTS; let h = !l || i, d = "audio/mp4", u, c, f; if (h && (u = c = 1 / 0), e.config && s.length && ("mp3" === (e.timescale = e.samplerate, e.segmentCodec) && (n.mpeg ? (d = "audio/mpeg", e.codec = "") : n.mp3 && (e.codec = "mp3")), o.audio = { id: "audio", container: d, codec: e.codec, initSegment: "mp3" === e.segmentCodec && n.mpeg ? new Uint8Array(0) : v.initSegment([e]), metadata: { channelCount: e.channelCount } }, h) && (f = e.inputTimeScale, l && f === l.timescale ? h = !1 : u = c = s[0].pts - Math.round(f * r)), t.sps && t.pps && a.length && (t.timescale = t.inputTimeScale, o.video = { id: "main", container: "video/mp4", codec: t.codec, initSegment: v.initSegment([t]), metadata: { width: t.width, height: t.height } }, h) && (f = t.inputTimeScale, l && f === l.timescale ? h = !1 : (i = this.getVideoStartPts(a), n = Math.round(f * r), c = Math.min(c, ft(a[0].dts, i) - n), u = Math.min(u, i - n))), Object.keys(o).length) return this.ISGenerated = !0, h ? (this._initPTS = { baseTime: u, timescale: f }, this._initDTS = { baseTime: c, timescale: f }) : u = f = void 0, { tracks: o, initPTS: u, timescale: f } } remuxVideo(e, t, r, i) { var s = e.inputTimeScale, a = e.samples, n = [], o = a.length, l = this._initPTS; let h = this.nextAvcDts, d = 8, u = this.videoSampleDuration, c, f, g = Number.POSITIVE_INFINITY, p = Number.NEGATIVE_INFINITY, T = !1; r && null !== h || (t = t * s, A = a[0].pts - ft(a[0].dts, a[0].pts), h = t - A); var y = l.baseTime * s / l.timescale; for (let e = 0; e < o; e++) { var S = a[e]; S.pts = ft(S.pts - y, h), S.dts = ft(S.dts - y, h), S.dts < a[0 < e ? e - 1 : e].dts && (T = !0) } T && a.sort(function (e, t) { return e.dts - t.dts || e.pts - t.pts }), c = a[0].dts; var A, t = a[a.length - 1].dts - c, R = t ? Math.round(t / (o - 1)) : u || e.inputTimeScale / 30; r && (l = (A = c - h) < -1, (t = R < A) || l) && (t ? E.warn(`AVC: ${Gt(A, !0)} ms (${A}dts) hole between fragments detected, filling it`) : E.warn(`AVC: ${Gt(-A, !0)} ms (${A}dts) overlapping between fragments detected`), !l || h >= a[0].pts) && (c = h, r = a[0].pts - A, a[0].dts = c, a[0].pts = r, E.log(`Video: First PTS/DTS adjusted: ${Gt(r, !0)}/${Gt(c, !0)}, delta: ${Gt(A, !0)} ms`)), c = Math.max(0, c); let I = 0, D = 0; for (let e = 0; e < o; e++) { var b = a[e], k = b.units, _ = k.length; let t = 0; for (let e = 0; e < _; e++)t += k[e].data.length; D += t, I += _, b.length = t, b.dts = Math.max(b.dts, c), g = Math.min(b.pts, g), p = Math.max(b.pts, p) } f = a[o - 1].dts; t = D + 4 * I + 8; let w; try { w = new Uint8Array(t) } catch (e) { return void this.observer.emit(m.ERROR, m.ERROR, { type: N.MUX_ERROR, details: L.REMUX_ALLOC_ERROR, fatal: !1, error: e, bytes: t, reason: "fail allocating video mdat " + t }) } var C = new DataView(w.buffer); C.setUint32(0, t), w.set(v.types.mdat, 4); let $ = !1, P = Number.POSITIVE_INFINITY, x = Number.POSITIVE_INFINITY, F = Number.NEGATIVE_INFINITY, O = Number.NEGATIVE_INFINITY; for (let t = 0; t < o; t++) { var M, U = a[t], K = U.units; let r = 0; for (let e = 0, t = K.length; e < t; e++) { var B = K[e], H = B.data, B = B.data.byteLength; C.setUint32(d, B), d += 4, w.set(H, d), d += B, r += 4 + B } let e; t < o - 1 ? (u = a[t + 1].dts - U.dts, e = a[t + 1].pts - U.pts) : (G = this.config, M = 0 < t ? U.dts - a[t - 1].dts : R, e = 0 < t ? U.pts - a[t - 1].pts : R, G.stretchShortVideoTrack && null !== this.nextAudioPts && Math.floor(G.maxBufferHole * s) < (G = (i ? g + i * s : this.nextAudioPts) - U.pts) ? ((u = G - M) < 0 ? u = M : $ = !0, E.log(`[mp4-remuxer]: It is approximately ${G / 90} ms to the next segment; using duration ${u / 90} ms for the last video frame.`)) : u = M); var G = Math.round(U.pts - U.dts); P = Math.min(P, u), F = Math.max(F, u), x = Math.min(x, e), O = Math.max(O, e), n.push(new Ks(U.key, u, r, G)) } if (n.length) if (te) te < 70 && ((l = n[0].flags).dependsOn = 2, l.isNonSync = 0); else if (Re && O - x < F - P && R / F < .025 && 0 === n[0].cts) { E.warn("Found irregular gaps in sample duration. Using PTS instead of DTS to determine MP4 sample duration."); let r = c; for (let e = 0, t = n.length; e < t; e++) { var V, Y = r + n[e].duration, W = r + n[e].cts; e < t - 1 ? (V = Y + n[e + 1].cts, n[e].duration = V - W) : n[e].duration = e ? n[e - 1].duration : R, n[e].cts = 0, r = Y } } u = $ || !u ? R : u, this.nextAvcDts = h = f + u, this.videoSampleDuration = u, this.isVideoContiguous = !0; r = { data1: v.moof(e.sequenceNumber++, c, tt({}, e, { samples: n })), data2: w, startPTS: g / s, endPTS: (p + u) / s, startDTS: c / s, endDTS: h / s, type: "video", hasAudio: !1, hasVideo: !0, nb: n.length, dropped: e.dropped }; return e.samples = [], e.dropped = 0, r } remuxAudio(s, e, r, t, i) { var a = s.inputTimeScale, n = a / (s.samplerate || a), o = "aac" === s.segmentCodec ? Gs : ua, l = o * n, h = this._initPTS, d = "mp3" === s.segmentCodec && this.typeSupported.mpeg, u = [], c = void 0 !== i; let f = s.samples, g = d ? 0 : 8, p = this.nextAudioPts || -1, T = e * a, y = h.baseTime * a / h.timescale; if (this.isAudioContiguous = r = r || f.length && 0 < p && (t && Math.abs(T - p) < 9e3 || Math.abs(ft(f[0].pts - y, T) - p) < 20 * l), f.forEach(function (e) { e.pts = ft(e.pts - y, T) }), !r || p < 0) { if (!(f = f.filter(e => 0 <= e.pts)).length) return; p = 0 === i ? 0 : t && !c ? Math.max(0, T) : f[0].pts } if ("aac" === s.segmentCodec) { var S = this.config.maxAudioFramesDrift; for (let r = 0, i = p; r < f.length; r++) { var A = f[r], R = A.pts, I = R - i, D = Math.abs(1e3 * I / a); if (I <= -S * l && c) 0 === r && (E.warn(`Audio frame @ ${(R / a).toFixed(3)}s overlaps nextAudioPts by ${Math.round(1e3 * I / a)} ms.`), this.nextAudioPts = p = i = R); else if (S * l <= I && D < da && c) { let t = Math.round(I / l); (i = R - t * l) < 0 && (t--, i += l), 0 === r && (this.nextAudioPts = p = i), E.warn(`[mp4-remuxer]: Injecting ${t} audio frame @ ${(i / a).toFixed(3)}s due to ${Math.round(1e3 * I / a)} ms gap.`); for (let e = 0; e < t; e++) { var b = Math.max(i, 0); let e = $s.getSilentFrame(s.manifestCodec || s.codec, s.channelCount); e || (E.log("[mp4-remuxer]: Unable to get silent frame for given audio codec; duplicating last frame instead."), e = A.unit.subarray()), f.splice(r, 0, { unit: e, pts: b }), i += l, r++ } } A.pts = i, i += l } } let k = null, _ = null, w, C = 0, P = f.length; for (; P--;)C += f[P].unit.byteLength; for (let t = 0, e = f.length; t < e; t++) { var x = f[t], F = x.unit; let e = x.pts; if (null !== _) u[t - 1].duration = Math.round((e - _) / n); else { if (r && "aac" === s.segmentCodec && (e = p), k = e, !(0 < C)) return; C += g; try { w = new Uint8Array(C) } catch (e) { return void this.observer.emit(m.ERROR, m.ERROR, { type: N.MUX_ERROR, details: L.REMUX_ALLOC_ERROR, fatal: !1, error: e, bytes: C, reason: "fail allocating audio mdat " + C }) } d || (new DataView(w.buffer).setUint32(0, C), w.set(v.types.mdat, 4)) } w.set(F, g); x = F.byteLength; g += x, u.push(new Ks(!0, o, x, 0)), _ = e } e = u.length; if (e) return h = u[u.length - 1], this.nextAudioPts = p = _ + n * h.duration, i = d ? new Uint8Array(0) : v.moof(s.sequenceNumber++, k / n, tt({}, s, { samples: u })), s.samples = [], t = k / a, h = p / a, i = { data1: i, data2: w, startPTS: t, endPTS: h, startDTS: t, endDTS: h, type: "audio", hasAudio: !0, hasVideo: !1, nb: e }, this.isAudioContiguous = !0, i } remuxEmptyAudio(e, t, r, i) { var s = e.inputTimeScale, a = this.nextAudioPts, n = this._initDTS, n = 9e4 * n.baseTime / n.timescale, o = (null !== a ? a : i.startDTS * s) + n, a = i.endDTS * s + n, l = s / (e.samplerate || s) * Gs, h = Math.ceil((a - o) / l), d = $s.getSilentFrame(e.manifestCodec || e.codec, e.channelCount); if (E.warn("[mp4-remuxer]: remux empty Audio"), d) { var u = []; for (let e = 0; e < h; e++) { var c = o + e * l; u.push({ unit: d, pts: c, dts: c }) } return e.samples = u, this.remuxAudio(e, t, r, !1) } E.trace("[mp4-remuxer]: Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec") } } function ft(e, t) { let r; if (null !== t) for (r = t < e ? -8589934592 : 8589934592; 4294967296 < Math.abs(e - t);)e += r; return e } function fa(t) { for (let e = 0; e < t.length; e++)if (t[e].key) return e; return -1 } function Ki(t, r, i, s) { var a = t.samples.length; if (a) { var n = t.inputTimeScale; for (let e = 0; e < a; e++) { var o = t.samples[e]; o.pts = ft(o.pts - i.baseTime * n / i.timescale, r * n) / n, o.dts = ft(o.dts - s.baseTime * n / s.timescale, r * n) / n } var e = t.samples; return t.samples = [], { samples: e } } } function Hi(t, r, i) { var s = t.samples.length; if (s) { var a = t.inputTimeScale; for (let e = 0; e < s; e++) { var n = t.samples[e]; n.pts = ft(n.pts - 9e4 * i.baseTime / i.timescale, r * a) / a } t.samples.sort((e, t) => e.pts - t.pts); var e = t.samples; return t.samples = [], { samples: e } } } class Ks { constructor(e, t, r, i) { this.size = void 0, this.duration = void 0, this.cts = void 0, this.flags = void 0, this.duration = t, this.size = r, this.cts = i, this.flags = new ga(e) } } class ga { constructor(e) { this.isLeading = 0, this.isDependedOn = 0, this.hasRedundancy = 0, this.degradPrio = 0, this.dependsOn = 1, this.isNonSync = 1, this.dependsOn = e ? 2 : 1, this.isNonSync = e ? 0 : 1 } } class ma { constructor() { this.emitInitSegment = !1, this.audioCodec = void 0, this.videoCodec = void 0, this.initData = void 0, this.initPTS = null, this.initTracks = void 0, this.lastEndTime = null } destroy() { } resetTimeStamp(e) { this.initPTS = e, this.lastEndTime = null } resetNextTimestamp() { this.lastEndTime = null } resetInitSegment(e, t, r, i) { this.audioCodec = t, this.videoCodec = r, this.generateInitSegment(Fr(e, i)), this.emitInitSegment = !0 } generateInitSegment(e) { let { audioCodec: t, videoCodec: r } = this; var i, s; null != e && e.byteLength ? (i = this.initData = yi(e), t = t || Hs(i.audio, H.AUDIO), r = r || Hs(i.video, H.VIDEO), s = {}, i.audio && i.video ? s.audiovideo = { container: "video/mp4", codec: t + "," + r, initSegment: e, id: "main" } : i.audio ? s.audio = { container: "audio/mp4", codec: t, initSegment: e, id: "audio" } : i.video ? s.video = { container: "video/mp4", codec: r, initSegment: e, id: "main" } : E.warn("[passthrough-remuxer.ts]: initSegment does not contain moov or trak boxes."), this.initTracks = s) : (this.initTracks = void 0, this.initData = void 0) } remux(r, i, s, a, n, o) { let e, l, { initPTS: h, lastEndTime: d } = this; var u = { audio: void 0, video: void 0, text: a, id3: s, initSegment: void 0 }, i = (F(d) || (d = this.lastEndTime = n || 0), i.samples); if (null != i && i.length) { var c = { initPTS: void 0, timescale: 1 }; let t = this.initData; if (null != (e = t) && e.length || (this.generateInitSegment(i), t = this.initData), null != (l = t) && l.length) { this.emitInitSegment && (c.tracks = this.initTracks, this.emitInitSegment = !1); var f = Mr(i, t), g = Or(t, i), g = null === g ? n : g, o = ((pa(h, g, n, f) || c.timescale !== h.timescale && o) && (c.initPTS = g - n, h && 1 === h.timescale && E.warn("Adjusting initPTS by " + (c.initPTS - h.baseTime)), this.initPTS = h = { baseTime: c.initPTS, timescale: 1 }), r ? g - h.baseTime / h.timescale : d), r = o + f, g = (Ur(t, i, h.baseTime / h.timescale), 0 < f ? this.lastEndTime = r : (E.warn("Duration parsed from mp4 should be greater than zero"), this.resetNextTimestamp()), !!t.audio), f = !!t.video; let e = ""; g && (e += "audio"), f && (e += "video"); i = { data1: i, startPTS: o, startDTS: o, endPTS: r, endDTS: r, type: e, hasAudio: g, hasVideo: f, nb: 1, dropped: 0 }; u.audio = "audio" === i.type ? i : void 0, u.video = "audio" !== i.type ? i : void 0, u.initSegment = c, u.id3 = Ki(s, n, h, h), a.samples.length && (u.text = Hi(a, n, h)) } else E.warn("[passthrough-remuxer.ts]: Failed to generate initSegment.") } return u } } function pa(e, t, r, i) { return null === e || (i = Math.max(i, 1), t = t - e.baseTime / e.timescale, Math.abs(t - r) > i) } function Hs(e, t) { e = null == e ? void 0 : e.codec; return e && 4 < e.length ? e : "hvc1" === e || "hev1" === e ? "hvc1.1.6.L120.90" : "av01" === e ? "av01.0.04M.08" : "avc1" === e || t === H.VIDEO ? "avc1.42e01e" : "mp4a.40.5" } let Lt; try { Lt = self.performance.now.bind(self.performance) } catch { E.debug("Unable to use Performance API on this environment"), Lt = typeof self < "u" && self.Date.now } let be = [{ demux: Jn, remux: ma }, { demux: bt, remux: Ie }, { demux: zn, remux: Ie }, { demux: la, remux: Ie }]; class Vs { constructor(e, t, r, i, s) { this.async = !1, this.observer = void 0, this.typeSupported = void 0, this.config = void 0, this.vendor = void 0, this.id = void 0, this.demuxer = void 0, this.remuxer = void 0, this.decrypter = void 0, this.probe = void 0, this.decryptionPromise = null, this.transmuxConfig = void 0, this.currentTransmuxState = void 0, this.observer = e, this.typeSupported = t, this.config = r, this.vendor = i, this.id = s } configure(e) { this.transmuxConfig = e, this.decrypter && this.decrypter.reset() } push(e, t, r, i) { var s = r.transmuxing; s.executeStart = Lt(); let a = new Uint8Array(e); var { currentTransmuxState: e, transmuxConfig: n } = this, { contiguous: i, discontinuity: e, trackSwitch: o, accurateTimeOffset: l, timeOffset: h, initSegmentChange: d } = (i && (this.currentTransmuxState = i), i || e), { audioCodec: n, videoCodec: u, defaultInitPts: c, duration: f, initSegmentData: g } = n, p = Ta(a, t); if (p && "AES-128" === p.method) { var v = this.getDecrypter(); if (!v.isSync()) return this.decryptionPromise = v.webCryptoDecrypt(a, p.key.buffer, p.iv.buffer).then(e => { e = this.push(e, null, r); return this.decryptionPromise = null, e }), this.decryptionPromise; { let e = v.softwareDecrypt(a, p.key.buffer, p.iv.buffer); if (!(e = -1 < r.part ? v.flush() : e)) return s.executeEnd = Lt(), De(r); a = new Uint8Array(e) } } v = this.needsProbing(e, o); if (v) { var T = this.configureTransmuxer(a); if (T) return E.warn("[transmuxer] " + T.message), this.observer.emit(m.ERROR, m.ERROR, { type: N.MEDIA_ERROR, details: L.FRAG_PARSING_ERROR, fatal: !1, error: T, reason: T.message }), s.executeEnd = Lt(), De(r) } (e || o || d || v) && this.resetInitSegment(g, n, u, f, t), (e || d || v) && this.resetInitialTimestamp(c), i || this.resetContiguity(); T = this.transmux(a, p, h, l, r), o = this.currentTransmuxState; return o.contiguous = !0, o.discontinuity = !1, o.trackSwitch = !1, s.executeEnd = Lt(), T } flush(t) { var e = t.transmuxing, { decrypter: r, currentTransmuxState: i, decryptionPromise: s } = (e.executeStart = Lt(), this); if (s) return s.then(() => this.flush(t)); let a = [], n = i.timeOffset; r && (s = r.flush()) && a.push(this.push(s, null, t)); var { demuxer: i, remuxer: r } = this; return i && r ? re(s = i.flush(n)) ? s.then(e => (this.flushRemux(a, e, t), a)) : (this.flushRemux(a, s, t), a) : (e.executeEnd = Lt(), [De(t)]) } flushRemux(e, t, r) { var { audioTrack: t, videoTrack: i, id3Track: s, textTrack: a } = t, { accurateTimeOffset: n, timeOffset: o } = this.currentTransmuxState, t = (E.log(`[transmuxer.ts]: Flushed fragment ${r.sn}${-1 < r.part ? " p: " + r.part : ""} of level ` + r.level), this.remuxer.remux(t, i, s, a, o, n, !0, this.id)); e.push({ remuxResult: t, chunkMeta: r }), r.transmuxing.executeEnd = Lt() } resetInitialTimestamp(e) { var { demuxer: t, remuxer: r } = this; t && r && (t.resetTimeStamp(e), r.resetTimeStamp(e)) } resetContiguity() { var { demuxer: e, remuxer: t } = this; e && t && (e.resetContiguity(), t.resetNextTimestamp()) } resetInitSegment(e, t, r, i, s) { var { demuxer: a, remuxer: n } = this; a && n && (a.resetInitSegment(e, t, r, i), n.resetInitSegment(e, t, r, s)) } destroy() { this.demuxer && (this.demuxer.destroy(), this.demuxer = void 0), this.remuxer && (this.remuxer.destroy(), this.remuxer = void 0) } transmux(e, t, r, i, s) { let a; return a = t && "SAMPLE-AES" === t.method ? this.transmuxSampleAes(e, t, r, i, s) : this.transmuxUnencrypted(e, r, i, s) } transmuxUnencrypted(e, t, r, i) { var { audioTrack: e, videoTrack: s, id3Track: a, textTrack: n } = this.demuxer.demux(e, t, !1, !this.config.progressive); return { remuxResult: this.remuxer.remux(e, s, a, n, t, r, !1, this.id), chunkMeta: i } } transmuxSampleAes(e, t, r, i, s) { return this.demuxer.demuxSampleAes(e, t, r).then(e => ({ remuxResult: this.remuxer.remux(e.audioTrack, e.videoTrack, e.id3Track, e.textTrack, r, i, !1, this.id), chunkMeta: s })) } configureTransmuxer(r) { var { config: e, observer: t, typeSupported: i, vendor: s } = this; let a; for (let e = 0, t = be.length; e < t; e++)if (be[e].demux.probe(r)) { a = be[e]; break } if (!a) return new Error("Failed to find demuxer by probing fragment data"); var n = this.demuxer, o = this.remuxer, l = a.remux, h = a.demux; o && o instanceof l || (this.remuxer = new l(t, e, i, s)), n && n instanceof h || (this.demuxer = new h(t, e, i), this.probe = h.probe) } needsProbing(e, t) { return !this.demuxer || !this.remuxer || e || t } getDecrypter() { let e = this.decrypter; return e = e || (this.decrypter = new is(this.config)) } } function Ta(e, t) { let r = null; return r = 0 < e.byteLength && null != t && null != t.key && null !== t.iv && null != t.method ? t : r } let De = e => ({ remuxResult: {}, chunkMeta: e }); function re(e) { return "then" in e && e.then instanceof Function } class ya { constructor(e, t, r, i, s) { this.audioCodec = void 0, this.videoCodec = void 0, this.initSegmentData = void 0, this.duration = void 0, this.defaultInitPts = void 0, this.audioCodec = e, this.videoCodec = t, this.initSegmentData = r, this.duration = i, this.defaultInitPts = s || null } } class Ea { constructor(e, t, r, i, s, a) { this.discontinuity = void 0, this.contiguous = void 0, this.accurateTimeOffset = void 0, this.trackSwitch = void 0, this.timeOffset = void 0, this.initSegmentChange = void 0, this.discontinuity = e, this.contiguous = t, this.accurateTimeOffset = r, this.trackSwitch = i, this.timeOffset = s, this.initSegmentChange = a } } var Vi = { exports: {} }, xa = ((e => { var i = Object.prototype.hasOwnProperty, f = "~"; function r() { } function a(e, t, r) { this.fn = e, this.context = t, this.once = r || !1 } function s(e, t, r, i, s) { if ("function" != typeof r) throw new TypeError("The listener must be a function"); r = new a(r, i || e, s), i = f ? f + t : t; return e._events[i] ? e._events[i].fn ? e._events[i] = [e._events[i], r] : e._events[i].push(r) : (e._events[i] = r, e._eventsCount++), e } function l(e, t) { 0 == --e._eventsCount ? e._events = new r : delete e._events[t] } function t() { this._events = new r, this._eventsCount = 0 } Object.create && (r.prototype = Object.create(null), (new r).__proto__ || (f = !1)), t.prototype.eventNames = function () { var e, t, r = []; if (0 === this._eventsCount) return r; for (t in e = this._events) i.call(e, t) && r.push(f ? t.slice(1) : t); return Object.getOwnPropertySymbols ? r.concat(Object.getOwnPropertySymbols(e)) : r }, t.prototype.listeners = function (e) { var e = f ? f + e : e, t = this._events[e]; if (!t) return []; if (t.fn) return [t.fn]; for (var r = 0, i = t.length, s = new Array(i); r < i; r++)s[r] = t[r].fn; return s }, t.prototype.listenerCount = function (e) { e = f ? f + e : e, e = this._events[e]; return e ? e.fn ? 1 : e.length : 0 }, t.prototype.emit = function (e, t, r, i, s, a) { var n = f ? f + e : e; if (!this._events[n]) return !1; var o, l = this._events[n], h = arguments.length; if (l.fn) { switch (l.once && this.removeListener(e, l.fn, void 0, !0), h) { case 1: return l.fn.call(l.context), !0; case 2: return l.fn.call(l.context, t), !0; case 3: return l.fn.call(l.context, t, r), !0; case 4: return l.fn.call(l.context, t, r, i), !0; case 5: return l.fn.call(l.context, t, r, i, s), !0; case 6: return l.fn.call(l.context, t, r, i, s, a), !0 }for (c = 1, o = new Array(h - 1); c < h; c++)o[c - 1] = arguments[c]; l.fn.apply(l.context, o) } else for (var d, u = l.length, c = 0; c < u; c++)switch (l[c].once && this.removeListener(e, l[c].fn, void 0, !0), h) { case 1: l[c].fn.call(l[c].context); break; case 2: l[c].fn.call(l[c].context, t); break; case 3: l[c].fn.call(l[c].context, t, r); break; case 4: l[c].fn.call(l[c].context, t, r, i); break; default: if (!o) for (d = 1, o = new Array(h - 1); d < h; d++)o[d - 1] = arguments[d]; l[c].fn.apply(l[c].context, o) }return !0 }, t.prototype.on = function (e, t, r) { return s(this, e, t, r, !1) }, t.prototype.once = function (e, t, r) { return s(this, e, t, r, !0) }, t.prototype.removeListener = function (e, t, r, i) { e = f ? f + e : e; if (this._events[e]) if (t) { var s = this._events[e]; if (s.fn) s.fn !== t || i && !s.once || r && s.context !== r || l(this, e); else { for (var a = 0, n = [], o = s.length; a < o; a++)(s[a].fn !== t || i && !s[a].once || r && s[a].context !== r) && n.push(s[a]); n.length ? this._events[e] = 1 === n.length ? n[0] : n : l(this, e) } } else l(this, e); return this }, t.prototype.removeAllListeners = function (e) { return e ? (e = f ? f + e : e, this._events[e] && l(this, e)) : (this._events = new r, this._eventsCount = 0), this }, t.prototype.off = t.prototype.removeListener, t.prototype.addListener = t.prototype.on, t.prefixed = f, e.exports = t.EventEmitter = t })(Vi), Vi.exports), ls = rr(xa); let Ce = fe() || { isTypeSupported: () => !1 }; class Wi {
    constructor(e, t, r, i) { this.error = null, this.hls = void 0, this.id = void 0, this.observer = void 0, this.frag = null, this.part = null, this.useWorker = void 0, this.workerContext = null, this.onwmsg = void 0, this.transmuxer = null, this.onTransmuxComplete = void 0, this.onFlush = void 0; let s = e.config; this.hls = e, this.id = t, this.useWorker = !!s.enableWorker, this.onTransmuxComplete = r, this.onFlush = i; e = (e, t) => { (t = t || {}).frag = this.frag, t.id = this.id, e === m.ERROR && (this.error = t.error), this.hls.trigger(e, t) }, this.observer = new ls, this.observer.on(m.FRAG_DECRYPTED, e), this.observer.on(m.ERROR, e), r = { mp4: Ce.isTypeSupported("video/mp4"), mpeg: Ce.isTypeSupported("audio/mpeg"), mp3: Ce.isTypeSupported('audio/mp4; codecs="mp3"') }, i = navigator.vendor; if (this.useWorker && typeof Worker < "u" && (s.workerPath || Gn())) try { s.workerPath ? (E.log(`loading Web Worker ${s.workerPath} for "${t}"`), this.workerContext = Hn(s.workerPath)) : (E.log(`injecting Web Worker for "${t}"`), this.workerContext = Kn()), this.onwmsg = e => this.onWorkerMessage(e); var a = this.workerContext.worker; a.addEventListener("message", this.onwmsg), a.onerror = e => { e = new Error(e.message + `  (${e.filename}:${e.lineno})`); s.enableWorker = !1, E.warn(`Error in "${t}" Web Worker, fallback to inline`), this.hls.trigger(m.ERROR, { type: N.OTHER_ERROR, details: L.INTERNAL_EXCEPTION, fatal: !1, event: "demuxerWorker", error: e }) }, a.postMessage({ cmd: "init", typeSupported: r, vendor: i, id: t, config: JSON.stringify(s) }) } catch (e) { E.warn(`Error setting up "${t}" Web Worker, fallback to inline`, e), this.resetWorker(), this.error = null, this.transmuxer = new Vs(this.observer, r, s, i, t) } else this.transmuxer = new Vs(this.observer, r, s, i, t) } resetWorker() { var e, t; this.workerContext && ({ worker: e, objectURL: t } = this.workerContext, t && self.URL.revokeObjectURL(t), e.removeEventListener("message", this.onwmsg), e.onerror = null, e.terminate(), this.workerContext = null) } destroy() { this.workerContext ? (this.resetWorker(), this.onwmsg = void 0) : (e = this.transmuxer) && (e.destroy(), this.transmuxer = null); var e = this.observer; e && e.removeAllListeners(), this.frag = null, this.observer = null, this.hls = null } push(e, t, r, i, s, a, n, o, l, h) {
        var d = (l.transmuxing.start = self.performance.now(), this).transmuxer, u = (a || s).start, c = s.decryptdata, f = this.frag, g = !(f && s.cc === f.cc), m = !(f && l.level === f.level), p = f ? l.sn - f.sn : -1, v = this.part ? l.part - this.part.index : -1, T = 0 == p && 1 < l.id && l.id === (null == f ? void 0 : f.stats.chunkCount), T = !m && (1 == p || 0 == p && (1 == v || T && v <= 0)), y = self.performance.now(), y = ((m || p || 0 === s.stats.parsing.start) && (s.stats.parsing.start = y), !a || !v && T || (a.stats.parsing.start = y), !(f && (null == (p = s.initSegment) ? void 0 : p.url) === (null == (v = f.initSegment) ? void 0 : v.url))), p = new Ea(g, T, o, m, u, y); T && !g && !y || (E.log(`[transmuxer-interface, ${s.type}]: Starting new transmux session for sn: ${l.sn} p: ${l.part} level: ${l.level} id: ${l.id}
        discontinuity: ${g}
        trackSwitch: ${m}
        contiguous: ${T}
        accurateTimeOffset: ${o}
        timeOffset: ${u}
        initSegmentChange: `+ y), f = new ya(r, i, t, n, h), this.configureTransmuxer(f)), this.frag = s, this.part = a, this.workerContext ? this.workerContext.worker.postMessage({ cmd: "demux", data: e, decryptdata: c, chunkMeta: l, state: p }, e instanceof ArrayBuffer ? [e] : []) : d && (re(v = d.push(e, c, l, p)) ? (d.async = !0, v.then(e => { this.handleTransmuxComplete(e) }).catch(e => { this.transmuxerError(e, l, "transmuxer-interface push error") })) : (d.async = !1, this.handleTransmuxComplete(v)))
    } flush(t) { t.transmuxing.start = self.performance.now(); var r = this.transmuxer; if (this.workerContext) this.workerContext.worker.postMessage({ cmd: "flush", chunkMeta: t }); else if (r) { let e = r.flush(t); re(e) || r.async ? (e = re(e) ? e : Promise.resolve(e)).then(e => { this.handleFlushResult(e, t) }).catch(e => { this.transmuxerError(e, t, "transmuxer-interface flush error") }) : this.handleFlushResult(e, t) } } transmuxerError(e, t, r) { this.hls && (this.error = e, this.hls.trigger(m.ERROR, { type: N.MEDIA_ERROR, details: L.FRAG_PARSING_ERROR, chunkMeta: t, fatal: !1, error: e, err: e, reason: r })) } handleFlushResult(e, t) { e.forEach(e => { this.handleTransmuxComplete(e) }), this.onFlush(t) } onWorkerMessage(e) { var t = e.data, r = this.hls; switch (t.event) { case "init": var i = null == (i = this.workerContext) ? void 0 : i.objectURL; i && self.URL.revokeObjectURL(i); break; case "transmuxComplete": this.handleTransmuxComplete(t.data); break; case "flush": this.onFlush(t.data); break; case "workerLog": E[t.data.logType] && E[t.data.logType](t.data.message); break; default: t.data = t.data || {}, t.data.frag = this.frag, t.data.id = this.id, r.trigger(t.event, t.data) } } configureTransmuxer(e) { var t = this.transmuxer; this.workerContext ? this.workerContext.worker.postMessage({ cmd: "configure", config: e }) : t && t.configure(e) } handleTransmuxComplete(e) { e.chunkMeta.transmuxing.end = self.performance.now(), this.onTransmuxComplete(e) }
} let Sa = 250, ke = 2, va = .1, Aa = .05; class La { constructor(e, t, r, i) { this.config = void 0, this.media = null, this.fragmentTracker = void 0, this.hls = void 0, this.nudgeRetry = 0, this.stallReported = !1, this.stalled = null, this.moved = !1, this.seeking = !1, this.config = e, this.media = t, this.fragmentTracker = r, this.hls = i } destroy() { this.media = null, this.hls = this.fragmentTracker = null } poll(e, t) { var { config: r, media: i, stalled: s } = this; if (null !== i) { var { currentTime: a, seeking: n } = i, o = this.seeking && !n, l = !this.seeking && n; if (this.seeking = n, a !== e) this.moved = !0, null !== s && (this.stallReported && (e = self.performance.now() - s, E.warn(`playback not stuck anymore @${a}, after ${Math.round(e)}ms`), this.stallReported = !1), this.stalled = null, this.nudgeRetry = 0); else if (l || o) this.stalled = null; else if (!(i.paused && !n || i.ended || 0 === i.playbackRate) && q.getBuffered(i).length) { e = q.bufferInfo(i, a, 0), l = 0 < e.len, o = e.nextStart || 0; if (l || o) { if (n) { l = e.len > ke, t = !o || t && t.start <= a || o - a > ke && !this.fragmentTracker.getPartialFragment(a); if (l || t) return; this.moved = !1 } if (!this.moved && null !== this.stalled) { l = Math.max(o, e.start || 0) - a, t = this.hls.levels ? this.hls.levels[this.hls.currentLevel] : null, o = null != t && null != (o = t.details) && o.live ? 2 * t.details.targetduration : ke, t = this.fragmentTracker.getPartialFragment(a); if (0 < l && (l <= o || t)) return void this._trySkipBufferHole(t) } l = self.performance.now(); null === s ? this.stalled = l : (o = l - s, !n && o >= Sa && (this._reportStall(e), !this.media) || (t = q.bufferInfo(i, a, r.maxBufferHole), this._tryFixBufferStall(t, o))) } } } } _tryFixBufferStall(e, t) { var { config: r, fragmentTracker: i, media: s } = this; null !== s && (s = s.currentTime, !(i = i.getPartialFragment(s)) || !this._trySkipBufferHole(i) && this.media) && (e.len > r.maxBufferHole || e.nextStart && e.nextStart - s < r.maxBufferHole) && t > 1e3 * r.highBufferWatchdogPeriod && (E.warn("Trying to nudge playhead over buffer-hole"), this.stalled = null, this._tryNudgeBuffer()) } _reportStall(e) { var { hls: t, media: r, stallReported: i } = this; !i && r && (this.stallReported = !0, i = new Error(`Playback stalling at @${r.currentTime} due to low buffer (${JSON.stringify(e)})`), E.warn(i.message), t.trigger(m.ERROR, { type: N.MEDIA_ERROR, details: L.BUFFER_STALLED_ERROR, fatal: !1, error: i, buffer: e.len })) } _trySkipBufferHole(t) { var { config: e, hls: r, media: i } = this; if (null !== i) { var s = i.currentTime, a = q.bufferInfo(i, s, 0), n = s < a.start ? a.start : a.nextStart; if (n) { var o = a.len <= e.maxBufferHole, a = 0 < a.len && a.len < 1 && i.readyState < 3, l = n - s; if (0 < l && (o || a)) { if (l > e.maxBufferHole) { var h = this.fragmentTracker; let e = !1; if (!(e = 0 === s && (o = h.getAppendedFrag(0, U.MAIN)) && n < o.end ? !0 : e)) { a = t || h.getAppendedFrag(s, U.MAIN); if (a) { let e = !1, t = a.end; for (; t < n;) { var d = h.getPartialFragment(t); if (!d) { e = !0; break } t += d.duration } if (e) return 0 } } } l = Math.max(n + Aa, s + va); return E.warn(`skipping hole, adjusting currentTime from ${s} to ` + l), this.moved = !0, this.stalled = null, i.currentTime = l, t && !t.gap && (e = new Error(`fragment loaded with buffer holes, seeking from ${s} to ` + l), r.trigger(m.ERROR, { type: N.MEDIA_ERROR, details: L.BUFFER_SEEK_OVER_HOLE, fatal: !1, error: e, reason: e.message, frag: t })), l } } } return 0 } _tryNudgeBuffer() { var e, t, { config: r, hls: i, media: s, nudgeRetry: a } = this; null !== s && (e = s.currentTime, this.nudgeRetry++, a < r.nudgeMaxRetry ? (a = e + (a + 1) * r.nudgeOffset, t = new Error(`Nudging 'currentTime' from ${e} to ` + a), E.warn(t.message), s.currentTime = a, i.trigger(m.ERROR, { type: N.MEDIA_ERROR, details: L.BUFFER_NUDGE_ON_STALL, error: t, fatal: !1 })) : (s = new Error(`Playhead still not moving while enough data buffered @${e} after ${r.nudgeMaxRetry} nudges`), E.error(s.message), i.trigger(m.ERROR, { type: N.MEDIA_ERROR, details: L.BUFFER_STALLED_ERROR, error: s, fatal: !0 }))) } } let Ra = 100; class Ia extends rs { constructor(e, t, r) { super(e, t, r, "[stream-controller]", U.MAIN), this.audioCodecSwap = !1, this.gapController = null, this.level = -1, this._forceStartLoad = !1, this.altAudio = !1, this.audioOnly = !1, this.fragPlaying = null, this.onvplaying = null, this.onvseeked = null, this.fragLastKbps = 0, this.couldBacktrack = !1, this.backtrackFragment = null, this.audioCodecSwitch = !1, this.videoBuffer = null, this._registerListeners() } _registerListeners() { var e = this.hls; e.on(m.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(m.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(m.MANIFEST_LOADING, this.onManifestLoading, this), e.on(m.MANIFEST_PARSED, this.onManifestParsed, this), e.on(m.LEVEL_LOADING, this.onLevelLoading, this), e.on(m.LEVEL_LOADED, this.onLevelLoaded, this), e.on(m.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this), e.on(m.ERROR, this.onError, this), e.on(m.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.on(m.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), e.on(m.BUFFER_CREATED, this.onBufferCreated, this), e.on(m.BUFFER_FLUSHED, this.onBufferFlushed, this), e.on(m.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(m.FRAG_BUFFERED, this.onFragBuffered, this) } _unregisterListeners() { var e = this.hls; e.off(m.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(m.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(m.MANIFEST_LOADING, this.onManifestLoading, this), e.off(m.MANIFEST_PARSED, this.onManifestParsed, this), e.off(m.LEVEL_LOADED, this.onLevelLoaded, this), e.off(m.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this), e.off(m.ERROR, this.onError, this), e.off(m.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.off(m.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), e.off(m.BUFFER_CREATED, this.onBufferCreated, this), e.off(m.BUFFER_FLUSHED, this.onBufferFlushed, this), e.off(m.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(m.FRAG_BUFFERED, this.onFragBuffered, this) } onHandlerDestroying() { this._unregisterListeners(), this.onMediaDetaching() } startLoad(e) { if (this.levels) { var { lastCurrentTime: t, hls: r } = this; if (this.stopLoad(), this.setInterval(Ra), this.level = -1, !this.startFragRequested) { let e = r.startLevel; -1 === e && (r.config.testBandwidth && 1 < this.levels.length ? (e = 0, this.bitrateTest = !0) : e = r.nextAutoLevel), this.level = r.nextLoadLevel = e, this.loadedmetadata = !1 } 0 < t && -1 === e && (this.log("Override startPosition with lastCurrentTime @" + t.toFixed(3)), e = t), this.state = b.IDLE, this.nextLoadPosition = this.startPosition = this.lastCurrentTime = e, this.tick() } else this._forceStartLoad = !0, this.state = b.STOPPED } stopLoad() { this._forceStartLoad = !1, super.stopLoad() } doTick() { switch (this.state) { case b.WAITING_LEVEL: var { levels: e, level: t } = this, t = null == e || null == (e = e[t]) ? void 0 : e.details; !t || t.live && this.levelLastLoaded !== this.level || this.waitForCdnTuneIn(t) || (this.state = b.IDLE); break; case b.FRAG_LOADING_WAITING_RETRY: e = self.performance.now(), t = this.retryDate; (!t || t <= e || null != (t = this.media) && t.seeking) && (this.resetStartWhenNotLoaded(this.level), this.state = b.IDLE) }this.state === b.IDLE && this.doTickIdle(), this.onTickEnd() } onTickEnd() { super.onTickEnd(), this.checkBuffer(), this.checkFragmentChanged() } doTickIdle() { var { hls: t, levelLastLoaded: r, levels: i, media: s } = this, { config: a, nextLoadLevel: n } = t; if (!(null === r || !s && (this.startFragRequested || !a.startFragPrefetch) || this.altAudio && this.audioOnly || null == i) && i[n]) { r = i[n], s = this.getMainFwdBufferInfo(); if (null !== s) { a = this.getLevelDetails(); if (a && this._streamEnded(s, a)) i = {}, this.altAudio && (i.type = "video"), this.hls.trigger(m.BUFFER_EOS, i), this.state = b.ENDED; else { t.loadLevel !== n && -1 === t.manualLevel && this.log(`Adapting to level ${n} from level ` + this.level), this.level = t.nextLoadLevel = n; a = r.details; if (!a || this.state === b.WAITING_LEVEL || a.live && this.levelLastLoaded !== n) this.level = n, this.state = b.WAITING_LEVEL; else { i = s.len, t = this.getMaxBufferLength(r.maxBitrate); if (!(t <= i)) { this.backtrackFragment && this.backtrackFragment.start > s.end && (this.backtrackFragment = null); var o, n = this.backtrackFragment ? this.backtrackFragment.start : s.end; let e = this.getNextFragment(n, a); this.couldBacktrack && !this.fragPrevious && e && "initSegment" !== e.sn && this.fragmentTracker.getState(e) !== st.OK ? (i = (null != (i = this.backtrackFragment) ? i : e).sn - a.startSN, (i = a.fragments[i - 1]) && e.cc === i.cc && (e = i, this.fragmentTracker.removeFragment(i))) : this.backtrackFragment && s.len && (this.backtrackFragment = null), e && this.isLoopLoading(e, n) && (e.gap || (o = ((i = this.audioOnly && !this.altAudio ? H.AUDIO : H.VIDEO) === H.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media) && this.afterBufferFlushed(o, i, U.MAIN), e = this.getNextFragmentLoopLoading(e, a, s, U.MAIN, t)), e && (!e.initSegment || e.initSegment.data || this.bitrateTest || (e = e.initSegment), this.loadFragment(e, r, n)) } } } } } } loadFragment(e, t, r) { var i = this.fragmentTracker.getState(e); this.fragCurrent = e, i === st.NOT_LOADED || i === st.PARTIAL ? "initSegment" === e.sn ? this._loadInitSegment(e, t) : this.bitrateTest ? (this.log(`Fragment ${e.sn} of level ${e.level} is being downloaded to test bitrate and will not be buffered`), this._loadBitrateTestFrag(e, t)) : (this.startFragRequested = !0, super.loadFragment(e, t, r)) : this.clearTrackerIfNeeded(e) } getBufferedFrag(e) { return this.fragmentTracker.getBufferedFrag(e, U.MAIN) } followingBufferedFrag(e) { return e ? this.getBufferedFrag(e.end + .5) : null } immediateLevelSwitch() { this.abortCurrentFrag(), this.flushMainBuffer(0, Number.POSITIVE_INFINITY) } nextLevelSwitch() { var { levels: t, media: r } = this; if (null != r && r.readyState) { let e; var i = this.getAppendedFrag(r.currentTime), i = (i && 1 < i.start && this.flushMainBuffer(0, i.start - 1), this.getLevelDetails()); if (null != i && i.live) { var s = this.getMainFwdBufferInfo(); if (!s || s.len < 2 * i.targetduration) return } e = !r.paused && t && (s = t[this.hls.nextLoadLevel], i = this.fragLastKbps) && this.fragCurrent ? this.fragCurrent.duration * s.maxBitrate / (1e3 * i) + 1 : 0; t = this.getBufferedFrag(r.currentTime + e); t && (s = this.followingBufferedFrag(t)) && (this.abortCurrentFrag(), i = s.maxStartPTS || s.start, r = s.duration, s = Math.max(t.end, i + Math.min(Math.max(r - this.config.maxFragLookUpTolerance, .5 * r), .75 * r)), this.flushMainBuffer(s, Number.POSITIVE_INFINITY)) } } abortCurrentFrag() { var e = this.fragCurrent; switch (this.fragCurrent = null, this.backtrackFragment = null, e && (e.abortRequests(), this.fragmentTracker.removeFragment(e)), this.state) { case b.KEY_LOADING: case b.FRAG_LOADING: case b.FRAG_LOADING_WAITING_RETRY: case b.PARSING: case b.PARSED: this.state = b.IDLE }this.nextLoadPosition = this.getLoadPosition() } flushMainBuffer(e, t) { super.flushMainBuffer(e, t, this.altAudio ? "video" : null) } onMediaAttached(e, t) { super.onMediaAttached(e, t); e = t.media; this.onvplaying = this.onMediaPlaying.bind(this), this.onvseeked = this.onMediaSeeked.bind(this), e.addEventListener("playing", this.onvplaying), e.addEventListener("seeked", this.onvseeked), this.gapController = new La(this.config, e, this.fragmentTracker, this.hls) } onMediaDetaching() { var e = this.media; e && this.onvplaying && this.onvseeked && (e.removeEventListener("playing", this.onvplaying), e.removeEventListener("seeked", this.onvseeked), this.onvplaying = this.onvseeked = null, this.videoBuffer = null), this.fragPlaying = null, this.gapController && (this.gapController.destroy(), this.gapController = null), super.onMediaDetaching() } onMediaPlaying() { this.tick() } onMediaSeeked() { var e = this.media, e = e ? e.currentTime : null, e = (F(e) && this.log("Media seeked to " + e.toFixed(3)), this.getMainFwdBufferInfo()); null === e || 0 === e.len ? this.warn(`Main forward buffer length on "seeked" event ${e ? e.len : "empty"})`) : this.tick() } onManifestLoading() { this.log("Trigger BUFFER_RESET"), this.hls.trigger(m.BUFFER_RESET, void 0), this.fragmentTracker.removeAllFragments(), this.couldBacktrack = !1, this.startPosition = this.lastCurrentTime = 0, this.levels = this.fragPlaying = this.backtrackFragment = null, this.altAudio = this.audioOnly = !1 } onManifestParsed(e, t) { let r = !1, i = !1, s; t.levels.forEach(e => { (s = e.audioCodec) && (-1 !== s.indexOf("mp4a.40.2") && (r = !0), -1 !== s.indexOf("mp4a.40.5")) && (i = !0) }), this.audioCodecSwitch = r && i && !$n(), this.audioCodecSwitch && this.log("Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC"), this.levels = t.levels, this.startFragRequested = !1 } onLevelLoading(e, t) { var r = this.levels; r && this.state === b.IDLE && (!(r = r[t.level]).details || r.details.live && this.levelLastLoaded !== t.level || this.waitForCdnTuneIn(r.details)) && (this.state = b.WAITING_LEVEL) } onLevelLoaded(e, t) { var r = this.levels, i = t.level, s = t.details, a = s.totalduration; if (r) { this.log(`Level ${i} loaded [${s.startSN},${s.endSN}]${s.lastPartSn ? `[part-${s.lastPartSn}-${s.lastPartIndex}]` : ""}, cc [${s.startCC}, ${s.endCC}] duration:` + a); a = r[i], r = this.fragCurrent; !r || this.state !== b.FRAG_LOADING && this.state !== b.FRAG_LOADING_WAITING_RETRY || r.level === t.level && r.urlId === a.urlId || !r.loader || this.abortCurrentFrag(); let e = 0; if (s.live || null != (t = a.details) && t.live) { if (s.fragments[0] || (s.deltaUpdateFailed = !0), s.deltaUpdateFailed) return; e = this.alignPlaylists(s, a.details) } if (a.details = s, this.levelLastLoaded = i, this.hls.trigger(m.LEVEL_UPDATED, { details: s, level: i }), this.state === b.WAITING_LEVEL) { if (this.waitForCdnTuneIn(s)) return; this.state = b.IDLE } this.startFragRequested ? s.live && this.synchronizeToLiveEdge(s) : this.setStartPosition(s, e), this.tick() } else this.warn("Levels were reset while loading level " + i) } _handleFragmentLoadProgress(e) { var t, r, i, s, a, n, o, { frag: e, part: l, payload: h } = e, d = this.levels; d ? (t = (d = d[e.level]).details) ? (r = d.videoCodec, i = t.PTSKnown || !t.live, s = null == (s = e.initSegment) ? void 0 : s.data, d = this._getAudioCodec(d), a = this.transmuxer = this.transmuxer || new Wi(this.hls, U.MAIN, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this)), o = -1 !== (n = l ? l.index : -1), n = new es(e.level, e.sn, e.stats.chunkCount, h.byteLength, n, o), o = this.initPTS[e.cc], a.push(h, s, d, r, e, l, t.totalduration, i, n, o)) : (this.warn(`Dropping fragment ${e.sn} of level ${e.level} after level details were reset`), this.fragmentTracker.removeFragment(e)) : this.warn(`Levels were reset while fragment load was in progress. Fragment ${e.sn} of level ${e.level} will not be buffered`) } onAudioTrackSwitching(e, t) { var r, i = this.altAudio; t.url || (this.mediaBuffer !== this.media ? (this.log("Switching on main audio, use media.buffered to schedule main fragment loading"), this.mediaBuffer = this.media, (r = this.fragCurrent) && (this.log("Switching to main audio track, cancel main fragment load"), r.abortRequests(), this.fragmentTracker.removeFragment(r)), this.resetTransmuxer(), this.resetLoadingState()) : this.audioOnly && this.resetTransmuxer(), r = this.hls, i && (r.trigger(m.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: null }), this.fragmentTracker.removeAllFragments()), r.trigger(m.AUDIO_TRACK_SWITCHED, t)) } onAudioTrackSwitched(e, t) { var r, t = t.id, t = !!this.hls.audioTracks[t].url; t && (r = this.videoBuffer) && this.mediaBuffer !== r && (this.log("Switching on alternate audio, use video.buffered to schedule main fragment loading"), this.mediaBuffer = r), this.altAudio = t, this.tick() } onBufferCreated(e, t) { var r, i = t.tracks; let s, a, n = !1; for (r in i) { var o = i[r]; "main" === o.id ? (a = r, s = o, "video" === r && (o = i[r]) && (this.videoBuffer = o.buffer)) : n = !0 } n && s ? (this.log(`Alternate track found, use ${a}.buffered to schedule main fragment loading`), this.mediaBuffer = s.buffer) : this.mediaBuffer = this.media } onFragBuffered(e, t) { var r, { frag: t, part: i } = t; t && t.type !== U.MAIN || (this.fragContextChanged(t) ? (this.warn(`Fragment ${t.sn}${i ? " p: " + i.index : ""} of level ${t.level} finished buffering, but was aborted. state: ` + this.state), this.state === b.PARSED && (this.state = b.IDLE)) : (r = (i || t).stats, this.fragLastKbps = Math.round(8 * r.total / (r.buffering.end - r.loading.first)), "initSegment" !== t.sn && (this.fragPrevious = t), this.fragBufferedComplete(t, i))) } onError(e, t) { var r; if (t.fatal) this.state = b.ERROR; else switch (t.details) { case L.FRAG_GAP: case L.FRAG_PARSING_ERROR: case L.FRAG_DECRYPT_ERROR: case L.FRAG_LOAD_ERROR: case L.FRAG_LOAD_TIMEOUT: case L.KEY_LOAD_ERROR: case L.KEY_LOAD_TIMEOUT: this.onFragmentOrKeyLoadError(U.MAIN, t); break; case L.LEVEL_LOAD_ERROR: case L.LEVEL_LOAD_TIMEOUT: case L.LEVEL_PARSING_ERROR: t.levelRetry || this.state !== b.WAITING_LEVEL || (null == (r = t.context) ? void 0 : r.type) !== G.LEVEL || (this.state = b.IDLE); break; case L.BUFFER_FULL_ERROR: t.parent && "main" === t.parent && this.reduceLengthAndFlushBuffer(t) && this.flushMainBuffer(0, Number.POSITIVE_INFINITY); break; case L.INTERNAL_EXCEPTION: this.recoverWorkerError(t) } } checkBuffer() { var e, { media: t, gapController: r } = this; t && r && t.readyState && (!this.loadedmetadata && q.getBuffered(t).length || (e = this.state !== b.IDLE ? this.fragCurrent : null, r.poll(this.lastCurrentTime, e)), this.lastCurrentTime = t.currentTime) } onFragLoadEmergencyAborted() { this.state = b.IDLE, this.loadedmetadata || (this.startFragRequested = !1, this.nextLoadPosition = this.startPosition), this.tickImmediate() } onBufferFlushed(e, { type: t }) { var r; (t !== H.AUDIO || this.audioOnly && !this.altAudio) && (r = (t === H.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media, this.afterBufferFlushed(r, t, U.MAIN)) } onLevelsUpdated(e, t) { this.levels = t.levels } swapAudioCodec() { this.audioCodecSwap = !this.audioCodecSwap } seekToStartPos() { var t = this.media; if (t) { var r, i = t.currentTime; let e = this.startPosition; 0 <= e && i < e && (t.seeking ? this.log(`could not seek to ${e}, already seeking at ` + i) : (0 < (r = ((r = q.getBuffered(t)).length ? r.start(0) : 0) - e) && (r < this.config.maxBufferHole || r < this.config.maxFragLookUpTolerance) && (this.log(`adjusting start position by ${r} to match buffer start`), e += r, this.startPosition = e), this.log(`seek to target start position ${e} from current time ` + i), t.currentTime = e)) } } _getAudioCodec(e) { let t = this.config.defaultAudioCodec || e.audioCodec; return this.audioCodecSwap && t && (this.log("Swapping audio codec"), t = -1 !== t.indexOf("mp4a.40.5") ? "mp4a.40.2" : "mp4a.40.5"), t } _loadBitrateTestFrag(i, s) { i.bitrateTest = !0, this._doFragLoad(i, s).then(e => { var t, r = this.hls; e && !this.fragContextChanged(i) && (s.fragmentError = 0, this.state = b.IDLE, this.startFragRequested = !1, this.bitrateTest = !1, (t = i.stats).parsing.start = t.parsing.end = t.buffering.start = t.buffering.end = self.performance.now(), r.trigger(m.FRAG_LOADED, e), i.bitrateTest = !1) }) } _handleTransmuxComplete(e) { var t = "main", r = this.hls, { remuxResult: e, chunkMeta: i } = e, s = this.getCurrentContext(i); if (s) { var { frag: s, part: a, level: n } = s, { video: o, text: l, id3: h, initSegment: d } = e, u = n.details, c = this.altAudio ? void 0 : e.audio; if (this.fragContextChanged(s)) this.fragmentTracker.removeFragment(s); else { if (this.state = b.PARSING, d && (null != d && d.tracks && (f = s.initSegment || s, this._bufferInitSegment(n, d.tracks, f, i), r.trigger(m.FRAG_PARSING_INIT_SEGMENT, { frag: f, id: t, tracks: d.tracks })), n = d.initPTS, f = d.timescale, F(n)) && (this.initPTS[s.cc] = { baseTime: n, timescale: f }, r.trigger(m.INIT_PTS_FOUND, { frag: s, id: t, initPTS: n, timescale: f })), o && !1 !== e.independent) { if (u) { var { startPTS: d, endPTS: n, startDTS: f, endDTS: g } = o; if (a) a.elementaryStreams[o.type] = { startPTS: d, endPTS: n, startDTS: f, endDTS: g }; else if (o.firstKeyFrame && o.independent && 1 === i.id && (this.couldBacktrack = !0), o.dropped && o.independent) { var p = this.getMainFwdBufferInfo(); if ((p ? p.end : this.getLoadPosition()) + this.config.maxBufferHole < (o.firstKeyFramePTS || d) - this.config.maxBufferHole) return void this.backtrack(s); s.setElementaryStreamInfo(o.type, s.start, n, s.start, g, !0) } s.setElementaryStreamInfo(o.type, d, n, f, g), this.backtrackFragment && (this.backtrackFragment = s), this.bufferFragmentData(o, s, a, i) } } else if (!1 === e.independent) return void this.backtrack(s); c && ({ startPTS: p, endPTS: d, startDTS: n, endDTS: f } = c, a && (a.elementaryStreams[H.AUDIO] = { startPTS: p, endPTS: d, startDTS: n, endDTS: f }), s.setElementaryStreamInfo(H.AUDIO, p, d, n, f), this.bufferFragmentData(c, s, a, i)), u && null != h && null != (g = h.samples) && g.length && (o = { id: t, frag: s, details: u, samples: h.samples }, r.trigger(m.FRAG_PARSING_METADATA, o)), u && l && (e = { id: t, frag: s, details: u, samples: l.samples }, r.trigger(m.FRAG_PARSING_USERDATA, e)) } } else this.resetWhenMissingContext(i) } _bufferInitSegment(t, r, i, s) { if (this.state === b.PARSING) { this.audioOnly = !!r.audio && !r.video, this.altAudio && !this.audioOnly && delete r.audio; var { audio: a, video: e, audiovideo: n } = r; if (a) { let e = t.audioCodec; var o = navigator.userAgent.toLowerCase(); this.audioCodecSwitch && (e = e && (-1 !== e.indexOf("mp4a.40.5") ? "mp4a.40.2" : "mp4a.40.5"), 1 !== a.metadata.channelCount) && -1 === o.indexOf("firefox") && (e = "mp4a.40.5"), -1 !== o.indexOf("android") && "audio/mpeg" !== a.container && (e = "mp4a.40.2", this.log("Android: force audio codec to " + e)), t.audioCodec && t.audioCodec !== e && this.log(`Swapping manifest audio codec "${t.audioCodec}" for "${e}"`), a.levelCodec = e, a.id = "main", this.log(`Init audio buffer, container:${a.container}, codecs[selected/level/parsed]=[${e || ""}/${t.audioCodec || ""}/${a.codec}]`) } e && (e.levelCodec = t.videoCodec, e.id = "main", this.log(`Init video buffer, container:${e.container}, codecs[level/parsed]=[${t.videoCodec || ""}/${e.codec}]`)), n && this.log(`Init audiovideo buffer, container:${n.container}, codecs[level/parsed]=[${t.attrs.CODECS || ""}/${n.codec}]`), this.hls.trigger(m.BUFFER_CODECS, r), Object.keys(r).forEach(e => { var t = r[e].initSegment; null != t && t.byteLength && this.hls.trigger(m.BUFFER_APPENDING, { type: e, data: t, frag: i, part: null, chunkMeta: s, parent: i.type }) }), this.tick() } } getMainFwdBufferInfo() { return this.getFwdBufferInfo(this.mediaBuffer || this.media, U.MAIN) } backtrack(e) { this.couldBacktrack = !0, this.backtrackFragment = e, this.resetTransmuxer(), this.flushBufferGap(e), this.fragmentTracker.removeFragment(e), this.fragPrevious = null, this.nextLoadPosition = e.start, this.state = b.IDLE } checkFragmentChanged() { var e, t = this.media; let r = null; t && 1 < t.readyState && !1 === t.seeking && (e = t.currentTime, q.isBuffered(t, e) ? r = this.getAppendedFrag(e) : q.isBuffered(t, e + .1) && (r = this.getAppendedFrag(e + .1)), r) && (this.backtrackFragment = null, t = this.fragPlaying, e = r.level, t && r.sn === t.sn && t.level === e && r.urlId === t.urlId || (this.fragPlaying = r, this.hls.trigger(m.FRAG_CHANGED, { frag: r }), t && t.level === e) || this.hls.trigger(m.LEVEL_SWITCHED, { level: e })) } get nextLevel() { var e = this.nextBufferedFrag; return e ? e.level : -1 } get currentFrag() { var e = this.media; return e ? this.fragPlaying || this.getAppendedFrag(e.currentTime) : null } get currentProgramDateTime() { var e = this.media; if (e) { var e = e.currentTime, t = this.currentFrag; if (t && F(e) && F(t.programDateTime)) return e = t.programDateTime + 1e3 * (e - t.start), new Date(e) } return null } get currentLevel() { var e = this.currentFrag; return e ? e.level : -1 } get nextBufferedFrag() { var e = this.currentFrag; return e ? this.followingBufferedFrag(e) : null } get forceStartLoad() { return this._forceStartLoad } } class Mt { constructor(e, t = 0, r = 0) { this.halfLife = void 0, this.alpha_ = void 0, this.estimate_ = void 0, this.totalWeight_ = void 0, this.halfLife = e, this.alpha_ = e ? Math.exp(Math.log(.5) / e) : 0, this.estimate_ = t, this.totalWeight_ = r } sample(e, t) { var r = Math.pow(this.alpha_, e); this.estimate_ = t * (1 - r) + r * this.estimate_, this.totalWeight_ += e } getTotalWeight() { return this.totalWeight_ } getEstimate() { if (this.alpha_) { var e = 1 - Math.pow(this.alpha_, this.totalWeight_); if (e) return this.estimate_ / e } return this.estimate_ } } class ba { constructor(e, t, r, i = 100) { this.defaultEstimate_ = void 0, this.minWeight_ = void 0, this.minDelayMs_ = void 0, this.slow_ = void 0, this.fast_ = void 0, this.defaultTTFB_ = void 0, this.ttfb_ = void 0, this.defaultEstimate_ = r, this.minWeight_ = .001, this.minDelayMs_ = 50, this.slow_ = new Mt(e), this.fast_ = new Mt(t), this.defaultTTFB_ = i, this.ttfb_ = new Mt(e) } update(e, t) { var { slow_: r, fast_: i, ttfb_: s } = this; r.halfLife !== e && (this.slow_ = new Mt(e, r.getEstimate(), r.getTotalWeight())), i.halfLife !== t && (this.fast_ = new Mt(t, i.getEstimate(), i.getTotalWeight())), s.halfLife !== e && (this.ttfb_ = new Mt(e, s.getEstimate(), s.getTotalWeight())) } sample(e, t) { e = (e = Math.max(e, this.minDelayMs_)) / 1e3, t = 8 * t / e; this.fast_.sample(e, t), this.slow_.sample(e, t) } sampleTTFB(e) { var t = e / 1e3, t = Math.sqrt(2) * Math.exp(-Math.pow(t, 2) / 2); this.ttfb_.sample(t, Math.max(e, 5)) } canEstimate() { return this.fast_.getTotalWeight() >= this.minWeight_ } getEstimate() { return this.canEstimate() ? Math.min(this.fast_.getEstimate(), this.slow_.getEstimate()) : this.defaultEstimate_ } getEstimateTTFB() { return this.ttfb_.getTotalWeight() >= this.minWeight_ ? this.ttfb_.getEstimate() : this.defaultTTFB_ } destroy() { } } class Da {
    constructor(e) { this.hls = void 0, this.lastLevelLoadSec = 0, this.lastLoadedFragLevel = 0, this._nextAutoLevel = -1, this.timer = -1, this.onCheck = this._abandonRulesCheck.bind(this), this.fragCurrent = null, this.partCurrent = null, this.bitrateTestDelay = 0, this.bwEstimator = void 0; e = (this.hls = e).config; this.bwEstimator = new ba(e.abrEwmaSlowVoD, e.abrEwmaFastVoD, e.abrEwmaDefaultEstimate), this.registerListeners() } registerListeners() { var e = this.hls; e.on(m.FRAG_LOADING, this.onFragLoading, this), e.on(m.FRAG_LOADED, this.onFragLoaded, this), e.on(m.FRAG_BUFFERED, this.onFragBuffered, this), e.on(m.LEVEL_SWITCHING, this.onLevelSwitching, this), e.on(m.LEVEL_LOADED, this.onLevelLoaded, this) } unregisterListeners() { var e = this.hls; e.off(m.FRAG_LOADING, this.onFragLoading, this), e.off(m.FRAG_LOADED, this.onFragLoaded, this), e.off(m.FRAG_BUFFERED, this.onFragBuffered, this), e.off(m.LEVEL_SWITCHING, this.onLevelSwitching, this), e.off(m.LEVEL_LOADED, this.onLevelLoaded, this) } destroy() { this.unregisterListeners(), this.clearTimer(), this.hls = this.onCheck = null, this.fragCurrent = this.partCurrent = null } onFragLoading(e, t) { var r = t.frag; this.ignoreFragment(r) || (this.fragCurrent = r, this.partCurrent = null != (r = t.part) ? r : null, this.clearTimer(), this.timer = self.setInterval(this.onCheck, 100)) } onLevelSwitching(e, t) { this.clearTimer() } getTimeToLoadFrag(e, t, r, i) { return e + r / t + (i ? this.lastLevelLoadSec : 0) } onLevelLoaded(e, t) { var r = this.hls.config, { total: i, bwEstimate: s } = t.stats; F(i) && F(s) && (this.lastLevelLoadSec = 8 * i / s), t.details.live ? this.bwEstimator.update(r.abrEwmaSlowLive, r.abrEwmaFastLive) : this.bwEstimator.update(r.abrEwmaSlowVoD, r.abrEwmaFastVoD) } _abandonRulesCheck() {
        var { fragCurrent: r, partCurrent: i, hls: s } = this, { autoLevelEnabled: a, media: n } = s; if (r && n) {
            var o = performance.now(), l = (i || r).stats, h = (i || r).duration, o = o - l.loading.start; if (l.aborted || l.loaded && l.loaded === l.total || 0 === r.level) this.clearTimer(), this._nextAutoLevel = -1; else if (a && !n.paused && n.playbackRate && n.readyState) {
                a = s.mainForwardBufferInfo; if (null !== a) {
                    var d = this.bwEstimator.getEstimateTTFB(), n = Math.abs(n.playbackRate); if (!(o <= Math.max(d, h / (2 * n) * 1e3))) {
                        var u = a.len / n; if (!(2 * h / n <= u)) {
                            var a = l.loading.first ? l.loading.first - l.loading.start : -1, n = l.loaded && -1 < a, c = this.bwEstimator.getEstimate(), { levels: f, minAutoLevel: g } = s, p = f[r.level], p = l.total || Math.max(l.loaded, Math.round(h * p.maxBitrate / 8)); let e = o - a; e < 1 && n && (e = Math.min(o, 8 * l.loaded / c)); var v = n ? 1e3 * l.loaded / e : 0, p = v ? (p - l.loaded) / v : 8 * p / c + d / 1e3; if (!(p <= u)) {
                                var T = v ? 8 * v : c; let e = Number.POSITIVE_INFINITY, t; for (t = r.level - 1; t > g; t--) { var y = f[t].maxBitrate; if ((e = this.getTimeToLoadFrag(d / 1e3, T, h * y, !f[t].details)) < u) break } e >= p || e > 10 * h || (s.nextLoadLevel = t, n ? this.bwEstimator.sample(o - Math.min(d, a), l.loaded) : this.bwEstimator.sampleTTFB(o), this.clearTimer(), E.warn(`[abr] Fragment ${r.sn}${i ? " part " + i.index : ""} of level ${r.level} is loading too slowly;
      Time to underbuffer: ${u.toFixed(3)} s
      Estimated load time for current fragment: ${p.toFixed(3)} s
      Estimated load time for down switch fragment: ${e.toFixed(3)} s
      TTFB estimate: ${a}
      Current BW estimate: ${F(c) ? (c / 1024).toFixed(3) : "Unknown"} Kb/s
      New BW estimate: ${(this.bwEstimator.getEstimate() / 1024).toFixed(3)} Kb/s
      Aborting and switching to level `+ t), r.loader && (this.fragCurrent = this.partCurrent = null, r.abortRequests()), s.trigger(m.FRAG_LOAD_EMERGENCY_ABORTED, { frag: r, part: i, stats: l }))
                            }
                        }
                    }
                }
            }
        }
    } onFragLoaded(e, { frag: t, part: r }) { var i, s, a, n = (r || t).stats; t.type === U.MAIN && this.bwEstimator.sampleTTFB(n.loading.first - n.loading.start), this.ignoreFragment(t) || (this.clearTimer(), this.lastLoadedFragLevel = t.level, this._nextAutoLevel = -1, this.hls.config.abrMaxWithRealBitrate && (s = (r || t).duration, i = ((a = this.hls.levels[t.level]).loaded ? a.loaded.bytes : 0) + n.loaded, s = (a.loaded ? a.loaded.duration : 0) + s, a.loaded = { bytes: i, duration: s }, a.realBitrate = Math.round(8 * i / s)), t.bitrateTest && (a = { stats: n, frag: t, part: r, id: t.type }, this.onFragBuffered(m.FRAG_BUFFERED, a), t.bitrateTest = !1)) } onFragBuffered(e, t) { var r, { frag: t, part: i } = t, i = (null != i && i.stats.loaded ? i : t).stats; i.aborted || this.ignoreFragment(t) || (r = i.parsing.end - i.loading.start - Math.min(i.loading.first - i.loading.start, this.bwEstimator.getEstimateTTFB()), this.bwEstimator.sample(r, i.loaded), i.bwEstimate = this.bwEstimator.getEstimate(), t.bitrateTest ? this.bitrateTestDelay = r / 1e3 : this.bitrateTestDelay = 0) } ignoreFragment(e) { return e.type !== U.MAIN || "initSegment" === e.sn } clearTimer() { self.clearInterval(this.timer) } get nextAutoLevel() { var e = this._nextAutoLevel, t = this.bwEstimator; if (-1 !== e && !t.canEstimate()) return e; let r = this.getNextABRAutoLevel(); if (-1 !== e) { t = this.hls.levels; if (t.length > Math.max(e, r) && t[e].loadError <= t[r].loadError) return e } return r = -1 !== e ? Math.min(e, r) : r } getNextABRAutoLevel() { var e, { fragCurrent: t, partCurrent: r, hls: i } = this, { maxAutoLevel: s, config: a, minAutoLevel: n, media: o } = i, r = r ? r.duration : t ? t.duration : 0, t = o && 0 !== o.playbackRate ? Math.abs(o.playbackRate) : 1, o = this.bwEstimator ? this.bwEstimator.getEstimate() : a.abrEwmaDefaultEstimate, i = i.mainForwardBufferInfo, i = (i ? i.len : 0) / t, t = this.findBestLevel(o, n, s, i, a.abrBandWidthFactor, a.abrBandWidthUpFactor); if (0 <= t) return t; E.trace(`[abr] ${i ? "rebuffering expected" : "buffer is empty"}, finding optimal quality level`); let l = r ? Math.min(r, a.maxStarvationDelay) : a.maxStarvationDelay, h = a.abrBandWidthFactor, d = a.abrBandWidthUpFactor; return i || (e = this.bitrateTestDelay) && (l = (r ? Math.min(r, a.maxLoadingDelay) : a.maxLoadingDelay) - e, E.trace(`[abr] bitrate test took ${Math.round(1e3 * e)}ms, set first fragment max fetchDuration to ${Math.round(1e3 * l)} ms`), h = d = 1), t = this.findBestLevel(o, n, s, i + l, h, d), Math.max(t, 0) } findBestLevel(r, e, i, s, a, n) { var t, { fragCurrent: o, partCurrent: l, lastLoadedFragLevel: h } = this, d = this.hls.levels, u = d[h], c = !(null == u || null == (t = u.details) || !t.live), f = null == u ? void 0 : u.codecSet, g = l ? l.duration : o ? o.duration : 0, m = this.bwEstimator.getEstimateTTFB() / 1e3; let p = e, v = -1; for (let t = i; t >= e; t--) { var T = d[t]; if (!T || f && T.codecSet !== f) T && (p = Math.min(t, p), v = Math.max(t, v)); else { -1 !== v && E.trace(`[abr] Skipped level(s) ${p}-${v} with CODECS:"${d[v].attrs.CODECS}"; not compatible with "${u.attrs.CODECS}"`); var T = T.details, y = (l ? null == T ? void 0 : T.partTarget : null == T ? void 0 : T.averagetargetduration) || g; let e; e = t <= h ? a * r : n * r; var L = d[t].maxBitrate, T = this.getTimeToLoadFrag(m, e, L * y, void 0 === T); if (E.trace(`[abr] level:${t} adjustedbw-bitrate:${Math.round(e - L)} avgDuration:${y.toFixed(1)} maxFetchDuration:${s.toFixed(1)} fetchDuration:` + T.toFixed(1)), e > L && (0 === T || !F(T) || c && !this.bitrateTestDelay || T < s)) return t } } return -1 } set nextAutoLevel(e) { this._nextAutoLevel = e }
} class Yi { constructor() { this.chunks = [], this.dataLength = 0 } push(e) { this.chunks.push(e), this.dataLength += e.length } flush() { var { chunks: e, dataLength: t } = this; let r; return e.length ? (r = 1 === e.length ? e[0] : Ca(e, t), this.reset(), r) : new Uint8Array(0) } reset() { this.chunks.length = 0, this.dataLength = 0 } } function Ca(t, e) { var r = new Uint8Array(e); let i = 0; for (let e = 0; e < t.length; e++) { var s = t[e]; r.set(s, i), i += s.length } return r } let Ws = 100; class ka extends rs { constructor(e, t, r) { super(e, t, r, "[audio-stream-controller]", U.AUDIO), this.videoBuffer = null, this.videoTrackCC = -1, this.waitingVideoCC = -1, this.bufferedTrack = null, this.switchingTrack = null, this.trackId = -1, this.waitingData = null, this.mainDetails = null, this.bufferFlushed = !1, this.cachedTrackLoadedData = null, this._registerListeners() } onHandlerDestroying() { this._unregisterListeners(), this.mainDetails = null, this.bufferedTrack = null, this.switchingTrack = null } _registerListeners() { var e = this.hls; e.on(m.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(m.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(m.MANIFEST_LOADING, this.onManifestLoading, this), e.on(m.LEVEL_LOADED, this.onLevelLoaded, this), e.on(m.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this), e.on(m.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.on(m.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.on(m.ERROR, this.onError, this), e.on(m.BUFFER_RESET, this.onBufferReset, this), e.on(m.BUFFER_CREATED, this.onBufferCreated, this), e.on(m.BUFFER_FLUSHED, this.onBufferFlushed, this), e.on(m.INIT_PTS_FOUND, this.onInitPtsFound, this), e.on(m.FRAG_BUFFERED, this.onFragBuffered, this) } _unregisterListeners() { var e = this.hls; e.off(m.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(m.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(m.MANIFEST_LOADING, this.onManifestLoading, this), e.off(m.LEVEL_LOADED, this.onLevelLoaded, this), e.off(m.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this), e.off(m.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.off(m.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.off(m.ERROR, this.onError, this), e.off(m.BUFFER_RESET, this.onBufferReset, this), e.off(m.BUFFER_CREATED, this.onBufferCreated, this), e.off(m.BUFFER_FLUSHED, this.onBufferFlushed, this), e.off(m.INIT_PTS_FOUND, this.onInitPtsFound, this), e.off(m.FRAG_BUFFERED, this.onFragBuffered, this) } onInitPtsFound(e, { frag: t, id: r, initPTS: i, timescale: s }) { "main" === r && (r = t.cc, this.initPTS[t.cc] = { baseTime: i, timescale: s }, this.log(`InitPTS for cc: ${r} found from main: ` + i), this.videoTrackCC = r, this.state === b.WAITING_INIT_PTS) && this.tick() } startLoad(e) { var t; this.levels ? (t = this.lastCurrentTime, this.stopLoad(), this.setInterval(Ws), 0 < t && -1 === e ? (this.log("Override startPosition with lastCurrentTime @" + t.toFixed(3)), e = t, this.state = b.IDLE) : (this.loadedmetadata = !1, this.state = b.WAITING_TRACK), this.nextLoadPosition = this.startPosition = this.lastCurrentTime = e, this.tick()) : (this.startPosition = e, this.state = b.STOPPED) } doTick() { switch (this.state) { case b.IDLE: this.doTickIdle(); break; case b.WAITING_TRACK: var { levels: e, trackId: t } = this, t = null == e || null == (e = e[t]) ? void 0 : e.details; if (t) { if (this.waitForCdnTuneIn(t)) break; this.state = b.WAITING_INIT_PTS } break; case b.FRAG_LOADING_WAITING_RETRY: e = performance.now(), t = this.retryDate; (!t || t <= e || null != (t = this.media) && t.seeking) && (this.log("RetryDate reached, switch back to IDLE state"), this.resetStartWhenNotLoaded(this.trackId), this.state = b.IDLE); break; case b.WAITING_INIT_PTS: var r, i, e = this.waitingData; e ? ({ frag: t, part: e, cache: r, complete: i } = e, void 0 !== this.initPTS[t.cc] ? (this.waitingData = null, this.waitingVideoCC = -1, this.state = b.FRAG_LOADING, e = { frag: t, part: e, payload: r.flush(), networkDetails: null }, this._handleFragmentLoadProgress(e), i && super._handleFragmentLoadComplete(e)) : this.videoTrackCC !== this.waitingVideoCC ? (this.log(`Waiting fragment cc (${t.cc}) cancelled because video is at cc ` + this.videoTrackCC), this.clearWaitingFragment()) : (r = this.getLoadPosition(), We((i = q.bufferInfo(this.mediaBuffer, r, this.config.maxBufferHole)).end, this.config.maxFragLookUpTolerance, t) < 0 && (this.log(`Waiting fragment cc (${t.cc}) @ ${t.start} cancelled because another fragment at ${i.end} is needed`), this.clearWaitingFragment()))) : this.state = b.IDLE }this.onTickEnd() } clearWaitingFragment() { var e = this.waitingData; e && (this.fragmentTracker.removeFragment(e.frag), this.waitingData = null, this.waitingVideoCC = -1, this.state = b.IDLE) } resetLoadingState() { this.clearWaitingFragment(), super.resetLoadingState() } onTickEnd() { var e = this.media; null != e && e.readyState && (this.lastCurrentTime = e.currentTime) } doTickIdle() { var { hls: i, levels: s, media: a, trackId: n } = this, o = i.config; if (null != s && s[n] && (a || !this.startFragRequested && o.startFragPrefetch)) { o = s[n], s = o.details; if (!s || s.live && this.levelLastLoaded !== n || this.waitForCdnTuneIn(s)) this.state = b.WAITING_TRACK; else { n = this.mediaBuffer || this.media, n = (this.bufferFlushed && n && (this.bufferFlushed = !1, this.afterBufferFlushed(n, H.AUDIO, U.AUDIO)), this.getFwdBufferInfo(n, U.AUDIO)); if (null !== n) { var { bufferedTrack: l, switchingTrack: h } = this; if (!h && this._streamEnded(n, s)) i.trigger(m.BUFFER_EOS, { type: "audio" }), this.state = b.ENDED; else { var i = this.getFwdBufferInfo(this.videoBuffer || this.media, U.MAIN), d = n.len, u = this.getMaxBufferLength(null == i ? void 0 : i.len); if (!(u <= d) || h) { var c, d = s.fragments[0].start; let e = n.end, t = (h && a && (c = this.getLoadPosition(), l && h.attrs !== l.attrs && (e = c), s.PTSKnown) && c < d && (n.end > d || n.nextStart) && (this.log("Alt audio track ahead of main track, seek to start of alt audio track"), a.currentTime = d + .05), this.getNextFragment(e, s)), r = !1; if (t && this.isLoopLoading(t, e) && (r = !!t.gap, t = this.getNextFragmentLoopLoading(t, s, n, U.MAIN, u)), t) { h = i && t.start > i.end + s.targetduration; if (h || (null == i || !i.len) && n.len) { l = this.getAppendedFrag(t.start, U.MAIN); if (null === l || (r = r || !!l.gap || !!h && 0 === i.len, h && !r) || r && n.nextStart && n.nextStart < l.end) return } this.loadFragment(t, o, e) } else this.bufferFlushed = !0 } } } } } } getMaxBufferLength(e) { var t = super.getMaxBufferLength(); return e ? Math.min(Math.max(t, e), this.config.maxMaxBufferLength) : t } onMediaDetaching() { this.videoBuffer = null, super.onMediaDetaching() } onAudioTracksUpdated(e, { audioTracks: t }) { this.resetTransmuxer(), this.levels = t.map(e => new Yt(e)) } onAudioTrackSwitching(e, t) { var r = !!t.url, i = (this.trackId = t.id, this).fragCurrent; i && (i.abortRequests(), this.removeUnbufferedFrags(i.start)), this.resetLoadingState(), r ? this.setInterval(Ws) : this.resetTransmuxer(), r ? (this.switchingTrack = t, this.state = b.IDLE) : (this.switchingTrack = null, this.bufferedTrack = t, this.state = b.STOPPED), this.tick() } onManifestLoading() { this.fragmentTracker.removeAllFragments(), this.startPosition = this.lastCurrentTime = 0, this.bufferFlushed = !1, this.levels = this.mainDetails = this.waitingData = this.bufferedTrack = this.cachedTrackLoadedData = this.switchingTrack = null, this.startFragRequested = !1, this.trackId = this.videoTrackCC = this.waitingVideoCC = -1 } onLevelLoaded(e, t) { this.mainDetails = t.details, null !== this.cachedTrackLoadedData && (this.hls.trigger(m.AUDIO_TRACK_LOADED, this.cachedTrackLoadedData), this.cachedTrackLoadedData = null) } onAudioTrackLoaded(e, t) { if (null == this.mainDetails) this.cachedTrackLoadedData = t; else { var r = this.levels, { details: t, id: i } = t; if (r) { this.log(`Track ${i} loaded [${t.startSN},${t.endSN}]${t.lastPartSn ? `[part-${t.lastPartSn}-${t.lastPartIndex}]` : ""},duration:` + t.totalduration); r = r[i]; let e = 0; if (t.live || null != (s = r.details) && s.live) { var s = this.mainDetails; if (t.fragments[0] || (t.deltaUpdateFailed = !0), t.deltaUpdateFailed || !s) return; e = !r.details && t.hasProgramDateTime && s.hasProgramDateTime ? (ki(t, s), t.fragments[0].start) : this.alignPlaylists(t, r.details) } r.details = t, this.levelLastLoaded = i, this.startFragRequested || !this.mainDetails && t.live || this.setStartPosition(r.details, e), this.state !== b.WAITING_TRACK || this.waitForCdnTuneIn(t) || (this.state = b.IDLE), this.tick() } else this.warn("Audio tracks were reset while loading level " + i) } } _handleFragmentLoadProgress(t) { var { frag: t, part: r, payload: i } = t, { config: s, trackId: a, levels: n } = this; if (n) { n = n[a]; if (n) { var o = n.details; if (o) { s = s.defaultAudioCodec || n.audioCodec || "mp4a.40.2"; let e = this.transmuxer; e = e || (this.transmuxer = new Wi(this.hls, U.AUDIO, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this))); var l, h, n = this.initPTS[t.cc], d = null == (d = t.initSegment) ? void 0 : d.data; void 0 !== n ? (h = -1 !== (l = r ? r.index : -1), l = new es(t.level, t.sn, t.stats.chunkCount, i.byteLength, l, h), e.push(i, d, s, "", t, r, o.totalduration, !1, l, n)) : (this.log(`Unknown video PTS for cc ${t.cc}, waiting for video PTS before demuxing audio frag ${t.sn} of [${o.startSN} ,${o.endSN}],track ` + a), h = (this.waitingData = this.waitingData || { frag: t, part: r, cache: new Yi, complete: !1 }).cache, h.push(new Uint8Array(i)), this.waitingVideoCC = this.videoTrackCC, this.state = b.WAITING_INIT_PTS) } else this.warn("Audio track details undefined on fragment load progress"), this.removeUnbufferedFrags(t.start) } else this.warn("Audio track is undefined on fragment load progress") } else this.warn(`Audio tracks were reset while fragment load was in progress. Fragment ${t.sn} of level ${t.level} will not be buffered`) } _handleFragmentLoadComplete(e) { this.waitingData ? this.waitingData.complete = !0 : super._handleFragmentLoadComplete(e) } onBufferReset() { this.mediaBuffer = this.videoBuffer = null, this.loadedmetadata = !1 } onBufferCreated(e, t) { var r = t.tracks.audio; r && (this.mediaBuffer = r.buffer || null), t.tracks.video && (this.videoBuffer = t.tracks.video.buffer || null) } onFragBuffered(e, t) { var r, { frag: t, part: i } = t; t.type !== U.AUDIO ? this.loadedmetadata || t.type !== U.MAIN || (r = this.videoBuffer || this.media) && q.getBuffered(r).length && (this.loadedmetadata = !0) : this.fragContextChanged(t) ? this.warn(`Fragment ${t.sn}${i ? " p: " + i.index : ""} of level ${t.level} finished buffering, but was aborted. state: ${this.state}, audioSwitch: ` + (this.switchingTrack ? this.switchingTrack.name : "false")) : ("initSegment" !== t.sn && (this.fragPrevious = t, r = this.switchingTrack) && (this.bufferedTrack = r, this.switchingTrack = null, this.hls.trigger(m.AUDIO_TRACK_SWITCHED, ct({}, r))), this.fragBufferedComplete(t, i)) } onError(e, t) { var r; if (t.fatal) this.state = b.ERROR; else switch (t.details) { case L.FRAG_GAP: case L.FRAG_PARSING_ERROR: case L.FRAG_DECRYPT_ERROR: case L.FRAG_LOAD_ERROR: case L.FRAG_LOAD_TIMEOUT: case L.KEY_LOAD_ERROR: case L.KEY_LOAD_TIMEOUT: this.onFragmentOrKeyLoadError(U.AUDIO, t); break; case L.AUDIO_TRACK_LOAD_ERROR: case L.AUDIO_TRACK_LOAD_TIMEOUT: case L.LEVEL_PARSING_ERROR: t.levelRetry || this.state !== b.WAITING_TRACK || (null == (r = t.context) ? void 0 : r.type) !== G.AUDIO_TRACK || (this.state = b.IDLE); break; case L.BUFFER_FULL_ERROR: t.parent && "audio" === t.parent && this.reduceLengthAndFlushBuffer(t) && (this.bufferedTrack = null, super.flushMainBuffer(0, Number.POSITIVE_INFINITY, "audio")); break; case L.INTERNAL_EXCEPTION: this.recoverWorkerError(t) } } onBufferFlushed(e, { type: t }) { t === H.AUDIO && (this.bufferFlushed = !0, this.state === b.ENDED) && (this.state = b.IDLE) } _handleTransmuxComplete(e) { var t, r, i, s, a, n, o, l, h = this.hls, { remuxResult: e, chunkMeta: d } = e, u = this.getCurrentContext(d); u ? ({ frag: u, part: t, level: r } = u, r = r.details, { audio: e, text: i, id3: s, initSegment: o } = e, this.fragContextChanged(u) || !r ? this.fragmentTracker.removeFragment(u) : (this.state = b.PARSING, this.switchingTrack && e && this.completeAudioSwitch(this.switchingTrack), null != o && o.tracks && (a = u.initSegment || u, this._bufferInitSegment(o.tracks, a, d), h.trigger(m.FRAG_PARSING_INIT_SEGMENT, { frag: a, id: "audio", tracks: o.tracks })), e && ({ startPTS: a, endPTS: o, startDTS: l, endDTS: n } = e, t && (t.elementaryStreams[H.AUDIO] = { startPTS: a, endPTS: o, startDTS: l, endDTS: n }), u.setElementaryStreamInfo(H.AUDIO, a, o, l, n), this.bufferFragmentData(e, u, t, d)), null != s && null != (a = s.samples) && a.length && (o = tt({ id: "audio", frag: u, details: r }, s), h.trigger(m.FRAG_PARSING_METADATA, o)), i && (l = tt({ id: "audio", frag: u, details: r }, i), h.trigger(m.FRAG_PARSING_USERDATA, l)))) : this.resetWhenMissingContext(d) } _bufferInitSegment(e, t, r) { var i; this.state === b.PARSING && (e.video && delete e.video, i = e.audio) && (i.levelCodec = i.codec, i.id = "audio", this.log(`Init audio buffer, container:${i.container}, codecs[parsed]=[${i.codec}]`), this.hls.trigger(m.BUFFER_CODECS, e), null != (e = i.initSegment) && e.byteLength && (i = { type: "audio", frag: t, part: null, chunkMeta: r, parent: t.type, data: e }, this.hls.trigger(m.BUFFER_APPENDING, i)), this.tick()) } loadFragment(e, t, r) { var i = this.fragmentTracker.getState(e); this.fragCurrent = e, this.switchingTrack || i === st.NOT_LOADED || i === st.PARTIAL ? "initSegment" === e.sn ? this._loadInitSegment(e, t) : null != (i = t.details) && i.live && !this.initPTS[e.cc] ? (this.log(`Waiting for video PTS in continuity counter ${e.cc} of live stream before loading audio fragment ${e.sn} of level ` + this.trackId), this.state = b.WAITING_INIT_PTS) : (this.startFragRequested = !0, super.loadFragment(e, t, r)) : this.clearTrackerIfNeeded(e) } completeAudioSwitch(e) { var { hls: t, media: r, bufferedTrack: i } = this, i = null == i ? void 0 : i.attrs, s = e.attrs; r && i && (i.CHANNELS !== s.CHANNELS || i.NAME !== s.NAME || i.LANGUAGE !== s.LANGUAGE) && (this.log("Switching audio track : flushing all audio"), super.flushMainBuffer(0, Number.POSITIVE_INFINITY, "audio")), this.bufferedTrack = e, this.switchingTrack = null, t.trigger(m.AUDIO_TRACK_SWITCHED, ct({}, e)) } } class _a extends ts { constructor(e) { super(e, "[audio-track-controller]"), this.tracks = [], this.groupId = null, this.tracksInGroup = [], this.trackId = -1, this.currentTrack = null, this.selectDefaultTrack = !0, this.registerListeners() } registerListeners() { var e = this.hls; e.on(m.MANIFEST_LOADING, this.onManifestLoading, this), e.on(m.MANIFEST_PARSED, this.onManifestParsed, this), e.on(m.LEVEL_LOADING, this.onLevelLoading, this), e.on(m.LEVEL_SWITCHING, this.onLevelSwitching, this), e.on(m.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.on(m.ERROR, this.onError, this) } unregisterListeners() { var e = this.hls; e.off(m.MANIFEST_LOADING, this.onManifestLoading, this), e.off(m.MANIFEST_PARSED, this.onManifestParsed, this), e.off(m.LEVEL_LOADING, this.onLevelLoading, this), e.off(m.LEVEL_SWITCHING, this.onLevelSwitching, this), e.off(m.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.off(m.ERROR, this.onError, this) } destroy() { this.unregisterListeners(), this.tracks.length = 0, this.tracksInGroup.length = 0, this.currentTrack = null, super.destroy() } onManifestLoading() { this.tracks = [], this.groupId = null, this.tracksInGroup = [], this.trackId = -1, this.currentTrack = null, this.selectDefaultTrack = !0 } onManifestParsed(e, t) { this.tracks = t.audioTracks || [] } onAudioTrackLoaded(e, t) { var r, { id: i, groupId: s, details: a } = t, n = this.tracksInGroup[i]; n && n.groupId === s ? (r = n.details, n.details = t.details, this.log(`audio-track ${i} "${n.name}" lang:${n.lang} group:${s} loaded [${a.startSN}-${a.endSN}]`), i === this.trackId && this.playlistLoaded(i, t, r)) : this.warn(`Track with id:${i} and group:${s} not found in active group ` + n.groupId) } onLevelLoading(e, t) { this.switchLevel(t.level) } onLevelSwitching(e, t) { this.switchLevel(t.level) } switchLevel(e) { var r, e = this.hls.levels[e]; if (null != e && e.audioGroupIds) { let t = e.audioGroupIds[e.urlId]; this.groupId !== t ? (this.groupId = t || null, e = this.tracks.filter(e => !t || e.groupId === t), this.selectDefaultTrack && !e.some(e => e.default) && (this.selectDefaultTrack = !1), r = { audioTracks: this.tracksInGroup = e }, this.log(`Updating audio tracks, ${e.length} track(s) found in group:` + t), this.hls.trigger(m.AUDIO_TRACKS_UPDATED, r), this.selectInitialTrack()) : this.shouldReloadPlaylist(this.currentTrack) && this.setAudioTrack(this.trackId) } } onError(e, t) { !t.fatal && t.context && t.context.type === G.AUDIO_TRACK && t.context.id === this.trackId && t.context.groupId === this.groupId && (this.requestScheduled = -1, this.checkRetry(t)) } get audioTracks() { return this.tracksInGroup } get audioTrack() { return this.trackId } set audioTrack(e) { this.selectDefaultTrack = !1, this.setAudioTrack(e) } setAudioTrack(e) { var t, r, i, s = this.tracksInGroup; e < 0 || e >= s.length ? this.warn("Invalid id passed to audio-track controller") : (this.clearTimer(), t = this.currentTrack, s[this.trackId], { groupId: r, name: i } = s = s[e], this.log(`Switching to audio-track ${e} "${i}" lang:${s.lang} group:` + r), this.trackId = e, this.currentTrack = s, this.selectDefaultTrack = !1, this.hls.trigger(m.AUDIO_TRACK_SWITCHING, ct({}, s)), s.details && !s.details.live || (i = this.switchParams(s.url, null == t ? void 0 : t.details), this.loadPlaylist(i))) } selectInitialTrack() { var e = this.tracksInGroup, t = this.findTrackId(this.currentTrack) | this.findTrackId(null); -1 != t ? this.setAudioTrack(t) : (t = new Error(`No track found for running audio group-ID: ${this.groupId} track count: ` + e.length), this.warn(t.message), this.hls.trigger(m.ERROR, { type: N.MEDIA_ERROR, details: L.AUDIO_TRACK_LOAD_ERROR, fatal: !0, error: t })) } findTrackId(t) { var r = this.tracksInGroup; for (let e = 0; e < r.length; e++) { var i = r[e]; if ((!this.selectDefaultTrack || i.default) && (!t || void 0 !== t.attrs["STABLE-RENDITION-ID"] && t.attrs["STABLE-RENDITION-ID"] === i.attrs["STABLE-RENDITION-ID"] || t.name === i.name && t.lang === i.lang)) return i.id } return -1 } loadPlaylist(t) { super.loadPlaylist(); var r = this.tracksInGroup[this.trackId]; if (this.shouldLoadPlaylist(r)) { var i = r.id, s = r.groupId; let e = r.url; if (t) try { e = t.addDirectives(e) } catch (e) { this.warn("Could not construct new URL with HLS Delivery Directives: " + e) } this.log(`loading audio-track playlist ${i} "${r.name}" lang:${r.lang} group:` + s), this.clearTimer(), this.hls.trigger(m.AUDIO_TRACK_LOADING, { url: e, id: i, groupId: s, deliveryDirectives: t || null }) } } } function qi(t, r) { if (t.length !== r.length) return !1; for (let e = 0; e < t.length; e++)if (!wa(t[e].attrs, r[e].attrs)) return !1; return !0 } function wa(t, r) { var e = t["STABLE-RENDITION-ID"]; return e ? e === r["STABLE-RENDITION-ID"] : !["LANGUAGE", "NAME", "CHARACTERISTICS", "AUTOSELECT", "DEFAULT", "FORCED"].some(e => t[e] !== r[e]) } let Ys = 500; class Pa extends rs { constructor(e, t, r) { super(e, t, r, "[subtitle-stream-controller]", U.SUBTITLE), this.levels = [], this.currentTrackId = -1, this.tracksBuffered = [], this.mainDetails = null, this._registerListeners() } onHandlerDestroying() { this._unregisterListeners(), this.mainDetails = null } _registerListeners() { var e = this.hls; e.on(m.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(m.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(m.MANIFEST_LOADING, this.onManifestLoading, this), e.on(m.LEVEL_LOADED, this.onLevelLoaded, this), e.on(m.ERROR, this.onError, this), e.on(m.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.on(m.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), e.on(m.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.on(m.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this), e.on(m.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on(m.FRAG_BUFFERED, this.onFragBuffered, this) } _unregisterListeners() { var e = this.hls; e.off(m.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(m.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(m.MANIFEST_LOADING, this.onManifestLoading, this), e.off(m.LEVEL_LOADED, this.onLevelLoaded, this), e.off(m.ERROR, this.onError, this), e.off(m.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.off(m.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), e.off(m.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.off(m.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this), e.off(m.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off(m.FRAG_BUFFERED, this.onFragBuffered, this) } startLoad(e) { this.stopLoad(), this.state = b.IDLE, this.setInterval(Ys), this.nextLoadPosition = this.startPosition = this.lastCurrentTime = e, this.tick() } onManifestLoading() { this.mainDetails = null, this.fragmentTracker.removeAllFragments() } onMediaDetaching() { this.tracksBuffered = [], super.onMediaDetaching() } onLevelLoaded(e, t) { this.mainDetails = t.details } onSubtitleFragProcessed(e, r) { var { frag: r, success: i } = r; if (this.fragPrevious = r, this.state = b.IDLE, i) { var s = this.tracksBuffered[this.currentTrackId]; if (s) { let t; var a = r.start; for (let e = 0; e < s.length; e++)if (a >= s[e].start && a <= s[e].end) { t = s[e]; break } i = r.start + r.duration; t ? t.end = i : (t = { start: a, end: i }, s.push(t)), this.fragmentTracker.fragBuffered(r) } } } onBufferFlushing(e, t) { var { startOffset: i, endOffset: s } = t; if (0 === i && s !== Number.POSITIVE_INFINITY) { var { currentTrackId: a, levels: n } = this; if (n.length && n[a] && n[a].details) { let e = n[a].details.targetduration, r = s - e; r <= 0 || (t.endOffsetSubtitles = Math.max(0, r), this.tracksBuffered.forEach(t => { for (let e = 0; e < t.length;)if (t[e].end <= r) t.shift(); else { if (!(t[e].start < r)) break; t[e].start = r, e++ } }), this.fragmentTracker.removeFragmentsInRange(i, r, U.SUBTITLE)) } } } onFragBuffered(e, t) { this.loadedmetadata || t.frag.type !== U.MAIN || null != (t = this.media) && t.buffered.length && (this.loadedmetadata = !0) } onError(e, t) { t = t.frag; (null == t ? void 0 : t.type) === U.SUBTITLE && (this.fragCurrent && this.fragCurrent.abortRequests(), this.state !== b.STOPPED) && (this.state = b.IDLE) } onSubtitleTracksUpdated(e, { subtitleTracks: t }) { qi(this.levels, t) ? this.levels = t.map(e => new Yt(e)) : (this.tracksBuffered = [], this.levels = t.map(e => { e = new Yt(e); return this.tracksBuffered[e.id] = [], e }), this.fragmentTracker.removeFragmentsInRange(0, Number.POSITIVE_INFINITY, U.SUBTITLE), this.fragPrevious = null, this.mediaBuffer = null) } onSubtitleTrackSwitch(e, t) { this.currentTrackId = t.id, this.levels.length && -1 !== this.currentTrackId ? (null != (t = this.levels[this.currentTrackId]) && t.details ? this.mediaBuffer = this.mediaBufferTimeRanges : this.mediaBuffer = null, t && this.setInterval(Ys)) : this.clearInterval() } onSubtitleTrackLoaded(e, t) { var { details: t, id: r } = t, { currentTrackId: i, levels: s } = this; if (s.length) { var a = s[i]; if (!(s.length <= r || r !== i) && a) { this.mediaBuffer = this.mediaBufferTimeRanges; let e = 0; if (t.live || null != (s = a.details) && s.live) { i = this.mainDetails; if (t.deltaUpdateFailed || !i) return; s = i.fragments[0]; a.details ? 0 === (e = this.alignPlaylists(t, a.details)) && s && Ve(t, e = s.start) : t.hasProgramDateTime && i.hasProgramDateTime ? (ki(t, i), e = t.fragments[0].start) : s && Ve(t, e = s.start) } a.details = t, this.levelLastLoaded = r, this.startFragRequested || !this.mainDetails && t.live || this.setStartPosition(a.details, e), this.tick(), !t.live || this.fragCurrent || !this.media || this.state !== b.IDLE || qt(null, t.fragments, this.media.currentTime, 0) || (this.warn("Subtitle playlist not aligned with playback"), a.details = void 0) } } } _handleFragmentLoadComplete(e) { let { frag: i, payload: t } = e, s = i.decryptdata, a = this.hls; if (!this.fragContextChanged(i) && t && 0 < t.byteLength && s && s.key && s.iv && "AES-128" === s.method) { let r = performance.now(); this.decrypter.decrypt(new Uint8Array(t), s.key.buffer, s.iv.buffer).catch(e => { throw a.trigger(m.ERROR, { type: N.MEDIA_ERROR, details: L.FRAG_DECRYPT_ERROR, fatal: !1, error: e, reason: e.message, frag: i }), e }).then(e => { var t = performance.now(); a.trigger(m.FRAG_DECRYPTED, { frag: i, payload: e, stats: { tstart: r, tdecrypt: t } }) }).catch(e => { this.warn(e.name + ": " + e.message), this.state = b.IDLE }) } } doTick() { if (this.media) { if (this.state === b.IDLE) { var { currentTrackId: t, levels: r } = this, t = r[t]; if (r.length && t && t.details) { var r = t.details, i = r.targetduration, s = this.config, a = this.getLoadPosition(), { end: a, len: n } = q.bufferedInfo(this.tracksBuffered[this.currentTrackId] || [], a - i, s.maxBufferHole), o = this.getFwdBufferInfo(this.media, U.MAIN), o = this.getMaxBufferLength(null == o ? void 0 : o.len) + i; if (!(o < n)) { i = r.fragments, o = i.length, n = r.edge; let e = null; r = this.fragPrevious; a < n ? (n = s.maxFragLookUpTolerance, !(e = qt(r, i, Math.max(i[0].start, a), n)) && r && r.start < i[0].start && (e = i[0])) : e = i[o - 1], e && (e = this.mapToInitFragWhenRequired(e), this.fragmentTracker.getState(e) === st.NOT_LOADED) && this.loadFragment(e, t, a) } } } } else this.state = b.IDLE } getMaxBufferLength(e) { var t = super.getMaxBufferLength(); return e ? Math.max(t, e) : t } loadFragment(e, t, r) { "initSegment" === (this.fragCurrent = e).sn ? this._loadInitSegment(e, t) : (this.startFragRequested = !0, super.loadFragment(e, t, r)) } get mediaBufferTimeRanges() { return new Fa(this.tracksBuffered[this.currentTrackId] || []) } } class Fa { constructor(i) { this.buffered = void 0; let t = (e, t, r) => { if (r - 1 < (t >>>= 0)) throw new DOMException(`Failed to execute '${e}' on 'TimeRanges': The index provided (${t}) is greater than the maximum bound (${r})`); return i[t][e] }; this.buffered = { get length() { return i.length }, end(e) { return t("end", e, i.length) }, start(e) { return t("start", e, i.length) } } } } class Oa extends ts { constructor(e) { super(e, "[subtitle-track-controller]"), this.media = null, this.tracks = [], this.groupId = null, this.tracksInGroup = [], this.trackId = -1, this.selectDefaultTrack = !0, this.queuedDefaultTrack = -1, this.trackChangeListener = () => this.onTextTracksChanged(), this.asyncPollTrackChange = () => this.pollTrackChange(0), this.useTextTrackPolling = !1, this.subtitlePollingInterval = -1, this._subtitleDisplay = !0, this.registerListeners() } destroy() { this.unregisterListeners(), this.tracks.length = 0, this.tracksInGroup.length = 0, this.trackChangeListener = this.asyncPollTrackChange = null, super.destroy() } get subtitleDisplay() { return this._subtitleDisplay } set subtitleDisplay(e) { this._subtitleDisplay = e, -1 < this.trackId && this.toggleTrackModes(this.trackId) } registerListeners() { var e = this.hls; e.on(m.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(m.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(m.MANIFEST_LOADING, this.onManifestLoading, this), e.on(m.MANIFEST_PARSED, this.onManifestParsed, this), e.on(m.LEVEL_LOADING, this.onLevelLoading, this), e.on(m.LEVEL_SWITCHING, this.onLevelSwitching, this), e.on(m.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.on(m.ERROR, this.onError, this) } unregisterListeners() { var e = this.hls; e.off(m.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(m.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(m.MANIFEST_LOADING, this.onManifestLoading, this), e.off(m.MANIFEST_PARSED, this.onManifestParsed, this), e.off(m.LEVEL_LOADING, this.onLevelLoading, this), e.off(m.LEVEL_SWITCHING, this.onLevelSwitching, this), e.off(m.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.off(m.ERROR, this.onError, this) } onMediaAttached(e, t) { this.media = t.media, this.media && (-1 < this.queuedDefaultTrack && (this.subtitleTrack = this.queuedDefaultTrack, this.queuedDefaultTrack = -1), this.useTextTrackPolling = !(this.media.textTracks && "onchange" in this.media.textTracks), this.useTextTrackPolling ? this.pollTrackChange(500) : this.media.textTracks.addEventListener("change", this.asyncPollTrackChange)) } pollTrackChange(e) { self.clearInterval(this.subtitlePollingInterval), this.subtitlePollingInterval = self.setInterval(this.trackChangeListener, e) } onMediaDetaching() { this.media && (self.clearInterval(this.subtitlePollingInterval), this.useTextTrackPolling || this.media.textTracks.removeEventListener("change", this.asyncPollTrackChange), -1 < this.trackId && (this.queuedDefaultTrack = this.trackId), _e(this.media.textTracks).forEach(e => { Bt(e) }), this.subtitleTrack = -1, this.media = null) } onManifestLoading() { this.tracks = [], this.groupId = null, this.tracksInGroup = [], this.trackId = -1, this.selectDefaultTrack = !0 } onManifestParsed(e, t) { this.tracks = t.subtitleTracks } onSubtitleTrackLoaded(e, t) { var r, { id: i, details: s } = t, a = this.trackId, a = this.tracksInGroup[a]; a ? (r = a.details, a.details = t.details, this.log(`subtitle track ${i} loaded [${s.startSN}-${s.endSN}]`), i === this.trackId && this.playlistLoaded(i, t, r)) : this.warn("Invalid subtitle track id " + i) } onLevelLoading(e, t) { this.switchLevel(t.level) } onLevelSwitching(e, t) { this.switchLevel(t.level) } switchLevel(r) { var i, s, r = this.hls.levels[r]; if (null != r && r.textGroupIds) { let t = r.textGroupIds[r.urlId], e = this.tracksInGroup ? this.tracksInGroup[this.trackId] : void 0; this.groupId !== t ? (r = this.tracks.filter(e => !t || e.groupId === t), this.tracksInGroup = r, i = this.findTrackId(null == e ? void 0 : e.name) || this.findTrackId(), this.groupId = t || null, s = { subtitleTracks: r }, this.log(`Updating subtitle tracks, ${r.length} track(s) found in "${t}" group-id`), this.hls.trigger(m.SUBTITLE_TRACKS_UPDATED, s), -1 !== i && this.setSubtitleTrack(i, e)) : this.shouldReloadPlaylist(e) && this.setSubtitleTrack(this.trackId, e) } } findTrackId(t) { var r = this.tracksInGroup; for (let e = 0; e < r.length; e++) { var i = r[e]; if ((!this.selectDefaultTrack || i.default) && (!t || t === i.name)) return i.id } return -1 } onError(e, t) { !t.fatal && t.context && t.context.type === G.SUBTITLE_TRACK && t.context.id === this.trackId && t.context.groupId === this.groupId && this.checkRetry(t) } get subtitleTracks() { return this.tracksInGroup } get subtitleTrack() { return this.trackId } set subtitleTrack(e) { this.selectDefaultTrack = !1; var t = this.tracksInGroup ? this.tracksInGroup[this.trackId] : void 0; this.setSubtitleTrack(e, t) } loadPlaylist(t) { super.loadPlaylist(); var r = this.tracksInGroup[this.trackId]; if (this.shouldLoadPlaylist(r)) { var i = r.id, s = r.groupId; let e = r.url; if (t) try { e = t.addDirectives(e) } catch (e) { this.warn("Could not construct new URL with HLS Delivery Directives: " + e) } this.log("Loading subtitle playlist for id " + i), this.hls.trigger(m.SUBTITLE_TRACK_LOADING, { url: e, id: i, groupId: s, deliveryDirectives: t || null }) } } toggleTrackModes(e) { var t, { media: r, trackId: i } = this; r && (t = (r = _e(r.textTracks)).filter(e => e.groupId === this.groupId), -1 === e ? [].slice.call(r).forEach(e => { e.mode = "disabled" }) : (r = t[i]) && (r.mode = "disabled"), i = t[e]) && (i.mode = this.subtitleDisplay ? "showing" : "hidden") } setSubtitleTrack(e, t) { var r, i, s, a, n, o = this.tracksInGroup; this.media ? (this.trackId !== e && this.toggleTrackModes(e), this.trackId === e && (-1 === e || null != (r = o[e]) && r.details) || e < -1 || e >= o.length || (this.clearTimer(), r = o[e], this.log("Switching to subtitle-track " + e + (r ? ` "${r.name}" lang:${r.lang} group:` + r.groupId : "")), this.trackId = e, r ? ({ id: o, groupId: i = "", name: s, type: a, url: n } = r, this.hls.trigger(m.SUBTITLE_TRACK_SWITCH, { id: o, groupId: i, name: s, type: a, url: n }), o = this.switchParams(r.url, null == t ? void 0 : t.details), this.loadPlaylist(o)) : this.hls.trigger(m.SUBTITLE_TRACK_SWITCH, { id: e }))) : this.queuedDefaultTrack = e } onTextTracksChanged() { if (this.useTextTrackPolling || self.clearInterval(this.subtitlePollingInterval), this.media && this.hls.config.renderTextTracksNatively) { let t = -1; var r = _e(this.media.textTracks); for (let e = 0; e < r.length; e++)if ("hidden" === r[e].mode) t = e; else if ("showing" === r[e].mode) { t = e; break } this.subtitleTrack !== t && (this.subtitleTrack = t) } } } function _e(t) { var r = []; for (let e = 0; e < t.length; e++) { var i = t[e]; "subtitles" !== i.kind && "captions" !== i.kind || !i.label || r.push(t[e]) } return r } class Ma { constructor(e) { this.buffers = void 0, this.queues = { video: [], audio: [], audiovideo: [] }, this.buffers = e } append(e, t) { var r = this.queues[t]; r.push(e), 1 === r.length && this.buffers[t] && this.executeNext(t) } insertAbort(e, t) { this.queues[t].unshift(e), this.executeNext(t) } appendBlocker(e) { let t; var r = new Promise(e => { t = e }), i = { execute: t, onStart: () => { }, onComplete: () => { }, onError: () => { } }; return this.append(i, e), r } executeNext(t) { var { buffers: r, queues: i } = this, r = r[t], i = i[t]; if (i.length) { var s = i[0]; try { s.execute() } catch (e) { E.warn("[buffer-operation-queue]: Unhandled exception executing the current operation"), s.onError(e), null != r && r.updating || (i.shift(), this.executeNext(t)) } } } shiftAndExecuteNext(e) { this.queues[e].shift(), this.executeNext(e) } current(e) { return this.queues[e][0] } } let qs = fe(), js = /([ha]vc.)(?:\.[^.,]+)+/; class Na { constructor(e) { this.details = null, this._objectUrl = null, this.operationQueue = void 0, this.listeners = void 0, this.hls = void 0, this.bufferCodecEventsExpected = 0, this._bufferCodecEventsTotal = 0, this.media = null, this.mediaSource = null, this.lastMpegAudioChunk = null, this.appendError = 0, this.tracks = {}, this.pendingTracks = {}, this.sourceBuffer = void 0, this._onMediaSourceOpen = () => { var { media: e, mediaSource: t } = this; E.log("[buffer-controller]: Media source opened"), e && (e.removeEventListener("emptied", this._onMediaEmptied), this.updateMediaElementDuration(), this.hls.trigger(m.MEDIA_ATTACHED, { media: e })), t && t.removeEventListener("sourceopen", this._onMediaSourceOpen), this.checkPendingTracks() }, this._onMediaSourceClose = () => { E.log("[buffer-controller]: Media source closed") }, this._onMediaSourceEnded = () => { E.log("[buffer-controller]: Media source ended") }, this._onMediaEmptied = () => { var { media: e, _objectUrl: t } = this; e && e.src !== t && E.error(`Media element src was set while attaching MediaSource (${t} > ${e.src})`) }, this.hls = e, this._initSourceBuffer(), this.registerListeners() } hasSourceTypes() { return 0 < this.getSourceBufferTypes().length || 0 < Object.keys(this.pendingTracks).length } destroy() { this.unregisterListeners(), this.details = null, this.lastMpegAudioChunk = null } registerListeners() { var e = this.hls; e.on(m.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(m.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(m.MANIFEST_LOADING, this.onManifestLoading, this), e.on(m.MANIFEST_PARSED, this.onManifestParsed, this), e.on(m.BUFFER_RESET, this.onBufferReset, this), e.on(m.BUFFER_APPENDING, this.onBufferAppending, this), e.on(m.BUFFER_CODECS, this.onBufferCodecs, this), e.on(m.BUFFER_EOS, this.onBufferEos, this), e.on(m.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on(m.LEVEL_UPDATED, this.onLevelUpdated, this), e.on(m.FRAG_PARSED, this.onFragParsed, this), e.on(m.FRAG_CHANGED, this.onFragChanged, this) } unregisterListeners() { var e = this.hls; e.off(m.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(m.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(m.MANIFEST_LOADING, this.onManifestLoading, this), e.off(m.MANIFEST_PARSED, this.onManifestParsed, this), e.off(m.BUFFER_RESET, this.onBufferReset, this), e.off(m.BUFFER_APPENDING, this.onBufferAppending, this), e.off(m.BUFFER_CODECS, this.onBufferCodecs, this), e.off(m.BUFFER_EOS, this.onBufferEos, this), e.off(m.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off(m.LEVEL_UPDATED, this.onLevelUpdated, this), e.off(m.FRAG_PARSED, this.onFragParsed, this), e.off(m.FRAG_CHANGED, this.onFragChanged, this) } _initSourceBuffer() { this.sourceBuffer = {}, this.operationQueue = new Ma(this.sourceBuffer), this.listeners = { audio: [], video: [], audiovideo: [] }, this.lastMpegAudioChunk = null } onManifestLoading() { this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = 0, this.details = null } onManifestParsed(e, t) { let r = 2; (!t.audio || t.video) && t.altAudio || (r = 1), this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = r, E.log(this.bufferCodecEventsExpected + " bufferCodec event(s) expected") } onMediaAttaching(e, t) { var r, t = this.media = t.media; t && qs && ((r = this.mediaSource = new qs).addEventListener("sourceopen", this._onMediaSourceOpen), r.addEventListener("sourceended", this._onMediaSourceEnded), r.addEventListener("sourceclose", this._onMediaSourceClose), t.src = self.URL.createObjectURL(r), this._objectUrl = t.src, t.addEventListener("emptied", this._onMediaEmptied)) } onMediaDetaching() { var { media: e, mediaSource: t, _objectUrl: r } = this; if (t) { if (E.log("[buffer-controller]: media source detaching"), "open" === t.readyState) try { t.endOfStream() } catch (e) { E.warn(`[buffer-controller]: onMediaDetaching: ${e.message} while calling endOfStream`) } this.onBufferReset(), t.removeEventListener("sourceopen", this._onMediaSourceOpen), t.removeEventListener("sourceended", this._onMediaSourceEnded), t.removeEventListener("sourceclose", this._onMediaSourceClose), e && (e.removeEventListener("emptied", this._onMediaEmptied), r && self.URL.revokeObjectURL(r), e.src === r ? (e.removeAttribute("src"), e.load()) : E.warn("[buffer-controller]: media.src was changed by a third party - skip cleanup")), this.mediaSource = null, this.media = null, this._objectUrl = null, this.bufferCodecEventsExpected = this._bufferCodecEventsTotal, this.pendingTracks = {}, this.tracks = {} } this.hls.trigger(m.MEDIA_DETACHED, void 0) } onBufferReset() { this.getSourceBufferTypes().forEach(t => { var e = this.sourceBuffer[t]; try { e && (this.removeBufferListeners(t), this.mediaSource && this.mediaSource.removeSourceBuffer(e), this.sourceBuffer[t] = void 0) } catch (e) { E.warn(`[buffer-controller]: Failed to reset the ${t} buffer`, e) } }), this._initSourceBuffer() } onBufferCodecs(e, h) { let d = this.getSourceBufferTypes().length; Object.keys(h).forEach(e => { var t, r, i, s, a, n, o, l; d ? (t = this.tracks[e]) && "function" == typeof t.buffer.changeType && ({ id: r, codec: i, levelCodec: s, container: a, metadata: n } = h[e], (o = (t.levelCodec || t.codec).replace(js, "$1")) !== (l = (s || i).replace(js, "$1"))) && (this.appendChangeType(e, a + ";codecs=" + (s || i)), E.log(`[buffer-controller]: switching codec ${o} to ` + l), this.tracks[e] = { buffer: t.buffer, codec: i, container: a, levelCodec: s, metadata: n, id: r }) : this.pendingTracks[e] = h[e] }), !d && (this.bufferCodecEventsExpected = Math.max(this.bufferCodecEventsExpected - 1, 0), this.mediaSource) && "open" === this.mediaSource.readyState && this.checkPendingTracks() } appendChangeType(t, r) { let i = this.operationQueue, e = { execute: () => { var e = this.sourceBuffer[t]; e && (E.log(`[buffer-controller]: changing ${t} sourceBuffer type to ` + r), e.changeType(r)), i.shiftAndExecuteNext(t) }, onStart: () => { }, onComplete: () => { }, onError: e => { E.warn(`[buffer-controller]: Failed to change ${t} SourceBuffer type`, e) } }; i.append(e, t) } onBufferAppending(e, t) { let { hls: r, operationQueue: i, tracks: s } = this, { data: a, type: n, frag: o, part: l, chunkMeta: h } = t, d = h.buffering[n], u = self.performance.now(), c = (d.start = u, o.stats.buffering), f = l ? l.stats.buffering : null; 0 === c.start && (c.start = u), f && 0 === f.start && (f.start = u); t = s.audio; let g = !1, p = ("audio" === n && "audio/mpeg" === (null == t ? void 0 : t.container) && (g = !this.lastMpegAudioChunk || 1 === h.id || this.lastMpegAudioChunk.sn !== h.sn, this.lastMpegAudioChunk = h), o.start), v = { execute: () => { var e, t; d.executeStart = self.performance.now(), g && (e = this.sourceBuffer[n]) && (t = p - e.timestampOffset, .1 <= Math.abs(t)) && (E.log(`[buffer-controller]: Updating audio SourceBuffer timestampOffset to ${p} (delta: ${t}) sn: ${o.sn})`), e.timestampOffset = p), this.appendExecutor(a, n) }, onStart: () => { }, onComplete: () => { var e, t = self.performance.now(), r = (d.executeEnd = d.end = t, 0 === c.first && (c.first = t), f && 0 === f.first && (f.first = t), this).sourceBuffer, i = {}; for (e in r) i[e] = q.getBuffered(r[e]); this.appendError = 0, this.hls.trigger(m.BUFFER_APPENDED, { type: n, frag: o, part: l, chunkMeta: h, parent: o.type, timeRanges: i }) }, onError: e => { E.error(`[buffer-controller]: Error encountered while trying to append to the ${n} SourceBuffer`, e); var t = { type: N.MEDIA_ERROR, parent: o.type, details: L.BUFFER_APPEND_ERROR, frag: o, part: l, chunkMeta: h, error: e, err: e, fatal: !1 }; e.code === DOMException.QUOTA_EXCEEDED_ERR ? t.details = L.BUFFER_FULL_ERROR : (this.appendError++, t.details = L.BUFFER_APPEND_ERROR, this.appendError > r.config.appendErrorMaxRetry && (E.error(`[buffer-controller]: Failed ${r.config.appendErrorMaxRetry} times to append segment in sourceBuffer`), t.fatal = !0)), r.trigger(m.ERROR, t) } }; i.append(v, n) } onBufferFlushing(e, r) { let t = this.operationQueue, i = t => ({ execute: this.removeExecutor.bind(this, t, r.startOffset, r.endOffset), onStart: () => { }, onComplete: () => { this.hls.trigger(m.BUFFER_FLUSHED, { type: t }) }, onError: e => { E.warn(`[buffer-controller]: Failed to remove from ${t} SourceBuffer`, e) } }); r.type ? t.append(i(r.type), r.type) : this.getSourceBufferTypes().forEach(e => { t.append(i(e), e) }) } onFragParsed(e, t) { let { frag: r, part: i } = t, s = [], a = (i || r).elementaryStreams; a[H.AUDIOVIDEO] ? s.push("audiovideo") : (a[H.AUDIO] && s.push("audio"), a[H.VIDEO] && s.push("video")); 0 === s.length && E.warn(`Fragments must have at least one ElementaryStreamType set. type: ${r.type} level: ${r.level} sn: ` + r.sn), this.blockBuffers(() => { var e = self.performance.now(), e = (r.stats.buffering.end = e, i && (i.stats.buffering.end = e), (i || r).stats); this.hls.trigger(m.FRAG_BUFFERED, { frag: r, part: i, stats: e, id: r.type }) }, s) } onFragChanged(e, t) { this.flushBackBuffer() } onBufferEos(e, i) { this.getSourceBufferTypes().reduce((e, t) => { var r = this.sourceBuffer[t]; return !r || i.type && i.type !== t || (r.ending = !0, r.ended) || (r.ended = !0, E.log(`[buffer-controller]: ${t} sourceBuffer now EOS`)), e && !(r && !r.ended) }, !0) && (E.log("[buffer-controller]: Queueing mediaSource.endOfStream()"), this.blockBuffers(() => { this.getSourceBufferTypes().forEach(e => { e = this.sourceBuffer[e]; e && (e.ending = !1) }); var e = this.mediaSource; e && "open" === e.readyState ? (E.log("[buffer-controller]: Calling mediaSource.endOfStream()"), e.endOfStream()) : e && E.info("[buffer-controller]: Could not call mediaSource.endOfStream(). mediaSource.readyState: " + e.readyState) })) } onLevelUpdated(e, { details: t }) { t.fragments.length && (this.details = t, this.getSourceBufferTypes().length ? this.blockBuffers(this.updateMediaElementDuration.bind(this)) : this.updateMediaElementDuration()) } flushBackBuffer() { let { hls: n, details: o, media: t, sourceBuffer: l } = this; if (t && null !== o) { var r = this.getSourceBufferTypes(); if (r.length) { var h = o.live && null !== n.config.liveBackBufferLength ? n.config.liveBackBufferLength : n.config.backBufferLength; if (F(h) && !(h < 0)) { let i = t.currentTime, s = o.levelTargetDuration, e = Math.max(h, s), a = Math.floor(i / s) * s - e; r.forEach(e => { var t = l[e]; if (t) { var r = q.getBuffered(t); if (0 < r.length && a > r.start(0)) { if (n.trigger(m.BACK_BUFFER_REACHED, { bufferEnd: a }), o.live) n.trigger(m.LIVE_BACK_BUFFER_REACHED, { bufferEnd: a }); else if (t.ended && r.end(r.length - 1) - i < 2 * s) return void E.info(`[buffer-controller]: Cannot flush ${e} back buffer while SourceBuffer is in ended state`); n.trigger(m.BUFFER_FLUSHING, { startOffset: 0, endOffset: a, type: e }) } } }) } } } } updateMediaElementDuration() { var e, t, r, i, s, a; this.details && this.media && this.mediaSource && "open" === this.mediaSource.readyState && ({ details: e, hls: t, media: s, mediaSource: r } = this, i = e.fragments[0].start + e.totalduration, s = s.duration, a = F(r.duration) ? r.duration : 0, e.live && t.config.liveDurationInfinity ? (E.log("[buffer-controller]: Media Source duration is set to Infinity"), r.duration = 1 / 0, this.updateSeekableRange(e)) : (a < i && s < i || !F(s)) && (E.log("[buffer-controller]: Updating Media Source duration to " + i.toFixed(3)), r.duration = i)) } updateSeekableRange(e) { var t = this.mediaSource, r = e.fragments; r.length && e.live && null != t && t.setLiveSeekableRange && (r = Math.max(0, r[0].start), e = Math.max(r, r + e.totalduration), t.setLiveSeekableRange(r, e)) } checkPendingTracks() { let { bufferCodecEventsExpected: e, operationQueue: t, pendingTracks: r } = this, i = Object.keys(r).length; var s; (i && !e || 2 === i) && (this.createSourceBuffers(r), this.pendingTracks = {}, (s = this.getSourceBufferTypes()).length ? (this.hls.trigger(m.BUFFER_CREATED, { tracks: this.tracks }), s.forEach(e => { t.executeNext(e) })) : (s = new Error("could not create source buffer for media codec(s)"), this.hls.trigger(m.ERROR, { type: N.MEDIA_ERROR, details: L.BUFFER_INCOMPATIBLE_CODECS_ERROR, fatal: !0, error: s, reason: s.message }))) } createSourceBuffers(e) { var t, { sourceBuffer: r, mediaSource: i } = this; if (!i) throw Error("createSourceBuffers called when mediaSource was null"); for (t in e) if (!r[t]) { var s = e[t]; if (!s) throw Error(`source buffer exists for track ${t}, however track does not`); var a = s.levelCodec || s.codec, n = s.container + ";codecs=" + a; E.log(`[buffer-controller]: creating sourceBuffer(${n})`); try { var o = r[t] = i.addSourceBuffer(n), l = t; this.addBufferListener(l, "updatestart", this._onSBUpdateStart), this.addBufferListener(l, "updateend", this._onSBUpdateEnd), this.addBufferListener(l, "error", this._onSBUpdateError), this.tracks[t] = { buffer: o, codec: a, container: s.container, levelCodec: s.levelCodec, metadata: s.metadata, id: s.id } } catch (e) { E.error("[buffer-controller]: error while trying to add sourceBuffer: " + e.message), this.hls.trigger(m.ERROR, { type: N.MEDIA_ERROR, details: L.BUFFER_ADD_CODEC_ERROR, fatal: !1, error: e, mimeType: n }) } } } _onSBUpdateStart(e) { var t = this.operationQueue; t.current(e).onStart() } _onSBUpdateEnd(e) { var t = this.operationQueue; t.current(e).onComplete(), t.shiftAndExecuteNext(e) } _onSBUpdateError(e, t) { var r = new Error(e + " SourceBuffer error"), r = (E.error("[buffer-controller]: " + r, t), this.hls.trigger(m.ERROR, { type: N.MEDIA_ERROR, details: L.BUFFER_APPENDING_ERROR, error: r, fatal: !1 }), this.operationQueue.current(e)); r && r.onError(t) } removeExecutor(e, t, r) { var { media: i, mediaSource: s, operationQueue: a, sourceBuffer: n } = this, n = n[e]; i && s && n ? (i = F(i.duration) ? i.duration : 1 / 0, s = F(s.duration) ? s.duration : 1 / 0, (t = Math.max(0, t)) < (r = Math.min(r, i, s)) && !n.ending ? (n.ended = !1, E.log(`[buffer-controller]: Removing [${t},${r}] from the ${e} SourceBuffer`), n.remove(t, r)) : a.shiftAndExecuteNext(e)) : (E.warn(`[buffer-controller]: Attempting to remove from the ${e} SourceBuffer, but it does not exist`), a.shiftAndExecuteNext(e)) } appendExecutor(e, t) { var { operationQueue: r, sourceBuffer: i } = this, i = i[t]; i ? (i.ended = !1, i.appendBuffer(e)) : (E.warn(`[buffer-controller]: Attempting to append to the ${t} SourceBuffer, but it does not exist`), r.shiftAndExecuteNext(t)) } blockBuffers(t, i = this.getSourceBufferTypes()) { if (i.length) { let r = this.operationQueue, e = i.map(e => r.appendBlocker(e)); Promise.all(e).then(() => { t(), i.forEach(e => { var t = this.sourceBuffer[e]; null != t && t.updating || r.shiftAndExecuteNext(e) }) }) } else E.log("[buffer-controller]: Blocking operation requested, but no SourceBuffers exist"), Promise.resolve().then(t) } getSourceBufferTypes() { return Object.keys(this.sourceBuffer) } addBufferListener(e, t, r) { var i = this.sourceBuffer[e]; i && (r = r.bind(this, e), this.listeners[e].push({ event: t, listener: r }), i.addEventListener(t, r)) } removeBufferListeners(e) { let t = this.sourceBuffer[e]; t && this.listeners[e].forEach(e => { t.removeEventListener(e.event, e.listener) }) } } let Xs = { 42: 225, 92: 233, 94: 237, 95: 243, 96: 250, 123: 231, 124: 247, 125: 209, 126: 241, 127: 9608, 128: 174, 129: 176, 130: 189, 131: 191, 132: 8482, 133: 162, 134: 163, 135: 9834, 136: 224, 137: 32, 138: 232, 139: 226, 140: 234, 141: 238, 142: 244, 143: 251, 144: 193, 145: 201, 146: 211, 147: 218, 148: 220, 149: 252, 150: 8216, 151: 161, 152: 42, 153: 8217, 154: 9473, 155: 169, 156: 8480, 157: 8226, 158: 8220, 159: 8221, 160: 192, 161: 194, 162: 199, 163: 200, 164: 202, 165: 203, 166: 235, 167: 206, 168: 207, 169: 239, 170: 212, 171: 217, 172: 249, 173: 219, 174: 171, 175: 187, 176: 195, 177: 227, 178: 205, 179: 204, 180: 236, 181: 210, 182: 242, 183: 213, 184: 245, 185: 123, 186: 125, 187: 92, 188: 94, 189: 95, 190: 124, 191: 8764, 192: 196, 193: 228, 194: 214, 195: 246, 196: 223, 197: 165, 198: 164, 199: 9475, 200: 197, 201: 229, 202: 216, 203: 248, 204: 9487, 205: 9491, 206: 9495, 207: 9499 }, ji = function (e) { let t = e; return Xs.hasOwnProperty(e) && (t = Xs[e]), String.fromCharCode(t) }, pt = 15, vt = 100, Ua = { 17: 1, 18: 3, 21: 5, 22: 7, 23: 9, 16: 11, 19: 12, 20: 14 }, Ba = { 17: 2, 18: 4, 21: 6, 22: 8, 23: 10, 19: 13, 20: 15 }, $a = { 25: 1, 26: 3, 29: 5, 30: 7, 31: 9, 24: 11, 27: 12, 28: 14 }, Ga = { 25: 2, 26: 4, 29: 6, 30: 8, 31: 10, 27: 13, 28: 15 }, Ka = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "black", "transparent"]; class Ha { constructor() { this.time = null, this.verboseLevel = 0 } log(e, t) { this.verboseLevel >= e && (t = "function" == typeof t ? t() : t, E.log(this.time + ` [${e}] ` + t)) } } let kt = function (t) { var r = []; for (let e = 0; e < t.length; e++)r.push(t[e].toString(16)); return r }; class Xi { constructor(e, t, r, i, s) { this.foreground = void 0, this.underline = void 0, this.italics = void 0, this.background = void 0, this.flash = void 0, this.foreground = e || "white", this.underline = t || !1, this.italics = r || !1, this.background = i || "black", this.flash = s || !1 } reset() { this.foreground = "white", this.underline = !1, this.italics = !1, this.background = "black", this.flash = !1 } setStyles(t) { var r = ["foreground", "underline", "italics", "background", "flash"]; for (let e = 0; e < r.length; e++) { var i = r[e]; t.hasOwnProperty(i) && (this[i] = t[i]) } } isDefault() { return "white" === this.foreground && !this.underline && !this.italics && "black" === this.background && !this.flash } equals(e) { return this.foreground === e.foreground && this.underline === e.underline && this.italics === e.italics && this.background === e.background && this.flash === e.flash } copy(e) { this.foreground = e.foreground, this.underline = e.underline, this.italics = e.italics, this.background = e.background, this.flash = e.flash } toString() { return "color=" + this.foreground + ", underline=" + this.underline + ", italics=" + this.italics + ", background=" + this.background + ", flash=" + this.flash } } class Va { constructor(e, t, r, i, s, a) { this.uchar = void 0, this.penState = void 0, this.uchar = e || " ", this.penState = new Xi(t, r, i, s, a) } reset() { this.uchar = " ", this.penState.reset() } setChar(e, t) { this.uchar = e, this.penState.copy(t) } setPenState(e) { this.penState.copy(e) } equals(e) { return this.uchar === e.uchar && this.penState.equals(e.penState) } copy(e) { this.uchar = e.uchar, this.penState.copy(e.penState) } isEmpty() { return " " === this.uchar && this.penState.isDefault() } } class Wa { constructor(e) { this.chars = void 0, this.pos = void 0, this.currPenState = void 0, this.cueStartTime = void 0, this.logger = void 0, this.chars = []; for (let e = 0; e < vt; e++)this.chars.push(new Va); this.logger = e, this.pos = 0, this.currPenState = new Xi } equals(t) { let r = !0; for (let e = 0; e < vt; e++)if (!this.chars[e].equals(t.chars[e])) { r = !1; break } return r } copy(t) { for (let e = 0; e < vt; e++)this.chars[e].copy(t.chars[e]) } isEmpty() { let t = !0; for (let e = 0; e < vt; e++)if (!this.chars[e].isEmpty()) { t = !1; break } return t } setCursor(e) { this.pos !== e && (this.pos = e), this.pos < 0 ? (this.logger.log(3, "Negative cursor position " + this.pos), this.pos = 0) : this.pos > vt && (this.logger.log(3, "Too large cursor position " + this.pos), this.pos = vt) } moveCursor(e) { var t = this.pos + e; if (1 < e) for (let e = this.pos + 1; e < t + 1; e++)this.chars[e].setPenState(this.currPenState); this.setCursor(t) } backSpace() { this.moveCursor(-1), this.chars[this.pos].setChar(" ", this.currPenState) } insertChar(e) { 144 <= e && this.backSpace(); let t = ji(e); this.pos >= vt ? this.logger.log(0, () => "Cannot insert " + e.toString(16) + " (" + t + ") at position " + this.pos + ". Skipping it!") : (this.chars[this.pos].setChar(t, this.currPenState), this.moveCursor(1)) } clearFromPos(e) { let t; for (t = e; t < vt; t++)this.chars[t].reset() } clear() { this.clearFromPos(0), this.pos = 0, this.currPenState.reset() } clearToEndOfRow() { this.clearFromPos(this.pos) } getTextString() { var t = []; let r = !0; for (let e = 0; e < vt; e++) { var i = this.chars[e].uchar; " " !== i && (r = !1), t.push(i) } return r ? "" : t.join("") } setPenStyles(e) { this.currPenState.setStyles(e), this.chars[this.pos].setPenState(this.currPenState) } } class we {
    constructor(t) { this.rows = void 0, this.currRow = void 0, this.nrRollUpRows = void 0, this.lastOutputScreen = void 0, this.logger = void 0, this.rows = []; for (let e = 0; e < pt; e++)this.rows.push(new Wa(t)); this.logger = t, this.currRow = pt - 1, this.nrRollUpRows = null, this.lastOutputScreen = null, this.reset() } reset() { for (let e = 0; e < pt; e++)this.rows[e].clear(); this.currRow = pt - 1 } equals(t) { let r = !0; for (let e = 0; e < pt; e++)if (!this.rows[e].equals(t.rows[e])) { r = !1; break } return r } copy(t) { for (let e = 0; e < pt; e++)this.rows[e].copy(t.rows[e]) } isEmpty() { let t = !0; for (let e = 0; e < pt; e++)if (!this.rows[e].isEmpty()) { t = !1; break } return t } backSpace() { this.rows[this.currRow].backSpace() } clearToEndOfRow() { this.rows[this.currRow].clearToEndOfRow() } insertChar(e) { this.rows[this.currRow].insertChar(e) } setPen(e) { this.rows[this.currRow].setPenStyles(e) } moveCursor(e) { this.rows[this.currRow].moveCursor(e) } setCursor(e) { this.logger.log(2, "setCursor: " + e), this.rows[this.currRow].setCursor(e) } setPAC(e) { this.logger.log(2, () => "pacData = " + JSON.stringify(e)); let t = e.row - 1; if (this.nrRollUpRows && t < this.nrRollUpRows - 1 && (t = this.nrRollUpRows - 1), this.nrRollUpRows && this.currRow !== t) { for (let e = 0; e < pt; e++)this.rows[e].clear(); var r = this.currRow + 1 - this.nrRollUpRows, i = this.lastOutputScreen; if (i) { var s = i.rows[r].cueStartTime, a = this.logger.time; if (s && null !== a && s < a) for (let e = 0; e < this.nrRollUpRows; e++)this.rows[t - this.nrRollUpRows + e + 1].copy(i.rows[r + e]) } } this.currRow = t; s = this.rows[this.currRow], null !== e.indent && (a = e.indent, a = Math.max(a - 1, 0), s.setCursor(e.indent), e.color = s.chars[a].penState.foreground), s = { foreground: e.color, underline: e.underline, italics: e.italics, background: "black", flash: !1 }; this.setPen(s) } setBkgData(e) { this.logger.log(2, () => "bkgData = " + JSON.stringify(e)), this.backSpace(), this.setPen(e), this.insertChar(32) } setRollUpRows(e) { this.nrRollUpRows = e } rollUp() { var e; null === this.nrRollUpRows ? this.logger.log(3, "roll_up but nrRollUpRows not set yet") : (this.logger.log(1, () => this.getDisplayText()), e = this.currRow + 1 - this.nrRollUpRows, (e = this.rows.splice(e, 1)[0]).clear(), this.rows.splice(this.currRow, 0, e), this.logger.log(2, "Rolling up")) } getDisplayText(t) {
        t = t || !1; var r = []; let e = "", i; for (let e = 0; e < pt; e++) { var s = this.rows[e].getTextString(); s && (i = e + 1, r.push(t ? "Row " + i + ": '" + s + "'" : s.trim())) } return e = 0 < r.length ? t ? "[" + r.join(" | ") + "]" : r.join(`
`) : e
    } getTextAndFormat() { return this.rows }
} class zs { constructor(e, t, r) { this.chNr = void 0, this.outputFilter = void 0, this.mode = void 0, this.verbose = void 0, this.displayedMemory = void 0, this.nonDisplayedMemory = void 0, this.lastOutputScreen = void 0, this.currRollUpRow = void 0, this.writeScreen = void 0, this.cueStartTime = void 0, this.logger = void 0, this.chNr = e, this.outputFilter = t, this.mode = null, this.verbose = 0, this.displayedMemory = new we(r), this.nonDisplayedMemory = new we(r), this.lastOutputScreen = new we(r), this.currRollUpRow = this.displayedMemory.rows[pt - 1], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null, this.logger = r } reset() { this.mode = null, this.displayedMemory.reset(), this.nonDisplayedMemory.reset(), this.lastOutputScreen.reset(), this.outputFilter.reset(), this.currRollUpRow = this.displayedMemory.rows[pt - 1], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null } getHandler() { return this.outputFilter } setHandler(e) { this.outputFilter = e } setPAC(e) { this.writeScreen.setPAC(e) } setBkgData(e) { this.writeScreen.setBkgData(e) } setMode(e) { e !== this.mode && (this.mode = e, this.logger.log(2, () => "MODE=" + e), "MODE_POP-ON" === this.mode ? this.writeScreen = this.nonDisplayedMemory : (this.writeScreen = this.displayedMemory, this.writeScreen.reset()), "MODE_ROLL-UP" !== this.mode && (this.displayedMemory.nrRollUpRows = null, this.nonDisplayedMemory.nrRollUpRows = null), this.mode = e) } insertChars(t) { for (let e = 0; e < t.length; e++)this.writeScreen.insertChar(t[e]); let e = this.writeScreen === this.displayedMemory ? "DISP" : "NON_DISP"; this.logger.log(2, () => e + ": " + this.writeScreen.getDisplayText(!0)), "MODE_PAINT-ON" !== this.mode && "MODE_ROLL-UP" !== this.mode || (this.logger.log(1, () => "DISPLAYED: " + this.displayedMemory.getDisplayText(!0)), this.outputDataUpdate()) } ccRCL() { this.logger.log(2, "RCL - Resume Caption Loading"), this.setMode("MODE_POP-ON") } ccBS() { this.logger.log(2, "BS - BackSpace"), "MODE_TEXT" !== this.mode && (this.writeScreen.backSpace(), this.writeScreen === this.displayedMemory) && this.outputDataUpdate() } ccAOF() { } ccAON() { } ccDER() { this.logger.log(2, "DER- Delete to End of Row"), this.writeScreen.clearToEndOfRow(), this.outputDataUpdate() } ccRU(e) { this.logger.log(2, "RU(" + e + ") - Roll Up"), this.writeScreen = this.displayedMemory, this.setMode("MODE_ROLL-UP"), this.writeScreen.setRollUpRows(e) } ccFON() { this.logger.log(2, "FON - Flash On"), this.writeScreen.setPen({ flash: !0 }) } ccRDC() { this.logger.log(2, "RDC - Resume Direct Captioning"), this.setMode("MODE_PAINT-ON") } ccTR() { this.logger.log(2, "TR"), this.setMode("MODE_TEXT") } ccRTD() { this.logger.log(2, "RTD"), this.setMode("MODE_TEXT") } ccEDM() { this.logger.log(2, "EDM - Erase Displayed Memory"), this.displayedMemory.reset(), this.outputDataUpdate(!0) } ccCR() { this.logger.log(2, "CR - Carriage Return"), this.writeScreen.rollUp(), this.outputDataUpdate(!0) } ccENM() { this.logger.log(2, "ENM - Erase Non-displayed Memory"), this.nonDisplayedMemory.reset() } ccEOC() { var e; this.logger.log(2, "EOC - End Of Caption"), "MODE_POP-ON" === this.mode && (e = this.displayedMemory, this.displayedMemory = this.nonDisplayedMemory, this.nonDisplayedMemory = e, this.writeScreen = this.nonDisplayedMemory, this.logger.log(1, () => "DISP: " + this.displayedMemory.getDisplayText())), this.outputDataUpdate(!0) } ccTO(e) { this.logger.log(2, "TO(" + e + ") - Tab Offset"), this.writeScreen.moveCursor(e) } ccMIDROW(e) { var t = { flash: !1 }; t.underline = e % 2 == 1, t.italics = 46 <= e, t.italics ? t.foreground = "white" : (e = Math.floor(e / 2) - 16, t.foreground = ["white", "green", "blue", "cyan", "red", "yellow", "magenta"][e]), this.logger.log(2, "MIDROW: " + JSON.stringify(t)), this.writeScreen.setPen(t) } outputDataUpdate(e = !1) { var t = this.logger.time; null !== t && this.outputFilter && (null !== this.cueStartTime || this.displayedMemory.isEmpty() ? this.displayedMemory.equals(this.lastOutputScreen) || (this.outputFilter.newCue(this.cueStartTime, t, this.lastOutputScreen), e && this.outputFilter.dispatchCue && this.outputFilter.dispatchCue(), this.cueStartTime = this.displayedMemory.isEmpty() ? null : t) : this.cueStartTime = t, this.lastOutputScreen.copy(this.displayedMemory)) } cueSplitAtTime(e) { !this.outputFilter || this.displayedMemory.isEmpty() || (this.outputFilter.newCue && this.outputFilter.newCue(this.cueStartTime, e, this.displayedMemory), this.cueStartTime = e) } } class Qs { constructor(e, t, r) { this.channels = void 0, this.currentChannel = 0, this.cmdHistory = void 0, this.logger = void 0; var i = new Ha; this.channels = [null, new zs(e, t, i), new zs(e + 1, r, i)], this.cmdHistory = Zs(), this.logger = i } getHandler(e) { return this.channels[e].getHandler() } setHandler(e, t) { this.channels[e].setHandler(t) } addData(e, t) { let r, i, s, a = !1; this.logger.time = e; for (let e = 0; e < t.length; e += 2) { var n; i = 127 & t[e], s = 127 & t[e + 1], 0 == i && 0 == s || (this.logger.log(3, "[" + kt([t[e], t[e + 1]]) + "] -> (" + kt([i, s]) + ")"), !(r = (r = (r = (r = this.parseCmd(i, s)) || this.parseMidrow(i, s)) || this.parsePAC(i, s)) || this.parseBackgroundAttributes(i, s)) && (a = this.parseChars(i, s)) && ((n = this.currentChannel) && 0 < n ? this.channels[n].insertChars(a) : this.logger.log(2, "No channel found yet. TEXT-MODE?")), r) || a || this.logger.log(2, "Couldn't parse cleaned data " + kt([i, s]) + " orig: " + kt([t[e], t[e + 1]])) } } parseCmd(e, t) { var r, i, s = this.cmdHistory; return ((20 === e || 28 === e || 21 === e || 29 === e) && 32 <= t && t <= 47 || (23 === e || 31 === e) && 33 <= t && t <= 35) && (Js(e, t, s) ? (Nt(null, null, s), this.logger.log(3, "Repeated command (" + kt([e, t]) + ") is dropped")) : (i = this.channels[r = 20 === e || 21 === e || 23 === e ? 1 : 2], 20 === e || 21 === e || 28 === e || 29 === e ? 32 === t ? i.ccRCL() : 33 === t ? i.ccBS() : 34 === t ? i.ccAOF() : 35 === t ? i.ccAON() : 36 === t ? i.ccDER() : 37 === t ? i.ccRU(2) : 38 === t ? i.ccRU(3) : 39 === t ? i.ccRU(4) : 40 === t ? i.ccFON() : 41 === t ? i.ccRDC() : 42 === t ? i.ccTR() : 43 === t ? i.ccRTD() : 44 === t ? i.ccEDM() : 45 === t ? i.ccCR() : 46 === t ? i.ccENM() : 47 === t && i.ccEOC() : i.ccTO(t - 32), Nt(e, t, s), this.currentChannel = r), !0) } parseMidrow(e, t) { let r = 0; var i; return (17 === e || 25 === e) && 32 <= t && t <= 47 && ((r = 17 === e ? 1 : 2) !== this.currentChannel ? (this.logger.log(0, "Mismatch channel in midrow parsing"), !1) : !!(i = this.channels[r]) && (i.ccMIDROW(t), this.logger.log(3, "MIDROW (" + kt([e, t]) + ")"), !0)) } parsePAC(e, t) { let r; var i, s, a = this.cmdHistory; return ((17 <= e && e <= 23 || 25 <= e && e <= 31) && 64 <= t && t <= 127 || (16 === e || 24 === e) && 64 <= t && t <= 95) && (Js(e, t, a) ? (Nt(null, null, a), !0) : (i = e <= 23 ? 1 : 2, r = (64 <= t && t <= 95 ? 1 == i ? Ua : $a : 1 == i ? Ba : Ga)[e], !!(s = this.channels[i]) && (s.setPAC(this.interpretPAC(r, t)), Nt(e, t, a), this.currentChannel = i, !0))) } interpretPAC(e, t) { let r; e = { color: null, italics: !1, indent: null, underline: !1, row: e }; return r = 95 < t ? t - 96 : t - 64, e.underline = 1 == (1 & r), r <= 13 ? e.color = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "white"][Math.floor(r / 2)] : r <= 15 ? (e.italics = !0, e.color = "white") : e.indent = 4 * Math.floor((r - 16) / 2), e } parseChars(e, t) { let r, i = null, s = null; if (17 <= (s = 25 <= e ? (r = 2, e - 8) : (r = 1, e)) && s <= 19) { let e; e = 17 === s ? t + 80 : 18 === s ? t + 112 : t + 144, this.logger.log(2, "Special char '" + ji(e) + "' in channel " + r), i = [e] } else 32 <= e && e <= 127 && (i = 0 === t ? [e] : [e, t]); var a; return i && (a = kt(i), this.logger.log(3, "Char codes =  " + a.join(",")), Nt(e, t, this.cmdHistory)), i } parseBackgroundAttributes(e, t) { var r, i; return ((16 === e || 24 === e) && 32 <= t && t <= 47 || (23 === e || 31 === e) && 45 <= t && t <= 47) && (i = {}, 16 === e || 24 === e ? (r = Math.floor((t - 32) / 2), i.background = Ka[r], t % 2 == 1 && (i.background = i.background + "_semi")) : 45 === t ? i.background = "transparent" : (i.foreground = "black", 47 === t && (i.underline = !0)), this.channels[e <= 23 ? 1 : 2].setBkgData(i), Nt(e, t, this.cmdHistory), !0) } reset() { for (let e = 0; e < Object.keys(this.channels).length; e++) { var t = this.channels[e]; t && t.reset() } this.cmdHistory = Zs() } cueSplitAtTime(t) { for (let e = 0; e < this.channels.length; e++) { var r = this.channels[e]; r && r.cueSplitAtTime(t) } } } function Nt(e, t, r) { r.a = e, r.b = t } function Js(e, t, r) { return r.a === e && r.b === t } function Zs() { return { a: null, b: null } } class ee { constructor(e, t) { this.timelineController = void 0, this.cueRanges = [], this.trackName = void 0, this.startTime = null, this.endTime = null, this.screen = null, this.timelineController = e, this.trackName = t } dispatchCue() { null !== this.startTime && (this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen, this.cueRanges), this.startTime = null) } newCue(e, t, r) { (null === this.startTime || this.startTime > e) && (this.startTime = e), this.endTime = t, this.screen = r, this.timelineController.createCaptionsTrack(this.trackName) } reset() { this.cueRanges = [], this.startTime = null } } var cs = (() => { if (typeof self < "u" && self.VTTCue) return self.VTTCue; let T = ["", "lr", "rl"], t = ["start", "middle", "end", "left", "right"]; function y(e, t) { return !("string" != typeof t || !Array.isArray(e) || (t = t.toLowerCase(), !~e.indexOf(t))) && t } function L(e) { return y(t, e) } function S(e) { let t = 1; for (; t < arguments.length; t++) { var r, i = arguments[t]; for (r in i) e[r] = i[r] } return e } function e(e, t, r) { var i = this, s = { enumerable: !0 }; i.hasBeenReset = !1; let a = "", n = !1, o = e, l = t, h = r, d = null, u = "", c = !0, f = "auto", g = "start", m = 50, p = "middle", v = 50, E = "middle"; Object.defineProperty(i, "id", S({}, s, { get: function () { return a }, set: function (e) { a = "" + e } })), Object.defineProperty(i, "pauseOnExit", S({}, s, { get: function () { return n }, set: function (e) { n = !!e } })), Object.defineProperty(i, "startTime", S({}, s, { get: function () { return o }, set: function (e) { if ("number" != typeof e) throw new TypeError("Start time must be set to a number."); o = e, this.hasBeenReset = !0 } })), Object.defineProperty(i, "endTime", S({}, s, { get: function () { return l }, set: function (e) { if ("number" != typeof e) throw new TypeError("End time must be set to a number."); l = e, this.hasBeenReset = !0 } })), Object.defineProperty(i, "text", S({}, s, { get: function () { return h }, set: function (e) { h = "" + e, this.hasBeenReset = !0 } })), Object.defineProperty(i, "region", S({}, s, { get: function () { return d }, set: function (e) { d = e, this.hasBeenReset = !0 } })), Object.defineProperty(i, "vertical", S({}, s, { get: function () { return u }, set: function (e) { e = e; e = y(T, e); if (!1 === e) throw new SyntaxError("An invalid or illegal string was specified."); u = e, this.hasBeenReset = !0 } })), Object.defineProperty(i, "snapToLines", S({}, s, { get: function () { return c }, set: function (e) { c = !!e, this.hasBeenReset = !0 } })), Object.defineProperty(i, "line", S({}, s, { get: function () { return f }, set: function (e) { if ("number" != typeof e && "auto" !== e) throw new SyntaxError("An invalid number or illegal string was specified."); f = e, this.hasBeenReset = !0 } })), Object.defineProperty(i, "lineAlign", S({}, s, { get: function () { return g }, set: function (e) { e = L(e); if (!e) throw new SyntaxError("An invalid or illegal string was specified."); g = e, this.hasBeenReset = !0 } })), Object.defineProperty(i, "position", S({}, s, { get: function () { return m }, set: function (e) { if (e < 0 || 100 < e) throw new Error("Position must be between 0 and 100."); m = e, this.hasBeenReset = !0 } })), Object.defineProperty(i, "positionAlign", S({}, s, { get: function () { return p }, set: function (e) { e = L(e); if (!e) throw new SyntaxError("An invalid or illegal string was specified."); p = e, this.hasBeenReset = !0 } })), Object.defineProperty(i, "size", S({}, s, { get: function () { return v }, set: function (e) { if (e < 0 || 100 < e) throw new Error("Size must be between 0 and 100."); v = e, this.hasBeenReset = !0 } })), Object.defineProperty(i, "align", S({}, s, { get: function () { return E }, set: function (e) { e = L(e); if (!e) throw new SyntaxError("An invalid or illegal string was specified."); E = e, this.hasBeenReset = !0 } })), i.displayState = void 0 } return e.prototype.getCueAsHTML = function () { return self.WebVTT.convertCueToDOMTree(self, this.text) }, e })(); class Ya { decode(e, t) { if (!e) return ""; if ("string" != typeof e) throw new Error("Error - expected string data."); return decodeURIComponent(encodeURIComponent(e)) } } function zi(e) { function t(e, t, r, i) { return 3600 * (0 | e) + 60 * (0 | t) + (0 | r) + parseFloat(i || 0) } e = e.match(/^(?:(\d+):)?(\d{2}):(\d{2})(\.\d+)?/); return e ? 59 < parseFloat(e[2]) ? t(e[2], e[3], 0, e[4]) : t(e[1], e[2], e[3], e[4]) : null } class qa { constructor() { this.values = Object.create(null) } set(e, t) { this.get(e) || "" === t || (this.values[e] = t) } get(e, t, r) { return r ? this.has(e) ? this.values[e] : t[r] : this.has(e) ? this.values[e] : t } has(e) { return e in this.values } alt(t, r, i) { for (let e = 0; e < i.length; ++e)if (r === i[e]) { this.set(t, r); break } } integer(e, t) { /^-?\d+$/.test(t) && this.set(e, parseInt(t, 10)) } percent(e, t) { if (/^([\d]{1,3})(\.[\d]*)?%$/.test(t)) { t = parseFloat(t); if (0 <= t && t <= 100) return this.set(e, t), !0 } return !1 } } function Qi(e, t, r, i) { var s, a, n = i ? e.split(i) : [e]; for (s in n) "string" == typeof n[s] && 2 === (a = n[s].split(r)).length && t(a[0], a[1]) } let qe = new cs(0, 0, ""), se = "middle" === qe.align ? "middle" : "center"; function ja(r, s, a) { let t = r; function e() { var e = zi(r); if (null === e) throw new Error("Malformed timestamp: " + t); return r = r.replace(/^[^\sa-zA-Z-]+/, ""), e } function i() { r = r.replace(/^\s+/, "") } if (i(), s.startTime = e(), i(), "--\x3e" !== r.slice(0, 3)) throw new Error("Malformed time stamp (time stamps must be separated by '--\x3e'): " + t); r = r.slice(3), i(), s.endTime = e(), i(); { var n = r; let i = new qa, e = (Qi(n, function (t, r) { let e; switch (t) { case "region": for (let e = a.length - 1; 0 <= e; e--)if (a[e].id === r) { i.set(t, a[e].region); break } break; case "vertical": i.alt(t, r, ["rl", "lr"]); break; case "line": e = r.split(","), i.integer(t, e[0]), i.percent(t, e[0]) && i.set("snapToLines", !1), i.alt(t, e[0], ["auto"]), 2 === e.length && i.alt("lineAlign", e[1], ["start", se, "end"]); break; case "position": e = r.split(","), i.percent(t, e[0]), 2 === e.length && i.alt("positionAlign", e[1], ["start", se, "end", "line-left", "line-right", "auto"]); break; case "size": i.percent(t, r); break; case "align": i.alt(t, r, ["start", se, "end", "left", "right"]) } }, /:/, /\s/), s.region = i.get("region", null), s.vertical = i.get("vertical", ""), i.get("line", "auto")), t = ("auto" === e && -1 === qe.line && (e = -1), s.line = e, s.lineAlign = i.get("lineAlign", "start"), s.snapToLines = i.get("snapToLines", !0), s.size = i.get("size", 100), s.align = i.get("align", se), i.get("position", "auto")); "auto" === t && 50 === qe.position && (t = "start" === s.align || "left" === s.align ? 0 : "end" === s.align || "right" === s.align ? 100 : 50), s.position = t } } function Ji(e) {
    return e.replace(/<br(?: \/)?>/gi, `
`)
} class Xa {
    constructor() { this.state = "INITIAL", this.buffer = "", this.decoder = new Ya, this.regionList = [], this.cue = null, this.oncue = void 0, this.onparsingerror = void 0, this.onflush = void 0 } parse(e) {
        let i = this; function r() {
            let e = i.buffer, t = 0; for (e = Ji(e); t < e.length && "\r" !== e[t] && e[t] !== `
`;)++t; var r = e.slice(0, t); return "\r" === e[t] && ++t, e[t] === `
`&& ++t, i.buffer = e.slice(t), r
        } e && (i.buffer += i.decoder.decode(e, { stream: !0 })); try {
            let e = ""; if ("INITIAL" === i.state) { if (!/\r\n|\n/.test(i.buffer)) return this; var s = (e = r()).match(/^()?WEBVTT([ \t].*)?$/); if (null == s || !s[0]) throw new Error("Malformed WebVTT signature."); i.state = "HEADER" } let t = !1; for (; i.buffer;) {
                if (!/\r\n|\n/.test(i.buffer)) return this; switch (t ? t = !1 : e = r(), i.state) {
                    case "HEADER": /:/.test(e) ? Qi(e, function (e, t) { }, /:/) : e || (i.state = "ID"); continue; case "NOTE": e || (i.state = "ID"); continue; case "ID": if (/^NOTE($|[ \t])/.test(e)) { i.state = "NOTE"; break } if (!e) continue; if (i.cue = new cs(0, 0, ""), i.state = "CUE", -1 === e.indexOf("--\x3e")) { i.cue.id = e; continue } case "CUE": if (!i.cue) { i.state = "BADCUE"; continue } try { ja(e, i.cue, i.regionList) } catch { i.cue = null, i.state = "BADCUE"; continue } i.state = "CUETEXT"; continue; case "CUETEXT": var a = -1 !== e.indexOf("--\x3e"); if (!e || a && (t = !0)) { i.oncue && i.cue && i.oncue(i.cue), i.cue = null, i.state = "ID"; continue } if (null === i.cue) continue; i.cue.text && (i.cue.text += `
`), i.cue.text += e; continue; case "BADCUE": e || (i.state = "ID")
                }
            }
        } catch { "CUETEXT" === i.state && i.cue && i.oncue && i.oncue(i.cue), i.cue = null, i.state = "INITIAL" === i.state ? "BADWEBVTT" : "BADCUE" } return this
    } flush() {
        var t = this; try {
            if (!t.cue && "HEADER" !== t.state || (t.buffer += `

`, t.parse()), "INITIAL" === t.state || "BADWEBVTT" === t.state) throw new Error("Malformed WebVTT signature.")
        } catch (e) { t.onparsingerror && t.onparsingerror(e) } return t.onflush && t.onflush(), this
    }
} let za = /\r\n|\n\r|\n|\r/g, Pe = function (e, t, r = 0) { return e.slice(r, r + t.length) === t }, Qa = function (e) { var t = parseInt(e.slice(-3)), r = parseInt(e.slice(-6, -4)), i = parseInt(e.slice(-9, -7)), s = 9 < e.length ? parseInt(e.substring(0, e.indexOf(":"))) : 0; if (F(t) && F(r) && F(i) && F(s)) return (t += 1e3 * r) + 6e4 * i + 36e5 * s; throw Error("Malformed X-TIMESTAMP-MAP: Local:" + e) }, Fe = function (e) { let t = 5381, r = e.length; for (; r;)t = 33 * t ^ e.charCodeAt(--r); return (t >>> 0).toString() }; function hs(e, t, r) { return Fe(e.toString()) + Fe(t.toString()) + Fe(r) } let Ja = function (e, t, r) { let i = e[t], s = e[i.prevCC]; if (!s || !s.new && i.new) e.ccOffset = e.presentationOffset = i.start, i.new = !1; else { for (; null != (a = s) && a.new;) { var a; e.ccOffset += i.start - s.start, i.new = !1, s = e[(i = s).prevCC] } e.presentationOffset = r } }; function Za(e, t, s, a, n, r, i) {
    let o = new Xa, l = St(new Uint8Array(e)).trim().replace(za, `
`).split(`
`), h = [], d = ha(t.baseTime, t.timescale), u = "00:00.000", c = 0, f = 0, g, m = !0; o.oncue = function (e) { var t = s[a]; let r = s.ccOffset; var i = (c - d) / 9e4, t = (null != t && t.new && (void 0 !== f ? r = s.ccOffset = t.start : Ja(s, a, i)), i && (r = i - s.presentationOffset), e.endTime - e.startTime), i = ft(9e4 * (e.startTime + r - f), 9e4 * n) / 9e4, i = (e.startTime = Math.max(i, 0), e.endTime = Math.max(i + t, 0), e.text.trim()); e.text = decodeURIComponent(encodeURIComponent(i)), e.id || (e.id = hs(e.startTime, e.endTime, i)), 0 < e.endTime && h.push(e) }, o.onparsingerror = function (e) { g = e }, o.onflush = function () { g ? i(g) : r(h) }, l.forEach(e => {
        if (m) { if (Pe(e, "X-TIMESTAMP-MAP=")) { m = !1, e.slice(16).split(",").forEach(e => { Pe(e, "LOCAL:") ? u = e.slice(6) : Pe(e, "MPEGTS:") && (c = parseInt(e.slice(7))) }); try { f = Qa(u) / 1e3 } catch (e) { g = e } return } "" === e && (m = !1) } o.parse(e + `
`)
    }), o.flush()
} let Oe = "stpp.ttml.im1t", Zi = /^(\d{2,}):(\d{2}):(\d{2}):(\d{2})\.?(\d+)?$/, tr = /^(\d*(?:\.\d*)?)(h|m|s|ms|f|t)$/, to = { left: "start", center: "center", right: "end", start: "start", end: "end" }; function ti(r, i, s, a) { r = $(new Uint8Array(r), ["mdat"]); if (0 === r.length) a(new Error("Could not parse IMSC1 mdat")); else { let e = r.map(e => St(e)), t = ca(i.baseTime, 1, i.timescale); try { e.forEach(e => s(eo(e, t))) } catch (e) { a(e) } } } function eo(e, a) { let r = (new DOMParser).parseFromString(e, "text/xml").getElementsByTagName("tt")[0]; if (!r) throw new Error("Invalid ttml"); let i = { frameRate: 30, subFrameRate: 1, frameRateMultiplier: 0, tickRate: 0 }, n = Object.keys(i).reduce((e, t) => (e[t] = r.getAttribute("ttp:" + t) || i[t], e), {}), o = "preserve" !== r.getAttribute("xml:space"), l = ei(Me(r, "styling", "style")), h = ei(Me(r, "layout", "region")), t = Me(r, "body", "[begin]"); return [].map.call(t, e => { var t = er(e, o); if (!t || !e.hasAttribute("begin")) return null; var r = Ue(e.getAttribute("begin"), n), i = Ue(e.getAttribute("dur"), n); let s = Ue(e.getAttribute("end"), n); if (null === r) throw si(e); if (null === s) { if (null === i) throw si(e); s = r + i } i = new cs(r - a, s - a, t), i.id = hs(i.startTime, i.endTime, i.text), r = h[e.getAttribute("region")], t = so(r, l[e.getAttribute("style")], l), r = t.textAlign; return r && ((e = to[r]) && (i.lineAlign = e), i.align = r), tt(i, t), i }).filter(e => null !== e) } function Me(e, t, r) { e = e.getElementsByTagName(t)[0]; return e ? [].slice.call(e.querySelectorAll(r)) : [] } function ei(e) { return e.reduce((e, t) => { var r = t.getAttribute("xml:id"); return r && (e[r] = t), e }, {}) } function er(e, i) {
    return [].slice.call(e.childNodes).reduce((e, t, r) => "br" === t.nodeName && r ? e + `
`: null != (r = t.childNodes) && r.length ? er(t, i) : i ? e + t.textContent.trim().replace(/\s+/g, " ") : e + t.textContent, "")
} function so(i, s, e) { let a = "http://www.w3.org/ns/ttml#styling", n = null; var t = null != i && i.hasAttribute("style") ? i.getAttribute("style") : null; return t && e.hasOwnProperty(t) && (n = e[t]), ["displayAlign", "textAlign", "color", "backgroundColor", "fontSize", "fontFamily"].reduce((e, t) => { var r = Ne(s, a, t) || Ne(i, a, t) || Ne(n, a, t); return r && (e[t] = r), e }, {}) } function Ne(e, t, r) { return e && e.hasAttributeNS(t, r) ? e.getAttributeNS(t, r) : null } function si(e) { return new Error("Could not parse ttml timestamp " + e) } function Ue(e, t) { if (!e) return null; let r = zi(e); return null === r && (Zi.test(e) ? r = io(e, t) : tr.test(e) && (r = ro(e, t))), r } function io(e, t) { var e = Zi.exec(e), r = (0 | e[4]) + (0 | e[5]) / t.subFrameRate; return 3600 * (0 | e[1]) + 60 * (0 | e[2]) + (0 | e[3]) + r / t.frameRate } function ro(e, t) { var e = tr.exec(e), r = Number(e[1]); switch (e[2]) { case "h": return 3600 * r; case "m": return 60 * r; case "ms": return 1e3 * r; case "f": return r / t.frameRate; case "t": return r / t.tickRate }return r } class no { constructor(e) { var t, r, i, s; this.hls = void 0, this.media = null, this.config = void 0, this.enabled = !0, this.Cues = void 0, this.textTracks = [], this.tracks = [], this.initPTS = [], this.unparsedVttFrags = [], this.captionsTracks = {}, this.nonNativeCaptionsTracks = {}, this.cea608Parser1 = void 0, this.cea608Parser2 = void 0, this.lastSn = -1, this.lastPartIndex = -1, this.prevCC = -1, this.vttCCs = ii(), this.captionsProperties = void 0, this.hls = e, this.config = e.config, this.Cues = e.config.cueHandler, this.captionsProperties = { textTrack1: { label: this.config.captionsTextTrack1Label, languageCode: this.config.captionsTextTrack1LanguageCode }, textTrack2: { label: this.config.captionsTextTrack2Label, languageCode: this.config.captionsTextTrack2LanguageCode }, textTrack3: { label: this.config.captionsTextTrack3Label, languageCode: this.config.captionsTextTrack3LanguageCode }, textTrack4: { label: this.config.captionsTextTrack4Label, languageCode: this.config.captionsTextTrack4LanguageCode } }, this.config.enableCEA708Captions && (t = new ee(this, "textTrack1"), r = new ee(this, "textTrack2"), i = new ee(this, "textTrack3"), s = new ee(this, "textTrack4"), this.cea608Parser1 = new Qs(1, t, r), this.cea608Parser2 = new Qs(3, i, s)), e.on(m.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(m.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(m.MANIFEST_LOADING, this.onManifestLoading, this), e.on(m.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(m.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.on(m.FRAG_LOADING, this.onFragLoading, this), e.on(m.FRAG_LOADED, this.onFragLoaded, this), e.on(m.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this), e.on(m.FRAG_DECRYPTED, this.onFragDecrypted, this), e.on(m.INIT_PTS_FOUND, this.onInitPtsFound, this), e.on(m.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this), e.on(m.BUFFER_FLUSHING, this.onBufferFlushing, this) } destroy() { var e = this.hls; e.off(m.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(m.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(m.MANIFEST_LOADING, this.onManifestLoading, this), e.off(m.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(m.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.off(m.FRAG_LOADING, this.onFragLoading, this), e.off(m.FRAG_LOADED, this.onFragLoaded, this), e.off(m.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this), e.off(m.FRAG_DECRYPTED, this.onFragDecrypted, this), e.off(m.INIT_PTS_FOUND, this.onInitPtsFound, this), e.off(m.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this), e.off(m.BUFFER_FLUSHING, this.onBufferFlushing, this), this.hls = this.config = this.cea608Parser1 = this.cea608Parser2 = null } addCues(e, t, r, i, s) { let a = !1; for (let e = s.length; e--;) { var n = s[e], o = oo(n[0], n[1], t, r); if (0 <= o && (n[0] = Math.min(n[0], t), n[1] = Math.max(n[1], r), a = !0, .5 < o / (r - t))) return } var l; a || s.push([t, r]), this.config.renderTextTracksNatively ? (l = this.captionsTracks[e], this.Cues.newCue(l, t, r, i)) : (l = this.Cues.newCue(null, t, r, i), this.hls.trigger(m.CUES_PARSED, { type: "captions", cues: l, track: e })) } onInitPtsFound(e, { frag: t, id: r, initPTS: i, timescale: s }) { var a = this.unparsedVttFrags; "main" === r && (this.initPTS[t.cc] = { baseTime: i, timescale: s }), a.length && (this.unparsedVttFrags = [], a.forEach(e => { this.onFragLoaded(m.FRAG_LOADED, e) })) } getExistingTrack(t) { var r = this.media; if (r) for (let e = 0; e < r.textTracks.length; e++) { var i = r.textTracks[e]; if (i[t]) return i } return null } createCaptionsTrack(e) { this.config.renderTextTracksNatively ? this.createNativeTrack(e) : this.createNonNativeTrack(e) } createNativeTrack(e) { var t, r, i, s, a; this.captionsTracks[e] || ({ captionsProperties: i, captionsTracks: t, media: r } = this, { label: i, languageCode: s } = i[e], (a = this.getExistingTrack(e)) ? (t[e] = a, Bt(t[e]), Ai(t[e], r)) : (a = this.createTextTrack("captions", i, s)) && (a[e] = !0, t[e] = a)) } createNonNativeTrack(e) { var t; this.nonNativeCaptionsTracks[e] || (t = this.captionsProperties[e]) && (t = { _id: e, label: t.label, kind: "captions", default: !!t.media && !!t.media.default, closedCaptions: t.media }, this.nonNativeCaptionsTracks[e] = t, this.hls.trigger(m.NON_NATIVE_TEXT_TRACKS_FOUND, { tracks: [t] })) } createTextTrack(e, t, r) { var i = this.media; if (i) return i.addTextTrack(e, t, r) } onMediaAttaching(e, t) { this.media = t.media, this._cleanTracks() } onMediaDetaching() { let t = this.captionsTracks; Object.keys(t).forEach(e => { Bt(t[e]), delete t[e] }), this.nonNativeCaptionsTracks = {} } onManifestLoading() { this.lastSn = -1, this.lastPartIndex = -1, this.prevCC = -1, this.vttCCs = ii(), this._cleanTracks(), this.tracks = [], this.captionsTracks = {}, this.nonNativeCaptionsTracks = {}, this.textTracks = [], this.unparsedVttFrags = this.unparsedVttFrags || [], this.initPTS = [], this.cea608Parser1 && this.cea608Parser2 && (this.cea608Parser1.reset(), this.cea608Parser2.reset()) } _cleanTracks() { var e = this.media; if (e) { var t = e.textTracks; if (t) for (let e = 0; e < t.length; e++)Bt(t[e]) } } onSubtitleTracksUpdated(e, t) { var t = t.subtitleTracks || [], r = t.some(e => e.textCodec === Oe); if (this.config.enableWebVTT || r && this.config.enableIMSC1) if (qi(this.tracks, t)) this.tracks = t; else if (this.textTracks = [], this.tracks = t, this.config.renderTextTracksNatively) { let s = this.media ? this.media.textTracks : null; this.tracks.forEach((r, e) => { let i; if (s && e < s.length) { let t = null; for (let e = 0; e < s.length; e++)if (ao(s[e], r)) { t = s[e]; break } t && (i = t) } i ? Bt(i) : (e = this._captionsOrSubtitlesFromCharacteristics(r), (i = this.createTextTrack(e, r.name, r.lang)) && (i.mode = "disabled")), i && (i.groupId = r.groupId, this.textTracks.push(i)) }) } else this.tracks.length && (r = this.tracks.map(e => ({ label: e.name, kind: e.type.toLowerCase(), default: e.default, subtitleTrack: e })), this.hls.trigger(m.NON_NATIVE_TEXT_TRACKS_FOUND, { tracks: r })) } _captionsOrSubtitlesFromCharacteristics(e) { if (e.attrs.CHARACTERISTICS) { var t = /transcribes-spoken-dialog/gi.test(e.attrs.CHARACTERISTICS), e = /describes-music-and-sound/gi.test(e.attrs.CHARACTERISTICS); if (t && e) return "captions" } return "subtitles" } onManifestLoaded(e, t) { this.config.enableCEA708Captions && t.captions && t.captions.forEach(e => { var t = /(?:CC|SERVICE)([1-4])/.exec(e.instreamId); t && (t = "textTrack" + t[1], t = this.captionsProperties[t]) && (t.label = e.name, e.lang && (t.languageCode = e.lang), t.media = e) }) } closedCaptionsForLevel(e) { e = this.hls.levels[e.level]; return null == e ? void 0 : e.attrs["CLOSED-CAPTIONS"] } onFragLoading(e, t) { var r, { cea608Parser1: i, cea608Parser2: s, lastSn: a, lastPartIndex: n } = this; this.enabled && i && s && t.frag.type === U.MAIN && (r = t.frag.sn, t = null != (t = null == t || null == (t = t.part) ? void 0 : t.index) ? t : -1, r === a + 1 || r === a && t === n + 1 || (i.reset(), s.reset()), this.lastSn = r, this.lastPartIndex = t) } onFragLoaded(e, t) { var r, i, { frag: s, payload: a } = t, { initPTS: n, unparsedVttFrags: o } = this; s.type === U.SUBTITLE && (a.byteLength ? n[s.cc] ? (r = s.decryptdata, i = "stats" in t, null != r && r.encrypted && !i || (r = this.tracks[s.level], (i = this.vttCCs)[s.cc] || (i[s.cc] = { start: s.start, prevCC: this.prevCC, new: !0 }, this.prevCC = s.cc), r && r.textCodec === Oe ? this._parseIMSC1(s, a) : this._parseVTTs(s, a, i))) : (o.push(t), n.length && this.hls.trigger(m.SUBTITLE_FRAG_PROCESSED, { success: !1, frag: s, error: new Error("Missing initial subtitle PTS") })) : this.hls.trigger(m.SUBTITLE_FRAG_PROCESSED, { success: !1, frag: s, error: new Error("Empty subtitle payload") })) } _parseIMSC1(t, e) { let r = this.hls; ti(e, this.initPTS[t.cc], e => { this._appendCues(e, t.level), r.trigger(m.SUBTITLE_FRAG_PROCESSED, { success: !0, frag: t }) }, e => { E.log("Failed to parse IMSC1: " + e), r.trigger(m.SUBTITLE_FRAG_PROCESSED, { success: !1, frag: t, error: e }) }) } _parseVTTs(t, r, e) { let i, s = this.hls, a = null != (i = t.initSegment) && i.data ? Pt(t.initSegment.data, new Uint8Array(r)) : r; Za(a, this.initPTS[t.cc], e, t.cc, t.start, e => { this._appendCues(e, t.level), s.trigger(m.SUBTITLE_FRAG_PROCESSED, { success: !0, frag: t }) }, e => { this._fallbackToIMSC1(t, r), E.log("Failed to parse VTT cue: " + e), s.trigger(m.SUBTITLE_FRAG_PROCESSED, { success: !1, frag: t, error: e }) }) } _fallbackToIMSC1(e, t) { let r = this.tracks[e.level]; r.textCodec || ti(t, this.initPTS[e.cc], () => { r.textCodec = Oe, this._parseIMSC1(e, t) }, () => { r.textCodec = "wvtt" }) } _appendCues(e, r) { var t = this.hls; if (this.config.renderTextTracksNatively) { let t = this.textTracks[r]; t && "disabled" !== t.mode && e.forEach(e => Li(t, e)) } else { var i = this.tracks[r]; i && (i = i.default ? "default" : "subtitles" + r, t.trigger(m.CUES_PARSED, { type: "subtitles", cues: e, track: i })) } } onFragDecrypted(e, t) { var r = t.frag; r.type === U.SUBTITLE && (this.initPTS[r.cc] ? this.onFragLoaded(m.FRAG_LOADED, t) : this.unparsedVttFrags.push(t)) } onSubtitleTracksCleared() { this.tracks = [], this.captionsTracks = {} } onFragParsingUserdata(e, t) { var { cea608Parser1: r, cea608Parser2: i } = this; if (this.enabled && r && i) { var { frag: t, samples: s } = t; if (t.type !== U.MAIN || "NONE" !== this.closedCaptionsForLevel(t)) for (let e = 0; e < s.length; e++) { var a = s[e].bytes; a && (a = this.extractCea608Data(a), r.addData(s[e].pts, a[0]), i.addData(s[e].pts, a[1])) } } } onBufferFlushing(e, { startOffset: r, endOffset: i, endOffsetSubtitles: s, type: t }) { var a = this.media; if (a && !(a.currentTime < i)) { if (!t || "video" === t) { let t = this.captionsTracks; Object.keys(t).forEach(e => Ge(t[e], r, i)) } if (this.config.renderTextTracksNatively && 0 === r && void 0 !== s) { let t = this.textTracks; Object.keys(t).forEach(e => Ge(t[e], r, s)) } } } extractCea608Data(t) { var r = [[], []], i = 31 & t[0]; let s = 2; for (let e = 0; e < i; e++) { var a = t[s++], n = 127 & t[s++], o = 127 & t[s++]; 0 == n && 0 == o || 0 == (4 & a) || 0 != (a = 3 & a) && 1 != a || (r[a].push(n), r[a].push(o)) } return r } } function ao(e, t) { return !!e && e.label === t.name && !(e.textTrack1 || e.textTrack2) } function oo(e, t, r, i) { return Math.min(t, i) - Math.max(e, r) } function ii() { return { ccOffset: 0, presentationOffset: 0, 0: { start: 0, prevCC: -1, new: !0 } } } class ds { constructor(e) { this.hls = void 0, this.autoLevelCapping = void 0, this.firstLevel = void 0, this.media = void 0, this.restrictedLevels = void 0, this.timer = void 0, this.clientRect = void 0, this.streamController = void 0, this.hls = e, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.firstLevel = -1, this.media = null, this.restrictedLevels = [], this.timer = void 0, this.clientRect = null, this.registerListeners() } setStreamController(e) { this.streamController = e } destroy() { this.unregisterListener(), this.hls.config.capLevelToPlayerSize && this.stopCapping(), this.media = null, this.clientRect = null, this.hls = this.streamController = null } registerListeners() { var e = this.hls; e.on(m.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this), e.on(m.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(m.MANIFEST_PARSED, this.onManifestParsed, this), e.on(m.BUFFER_CODECS, this.onBufferCodecs, this), e.on(m.MEDIA_DETACHING, this.onMediaDetaching, this) } unregisterListener() { var e = this.hls; e.off(m.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this), e.off(m.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(m.MANIFEST_PARSED, this.onManifestParsed, this), e.off(m.BUFFER_CODECS, this.onBufferCodecs, this), e.off(m.MEDIA_DETACHING, this.onMediaDetaching, this) } onFpsDropLevelCapping(e, t) { t = this.hls.levels[t.droppedLevel]; this.isLevelAllowed(t) && this.restrictedLevels.push({ bitrate: t.bitrate, height: t.height, width: t.width }) } onMediaAttaching(e, t) { this.media = t.media instanceof HTMLVideoElement ? t.media : null, this.clientRect = null } onManifestParsed(e, t) { var r = this.hls; this.restrictedLevels = [], this.firstLevel = t.firstLevel, r.config.capLevelToPlayerSize && t.video && this.startCapping() } onBufferCodecs(e, t) { this.hls.config.capLevelToPlayerSize && t.video && this.startCapping() } onMediaDetaching() { this.stopCapping() } detectPlayerSize() { var e, t; this.media && 0 < this.mediaHeight && 0 < this.mediaWidth && (e = this.hls.levels).length && ((t = this.hls).autoLevelCapping = this.getMaxLevel(e.length - 1), t.autoLevelCapping > this.autoLevelCapping && this.streamController && this.streamController.nextLevelSwitch(), this.autoLevelCapping = t.autoLevelCapping) } getMaxLevel(r) { var e = this.hls.levels; return e.length ? (e = e.filter((e, t) => this.isLevelAllowed(e) && t <= r), this.clientRect = null, ds.getMaxLevelByMediaSize(e, this.mediaWidth, this.mediaHeight)) : -1 } startCapping() { this.timer || (this.autoLevelCapping = Number.POSITIVE_INFINITY, this.hls.firstLevel = this.getMaxLevel(this.firstLevel), self.clearInterval(this.timer), this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1e3), this.detectPlayerSize()) } stopCapping() { this.restrictedLevels = [], this.firstLevel = -1, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.timer && (self.clearInterval(this.timer), this.timer = void 0) } getDimensions() { var e, t, r; return this.clientRect || (t = { width: 0, height: 0 }, (e = this.media) && (r = e.getBoundingClientRect(), t.width = r.width, t.height = r.height, t.width || t.height || (t.width = r.right - r.left || e.width || 0, t.height = r.bottom - r.top || e.height || 0)), this.clientRect = t) } get mediaWidth() { return this.getDimensions().width * this.contentScaleFactor } get mediaHeight() { return this.getDimensions().height * this.contentScaleFactor } get contentScaleFactor() { let e = 1; if (!this.hls.config.ignoreDevicePixelRatio) try { e = self.devicePixelRatio } catch { } return e } isLevelAllowed(t) { return !this.restrictedLevels.some(e => t.bitrate === e.bitrate && t.width === e.width && t.height === e.height) } static getMaxLevelByMediaSize(t, r, i) { if (null == t || !t.length) return -1; var s; let a = t.length - 1; for (let e = 0; e < t.length; e += 1) { var n = t[e]; if ((n.width >= r || n.height >= i) && (n = n, !(s = t[e + 1]) || n.width !== s.width || n.height !== s.height)) { a = e; break } } return a } } class lo { constructor(e) { this.hls = void 0, this.isVideoPlaybackQualityAvailable = !1, this.timer = void 0, this.media = null, this.lastTime = void 0, this.lastDroppedFrames = 0, this.lastDecodedFrames = 0, this.streamController = void 0, this.hls = e, this.registerListeners() } setStreamController(e) { this.streamController = e } registerListeners() { this.hls.on(m.MEDIA_ATTACHING, this.onMediaAttaching, this) } unregisterListeners() { this.hls.off(m.MEDIA_ATTACHING, this.onMediaAttaching, this) } destroy() { this.timer && clearInterval(this.timer), this.unregisterListeners(), this.isVideoPlaybackQualityAvailable = !1, this.media = null } onMediaAttaching(e, t) { var r = this.hls.config; r.capLevelOnFPSDrop && (t = t.media instanceof self.HTMLVideoElement ? t.media : null, (this.media = t) && "function" == typeof t.getVideoPlaybackQuality && (this.isVideoPlaybackQualityAvailable = !0), self.clearInterval(this.timer), this.timer = self.setInterval(this.checkFPSInterval.bind(this), r.fpsDroppedMonitoringPeriod)) } checkFPS(e, t, r) { var i, s, a, n, o = performance.now(); t && (this.lastTime && (n = o - this.lastTime, i = r - this.lastDroppedFrames, s = t - this.lastDecodedFrames, n = 1e3 * i / n, (a = this.hls).trigger(m.FPS_DROP, { currentDropped: i, currentDecoded: s, totalDroppedFrames: r }), 0 < n) && i > a.config.fpsDroppedMonitoringThreshold * s && (n = a.currentLevel, E.warn("drop FPS ratio greater than max allowed value for currentLevel: " + n), 0 < n) && (-1 === a.autoLevelCapping || a.autoLevelCapping >= n) && (n -= 1, a.trigger(m.FPS_DROP_LEVEL_CAPPING, { level: n, droppedLevel: a.currentLevel }), a.autoLevelCapping = n, this.streamController.nextLevelSwitch()), this.lastTime = o, this.lastDroppedFrames = r, this.lastDecodedFrames = t) } checkFPSInterval() { var e, t = this.media; t && (this.isVideoPlaybackQualityAvailable ? (e = t.getVideoPlaybackQuality(), this.checkFPS(t, e.totalVideoFrames, e.droppedVideoFrames)) : this.checkFPS(t, t.webkitDecodedFrameCount, t.webkitDroppedFrameCount)) } } let ie = "[eme]"; class $t {
    constructor(e) { this.hls = void 0, this.config = void 0, this.media = null, this.keyFormatPromise = null, this.keySystemAccessPromises = {}, this._requestLicenseFailureCount = 0, this.mediaKeySessions = [], this.keyIdToKeySessionPromise = {}, this.setMediaKeysQueue = $t.CDMCleanupPromise ? [$t.CDMCleanupPromise] : [], this.onMediaEncrypted = this._onMediaEncrypted.bind(this), this.onWaitingForKey = this._onWaitingForKey.bind(this), this.debug = E.debug.bind(E, ie), this.log = E.log.bind(E, ie), this.warn = E.warn.bind(E, ie), this.error = E.error.bind(E, ie), this.hls = e, this.config = e.config, this.registerListeners() } destroy() { this.unregisterListeners(), this.onMediaDetached(); var e = this.config; e.requestMediaKeySystemAccessFunc = null, e.licenseXhrSetup = e.licenseResponseCallback = void 0, e.drmSystems = e.drmSystemOptions = {}, this.hls = this.onMediaEncrypted = this.onWaitingForKey = this.keyIdToKeySessionPromise = null, this.config = null } registerListeners() { this.hls.on(m.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.on(m.MEDIA_DETACHED, this.onMediaDetached, this), this.hls.on(m.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.on(m.MANIFEST_LOADED, this.onManifestLoaded, this) } unregisterListeners() { this.hls.off(m.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.off(m.MEDIA_DETACHED, this.onMediaDetached, this), this.hls.off(m.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.off(m.MANIFEST_LOADED, this.onManifestLoaded, this) } getLicenseServerUrl(e) { var { drmSystems: t, widevineLicenseUrl: r } = this.config, t = t[e]; if (t) return t.licenseUrl; if (e === J.WIDEVINE && r) return r; throw new Error(`no license server URL configured for key-system "${e}"`) } getServerCertificateUrl(e) { var t = this.config.drmSystems, t = t[e]; if (t) return t.serverCertificateUrl; this.log(`No Server Certificate in config.drmSystems["${e}"]`) } attemptKeySystemAccess(e) { let t = this.hls.levels, r = (e, t, r) => !!e && r.indexOf(e) === t, n = t.map(e => e.audioCodec).filter(r), o = t.map(e => e.videoCodec).filter(r); return n.length + o.length === 0 && o.push("avc1.42e01e"), new Promise((i, s) => { let a = t => { let r = t.shift(); this.getMediaKeysPromise(r, n, o).then(e => i({ keySystem: r, mediaKeys: e })).catch(e => { t.length ? a(t) : e instanceof ut ? s(e) : s(new ut({ type: N.KEY_SYSTEM_ERROR, details: L.KEY_SYSTEM_NO_ACCESS, error: e, fatal: !0 }, e.message)) }) }; a(e) }) } requestMediaKeySystemAccess(e, t) { var r = this.config.requestMediaKeySystemAccessFunc; if ("function" == typeof r) return r(e, t); { let e = "Configured requestMediaKeySystemAccess is not a function " + r; return null === di && "http:" === self.location.protocol && (e = "navigator.requestMediaKeySystemAccess is not available over insecure protocol " + location.protocol), Promise.reject(new Error(e)) } } getMediaKeysPromise(i, e, t) { let r = Sr(i, e, t, this.config.drmSystemOptions), s = this.keySystemAccessPromises[i], a = null == s ? void 0 : s.keySystemAccess; if (a) return a.then(() => s.mediaKeys); { this.log(`Requesting encrypted media "${i}" key-system access with config: ` + JSON.stringify(r)), a = this.requestMediaKeySystemAccess(i, r); let t = this.keySystemAccessPromises[i] = { keySystemAccess: a }; return a.catch(e => { this.log(`Failed to obtain access to key-system "${i}": ` + e) }), a.then(e => { this.log(`Access for key-system "${e.keySystem}" obtained`); let r = this.fetchServerCertificate(i); return this.log(`Create media-keys for "${i}"`), t.mediaKeys = e.createMediaKeys().then(t => (this.log(`Media-keys created for "${i}"`), r.then(e => e ? this.setMediaKeysServerCertificate(t, i, e) : t))), t.mediaKeys.catch(e => { this.error(`Failed to create media-keys for "${i}"}: ` + e) }), t.mediaKeys }) } } createMediaKeySessionContext({ decryptdata: e, keySystem: t, mediaKeys: r }) { this.log(`Creating key-system session "${t}" keyId: ` + Et.hexDump(e.keyId || [])); var i = r.createSession(), e = { decryptdata: e, keySystem: t, mediaKeys: r, mediaKeysSession: i, keyStatus: "status-pending" }; return this.mediaKeySessions.push(e), e } renewKeySession(e) { var t, r, i = e.decryptdata; i.pssh ? (t = this.createMediaKeySessionContext(e), r = this.getKeyIdString(i), this.keyIdToKeySessionPromise[r] = this.generateRequestWithPreferredKeySession(t, "cenc", i.pssh, "expired")) : this.warn("Could not renew expired session. Missing pssh initData."), this.removeSession(e) } getKeyIdString(e) { if (!e) throw new Error("Could not read keyId of undefined decryptdata"); if (null === e.keyId) throw new Error("keyId is null"); return Et.hexDump(e.keyId) } updateKeySession(e, t) {
        var r = e.mediaKeysSession; return this.log(`Updating key-session "${r.sessionId}" for keyID ${Et.hexDump((null == (e = e.decryptdata) ? void 0 : e.keyId) || [])}
      } (data length: ${t && t.byteLength})`), r.update(t)
    } selectKeySystemFormat(e) { var t = Object.keys(e.levelkeys || {}); return this.keyFormatPromise || (this.log(`Selecting key-system from fragment (sn: ${e.sn} ${e.type}: ${e.level}) key formats ` + t.join(", ")), this.keyFormatPromise = this.getKeyFormatPromise(t)), this.keyFormatPromise } getKeyFormatPromise(s) { return new Promise((r, i) => { let t = pe(this.config), e = s.map(gs).filter(e => !!e && -1 !== t.indexOf(e)); return this.getKeySystemSelectionPromise(e).then(({ keySystem: e }) => { var t = ms(e); t ? r(t) : i(new Error(`Unable to find format for key-system "${e}"`)) }).catch(i) }) } loadKey(e) { let i = e.keyInfo.decryptdata, t = this.getKeyIdString(i), s = `(keyId: ${t} format: "${i.keyFormat}" method: ${i.method} uri: ${i.uri})`, r = (this.log("Starting session for key " + s), this.keyIdToKeySessionPromise[t]); return r || (r = this.keyIdToKeySessionPromise[t] = this.getKeySystemForKeyPromise(i).then(({ keySystem: t, mediaKeys: r }) => (this.throwIfDestroyed(), this.log(`Handle encrypted media sn: ${e.frag.sn} ${e.frag.type}: ${e.frag.level} using key ` + s), this.attemptSetMediaKeys(t, r).then(() => { this.throwIfDestroyed(); var e = this.createMediaKeySessionContext({ keySystem: t, mediaKeys: r, decryptdata: i }); return this.generateRequestWithPreferredKeySession(e, "cenc", i.pssh, "playlist-key") })))).catch(e => this.handleError(e)), r } throwIfDestroyed(e = 0) { if (!this.hls) throw new Error("invalid state") } handleError(e) { this.hls && (this.error(e.message), e instanceof ut ? this.hls.trigger(m.ERROR, e.data) : this.hls.trigger(m.ERROR, { type: N.KEY_SYSTEM_ERROR, details: L.KEY_SYSTEM_NO_KEYS, error: e, fatal: !0 })) } getKeySystemForKeyPromise(e) { var t = this.getKeyIdString(e), t = this.keyIdToKeySessionPromise[t]; return t || (e = (t = gs(e.keyFormat)) ? [t] : pe(this.config), this.attemptKeySystemAccess(e)) } getKeySystemSelectionPromise(e) { if (0 === (e = e.length ? e : pe(this.config)).length) throw new ut({ type: N.KEY_SYSTEM_ERROR, details: L.KEY_SYSTEM_NO_CONFIGURED_LICENSE, fatal: !0 }, "Missing key-system license configuration options " + JSON.stringify({ drmSystems: this.config.drmSystems })); return this.attemptKeySystemAccess(e) } _onMediaEncrypted(t) { let { initDataType: l, initData: h } = t; if (this.debug(`"${t.type}" event: init data type: "${l}"`), null !== h) { let o, e; if ("sinf" === l && this.config.drmSystems[J.FAIRPLAY]) { t = et(new Uint8Array(h)); try { var r = Qe(JSON.parse(t).sinf), i = Ei(new Uint8Array(r)); if (!i) return; o = i.subarray(8, 24), e = J.FAIRPLAY } catch { return void this.warn('Failed to parse sinf "encrypted" event message initData') } } else { t = Wr(h); if (null === t) return; 0 === t.version && t.systemId === hi.WIDEVINE && t.data && (o = t.data.subarray(8, 24)), e = xr(t.systemId) } if (e && o) { let s = Et.hexDump(o), { keyIdToKeySessionPromise: i, mediaKeySessions: a } = this, n = i[s]; for (let r = 0; r < a.length; r++) { let e = a[r], t = e.decryptdata; if (!t.pssh && t.keyId) { var d = Et.hexDump(t.keyId); if (s === d || -1 !== t.uri.replace(/-/g, "").indexOf(s)) { n = i[d], delete i[d], t.pssh = new Uint8Array(h), t.keyId = o, n = i[s] = n.then(() => this.generateRequestWithPreferredKeySession(e, l, h, "encrypted-event-key-match")); break } } } (n = n || (i[s] = this.getKeySystemSelectionPromise([e]).then(({ keySystem: t, mediaKeys: r }) => { var e; this.throwIfDestroyed(); let i = new Wt("ISO-23001-7", s, null != (e = ms(t)) ? e : ""); return i.pssh = new Uint8Array(h), i.keyId = o, this.attemptSetMediaKeys(t, r).then(() => { this.throwIfDestroyed(); var e = this.createMediaKeySessionContext({ decryptdata: i, keySystem: t, mediaKeys: r }); return this.generateRequestWithPreferredKeySession(e, l, h, "encrypted-event-no-match") }) }))).catch(e => this.handleError(e)) } } } _onWaitingForKey(e) { this.log(`"${e.type}" event`) } attemptSetMediaKeys(e, t) { let r = this.setMediaKeysQueue.slice(), i = (this.log(`Setting media-keys for "${e}"`), Promise.all(r).then(() => { if (this.media) return this.media.setMediaKeys(t); throw new Error("Attempted to set mediaKeys without media element attached") })); return this.setMediaKeysQueue.push(i), i.then(() => { this.log(`Media-keys set for "${e}"`), r.push(i), this.setMediaKeysQueue = this.setMediaKeysQueue.filter(e => -1 === r.indexOf(e)) }) } generateRequestWithPreferredKeySession(i, e, t, r) { var s = null == (s = this.config.drmSystems) || null == (s = s[i.keySystem]) ? void 0 : s.generateRequest; if (s) try { var a = s.call(this.hls, e, t, i); if (!a) throw new Error("Invalid response from configured generateRequest filter"); e = a.initDataType, t = i.decryptdata.pssh = a.initData ? new Uint8Array(a.initData) : null } catch (e) { if (this.warn(e.message), null != (s = this.hls) && s.config.debug) throw e } if (null === t) return this.log(`Skipping key-session request for "${r}" (no initData)`), Promise.resolve(i); let n = this.getKeyIdString(i.decryptdata), o = (this.log(`Generating key-session request for "${r}": ${n} (init data type: ${e} length: ${t ? t.byteLength : null})`), new ls), l = (i.mediaKeysSession.onmessage = e => { var t, r = i.mediaKeysSession; r ? ({ messageType: e, message: t } = e, this.log(`"${e}" message event for session "${r.sessionId}" message size: ` + t.byteLength), "license-request" === e || "license-renewal" === e ? this.renewLicense(i, t).catch(e => { this.handleError(e), o.emit("error", e) }) : "license-release" === e ? i.keySystem === J.FAIRPLAY && (this.updateKeySession(i, ci("acknowledged")), this.removeSession(i)) : this.warn(`unhandled media key message type "${e}"`)) : o.emit("error", new Error("invalid state")) }, i.mediaKeysSession.onkeystatuseschange = e => { var t; i.mediaKeysSession ? (this.onKeyStatusChange(i), t = i.keyStatus, o.emit("keyStatus", t), "expired" === t && (this.warn(i.keySystem + " expired for key " + n), this.renewKeySession(i))) : o.emit("error", new Error("invalid state")) }, new Promise((t, r) => { o.on("error", r), o.on("keyStatus", e => { e.startsWith("usable") ? t() : "output-restricted" === e ? r(new ut({ type: N.KEY_SYSTEM_ERROR, details: L.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED, fatal: !1 }, "HDCP level output restricted")) : "internal-error" === e ? r(new ut({ type: N.KEY_SYSTEM_ERROR, details: L.KEY_SYSTEM_STATUS_INTERNAL_ERROR, fatal: !0 }, `key status changed to "${e}"`)) : "expired" === e ? r(new Error("key expired while generating request")) : this.warn(`unhandled key status change "${e}"`) }) })); return i.mediaKeysSession.generateRequest(e, t).then(() => { var e; this.log(`Request generated for key-session "${null == (e = i.mediaKeysSession) ? void 0 : e.sessionId}" keyId: ` + n) }).catch(e => { throw new ut({ type: N.KEY_SYSTEM_ERROR, details: L.KEY_SYSTEM_NO_SESSION, error: e, fatal: !1 }, "Error generating key-session request: " + e) }).then(() => l).catch(e => { throw o.removeAllListeners(), this.removeSession(i), e }).then(() => (o.removeAllListeners(), i)) } onKeyStatusChange(r) { r.mediaKeysSession.keyStatuses.forEach((e, t) => { this.log(`key status change "${e}" for keyStatuses keyId: ${Et.hexDump("buffer" in t ? new Uint8Array(t.buffer, t.byteOffset, t.byteLength) : new Uint8Array(t))} session keyId: ${Et.hexDump(new Uint8Array(r.decryptdata.keyId || []))} uri: ` + r.decryptdata.uri), r.keyStatus = e }) } fetchServerCertificate(o) { let i = this.config, e = i.loader, l = new e(i), h = this.getServerCertificateUrl(o); return h ? (this.log(`Fetching serverCertificate for "${o}"`), new Promise((s, a) => { let n = { responseType: "arraybuffer", url: h }, e = i.certLoadPolicy.default, t = { loadPolicy: e, timeout: e.maxLoadTimeMs, maxRetry: 0, retryDelay: 0, maxRetryDelay: 0 }, r = { onSuccess: (e, t, r, i) => { s(e.data) }, onError: (e, t, r, i) => { a(new ut({ type: N.KEY_SYSTEM_ERROR, details: L.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED, fatal: !0, networkDetails: r, response: ct({ url: n.url, data: void 0 }, e) }, `"${o}" certificate request failed (${h}). Status: ${e.code} (${e.text})`)) }, onTimeout: (e, t, r) => { a(new ut({ type: N.KEY_SYSTEM_ERROR, details: L.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED, fatal: !0, networkDetails: r, response: { url: n.url, data: void 0 } }, `"${o}" certificate request timed out (${h})`)) }, onAbort: (e, t, r) => { a(new Error("aborted")) } }; l.load(n, t, r) })) : Promise.resolve() } setMediaKeysServerCertificate(i, s, a) { return new Promise((t, r) => { i.setServerCertificate(a).then(e => { this.log(`setServerCertificate ${e ? "success" : "not supported by CDM"} (${null == a ? void 0 : a.byteLength}) on "${s}"`), t(i) }).catch(e => { r(new ut({ type: N.KEY_SYSTEM_ERROR, details: L.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED, error: e, fatal: !0 }, e.message)) }) }) } renewLicense(t, e) { return this.requestLicense(t, new Uint8Array(e)).then(e => this.updateKeySession(t, new Uint8Array(e)).catch(e => { throw new ut({ type: N.KEY_SYSTEM_ERROR, details: L.KEY_SYSTEM_SESSION_UPDATE_FAILED, error: e, fatal: !0 }, e.message) })) } setupLicenseXHR(t, r, i, s) { let a = this.config.licenseXhrSetup; return a ? Promise.resolve().then(() => { if (i.decryptdata) return a.call(this.hls, t, r, i, s); throw new Error("Key removed") }).catch(e => { if (i.decryptdata) return t.open("POST", r, !0), a.call(this.hls, t, r, i, s); throw e }).then(e => (t.readyState || t.open("POST", r, !0), { xhr: t, licenseChallenge: e || s })) : (t.open("POST", r, !0), Promise.resolve({ xhr: t, licenseChallenge: s })) } requestLicense(a, n) { let o = this.config.keyLoadPolicy.default; return new Promise((r, e) => { let i = this.getLicenseServerUrl(a.keySystem), s = (this.log("Sending license request to URL: " + i), new XMLHttpRequest); s.responseType = "arraybuffer", s.onreadystatechange = () => { if (!this.hls || !a.mediaKeysSession) return e(new Error("invalid state")); if (4 === s.readyState) if (200 === s.status) { this._requestLicenseFailureCount = 0; let e = s.response; this.log("License received " + (e instanceof ArrayBuffer ? e.byteLength : e)); var t = this.config.licenseResponseCallback; if (t) try { e = t.call(this.hls, s, i, a) } catch (e) { this.error(e) } r(e) } else { var t = o.errorRetry, t = t ? t.maxNumRetry : 0; this._requestLicenseFailureCount++, this._requestLicenseFailureCount > t || 400 <= s.status && s.status < 500 ? e(new ut({ type: N.KEY_SYSTEM_ERROR, details: L.KEY_SYSTEM_LICENSE_REQUEST_FAILED, fatal: !0, networkDetails: s, response: { url: i, data: void 0, code: s.status, text: s.statusText } }, `License Request XHR failed (${i}). Status: ${s.status} (${s.statusText})`)) : (t = t - this._requestLicenseFailureCount + 1, this.warn(`Retrying license request, ${t} attempts left`), this.requestLicense(a, n).then(r, e)) } }, a.licenseXhr && a.licenseXhr.readyState !== XMLHttpRequest.DONE && a.licenseXhr.abort(), a.licenseXhr = s, this.setupLicenseXHR(s, i, a, n).then(({ xhr: e, licenseChallenge: t }) => { e.send(t) }) }) } onMediaAttached(e, t) { this.config.emeEnabled && (t = t.media, (this.media = t).addEventListener("encrypted", this.onMediaEncrypted), t.addEventListener("waitingforkey", this.onWaitingForKey)) } onMediaDetached() { let t = this.media, e = this.mediaKeySessions, r = (t && (t.removeEventListener("encrypted", this.onMediaEncrypted), t.removeEventListener("waitingforkey", this.onWaitingForKey), this.media = null), this._requestLicenseFailureCount = 0, this.setMediaKeysQueue = [], this.mediaKeySessions = [], this.keyIdToKeySessionPromise = {}, Wt.clearKeyUriToKeyIdMap(), e.length); $t.CDMCleanupPromise = Promise.all(e.map(e => this.removeSession(e)).concat(null == t ? void 0 : t.setMediaKeys(null).catch(e => { this.log(`Could not clear media keys: ${e}. media.src: ` + (null == t ? void 0 : t.src)) }))).then(() => { r && (this.log("finished closing key sessions and clearing media keys"), e.length = 0) }).catch(e => { this.log(`Could not close sessions and clear media keys: ${e}. media.src: ` + (null == t ? void 0 : t.src)) }) } onManifestLoading() { this.keyFormatPromise = null } onManifestLoaded(e, { sessionKeys: t }) { t && this.config.emeEnabled && !this.keyFormatPromise && (t = t.reduce((e, t) => (-1 === e.indexOf(t.keyFormat) && e.push(t.keyFormat), e), []), this.log("Selecting key-system from session-keys " + t.join(", ")), this.keyFormatPromise = this.getKeyFormatPromise(t)) } removeSession(e) { let { mediaKeysSession: t, licenseXhr: r } = e; if (t) return this.log("Remove licenses and keys and close session " + t.sessionId), t.onmessage = null, t.onkeystatuseschange = null, r && r.readyState !== XMLHttpRequest.DONE && r.abort(), e.mediaKeysSession = e.decryptdata = e.licenseXhr = void 0, -1 < (e = this.mediaKeySessions.indexOf(e)) && this.mediaKeySessions.splice(e, 1), t.remove().catch(e => { this.log("Could not remove session: " + e) }).then(() => t.close()).catch(e => { this.log("Could not close session: " + e) }) }
} $t.CDMCleanupPromise = void 0; class ut extends Error { constructor(e, t) { super(t), this.data = void 0, e.error || (e.error = new Error(t)), (this.data = e).err = e.error } } let co = 1; var nt = { MANIFEST: "m", AUDIO: "a", VIDEO: "v", MUXED: "av", INIT: "i", CAPTION: "c", TIMED_TEXT: "tt", KEY: "k", OTHER: "o" }; let ho = "h"; class Dt { constructor(e) { this.hls = void 0, this.config = void 0, this.media = void 0, this.sid = void 0, this.cid = void 0, this.useHeaders = !1, this.initialized = !1, this.starved = !1, this.buffering = !0, this.audioBuffer = void 0, this.videoBuffer = void 0, this.onWaiting = () => { this.initialized && (this.starved = !0), this.buffering = !0 }, this.onPlaying = () => { this.initialized || (this.initialized = !0), this.buffering = !1 }, this.applyPlaylistData = e => { try { this.apply(e, { ot: nt.MANIFEST, su: !this.initialized }) } catch (e) { E.warn("Could not generate manifest CMCD data.", e) } }, this.applyFragmentData = e => { try { var t = e.frag, r = this.hls.levels[t.level], i = this.getObjectType(t), s = { d: 1e3 * t.duration, ot: i }; i !== nt.VIDEO && i !== nt.AUDIO && i != nt.MUXED || (s.br = r.bitrate / 1e3, s.tb = this.getTopBandwidth(i) / 1e3, s.bl = this.getBufferLength(i)), this.apply(e, s) } catch (e) { E.warn("Could not generate segment CMCD data.", e) } }, this.hls = e; var e = this.config = e.config, t = e.cmcd; null != t && (e.pLoader = this.createPlaylistLoader(), e.fLoader = this.createFragmentLoader(), this.sid = t.sessionId || Dt.uuid(), this.cid = t.contentId, this.useHeaders = !0 === t.useHeaders, this.registerListeners()) } registerListeners() { var e = this.hls; e.on(m.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(m.MEDIA_DETACHED, this.onMediaDetached, this), e.on(m.BUFFER_CREATED, this.onBufferCreated, this) } unregisterListeners() { var e = this.hls; e.off(m.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(m.MEDIA_DETACHED, this.onMediaDetached, this), e.off(m.BUFFER_CREATED, this.onBufferCreated, this) } destroy() { this.unregisterListeners(), this.onMediaDetached(), this.hls = this.config = this.audioBuffer = this.videoBuffer = null } onMediaAttached(e, t) { this.media = t.media, this.media.addEventListener("waiting", this.onWaiting), this.media.addEventListener("playing", this.onPlaying) } onMediaDetached() { this.media && (this.media.removeEventListener("waiting", this.onWaiting), this.media.removeEventListener("playing", this.onPlaying), this.media = null) } onBufferCreated(e, t) { var r; this.audioBuffer = null == (r = t.tracks.audio) ? void 0 : r.buffer, this.videoBuffer = null == (r = t.tracks.video) ? void 0 : r.buffer } createData() { var e; return { v: co, sf: ho, sid: this.sid, cid: this.cid, pr: null == (e = this.media) ? void 0 : e.playbackRate, mtp: this.hls.bandwidthEstimate / 1e3 } } apply(e, t = {}) { tt(t, this.createData()); var r = t.ot === nt.INIT || t.ot === nt.VIDEO || t.ot === nt.MUXED; this.starved && r && (t.bs = !0, this.starved = !(t.su = !0)), null == t.su && (t.su = this.buffering), this.useHeaders ? (r = Dt.toHeaders(t), Object.keys(r).length && (e.headers || (e.headers = {}), tt(e.headers, r))) : (r = Dt.toQuery(t)) && (e.url = Dt.appendQueryToUri(e.url, r)) } getObjectType(e) { var t = e.type; return "subtitle" === t ? nt.TIMED_TEXT : "initSegment" === e.sn ? nt.INIT : "audio" === t ? nt.AUDIO : "main" === t ? this.hls.audioTracks.length ? nt.VIDEO : nt.MUXED : void 0 } getTopBandwidth(e) { let t = 0, r; var i, s = this.hls; for (i of r = e === nt.AUDIO ? s.audioTracks : (e = -1 < (e = s.maxAutoLevel) ? e + 1 : s.levels.length, s.levels.slice(0, e))) i.bitrate > t && (t = i.bitrate); return 0 < t ? t : NaN } getBufferLength(e) { var t = this.hls.media, e = e === nt.AUDIO ? this.audioBuffer : this.videoBuffer; return e && t ? 1e3 * q.bufferInfo(e, t.currentTime, this.config.maxBufferHole).len : NaN } createPlaylistLoader() { let e = this.config.pLoader, i = this.applyPlaylistData, t = e || this.config.loader; return class { constructor(e) { this.loader = void 0, this.loader = new t(e) } get stats() { return this.loader.stats } get context() { return this.loader.context } destroy() { this.loader.destroy() } abort() { this.loader.abort() } load(e, t, r) { i(e), this.loader.load(e, t, r) } } } createFragmentLoader() { let e = this.config.fLoader, i = this.applyFragmentData, t = e || this.config.loader; return class { constructor(e) { this.loader = void 0, this.loader = new t(e) } get stats() { return this.loader.stats } get context() { return this.loader.context } destroy() { this.loader.destroy() } abort() { this.loader.abort() } load(e, t, r) { i(e), this.loader.load(e, t, r) } } } static uuid() { var e = URL.createObjectURL(new Blob), t = e.toString(); return URL.revokeObjectURL(e), t.slice(t.lastIndexOf("/") + 1) } static serialize(e) { let r = [], t = e => Math.round(e), i = e => 100 * t(e / 100), s = { br: t, d: t, bl: i, dl: i, mtp: i, nor: e => encodeURIComponent(e), rtp: i, tb: t }, a = Object.keys(e || {}).sort(); for (var n of a) { let t = e[n]; if (o = t, !(Number.isNaN(o) || null == o || "" === o || !1 === o || "v" === n && 1 === t || "pr" == n && 1 === t)) { o = s[n], o = typeof (t = o ? o(t) : t); let e; e = "ot" === n || "sf" === n || "st" === n ? n + "=" + t : "boolean" == o ? n : "number" == o ? n + "=" + t : n + "=" + JSON.stringify(t), r.push(e) } } var o; return r.join(",") } static toHeaders(e) { var t, r = {}, i = ["Object", "Request", "Session", "Status"], s = [{}, {}, {}, {}], a = { br: 0, d: 0, ot: 0, tb: 0, bl: 1, dl: 1, mtp: 1, nor: 1, nrr: 1, su: 1, cid: 2, pr: 2, sf: 2, sid: 2, st: 2, v: 2, bs: 3, rtp: 3 }; for (t of Object.keys(e)) s[null != a[t] ? a[t] : 1][t] = e[t]; for (let e = 0; e < s.length; e++) { var n = Dt.serialize(s[e]); n && (r["CMCD-" + i[e]] = n) } return r } static toQuery(e) { return "CMCD=" + encodeURIComponent(Dt.serialize(e)) } static appendQueryToUri(e, t) { var r; return t ? (r = e.includes("?") ? "&" : "?", e + r + t) : e } } let uo = 3e5; class fo { constructor(e) { this.hls = void 0, this.log = void 0, this.loader = null, this.uri = null, this.pathwayId = ".", this.pathwayPriority = null, this.timeToLoad = 300, this.reloadTimer = -1, this.updated = 0, this.started = !1, this.enabled = !0, this.levels = null, this.audioTracks = null, this.subtitleTracks = null, this.penalizedPathways = {}, this.hls = e, this.log = E.log.bind(E, "[content-steering]:"), this.registerListeners() } registerListeners() { var e = this.hls; e.on(m.MANIFEST_LOADING, this.onManifestLoading, this), e.on(m.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(m.MANIFEST_PARSED, this.onManifestParsed, this), e.on(m.ERROR, this.onError, this) } unregisterListeners() { var e = this.hls; e && (e.off(m.MANIFEST_LOADING, this.onManifestLoading, this), e.off(m.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(m.MANIFEST_PARSED, this.onManifestParsed, this), e.off(m.ERROR, this.onError, this)) } startLoad() { var e; this.started = !0, self.clearTimeout(this.reloadTimer), this.enabled && this.uri && (this.updated ? (e = Math.max(1e3 * this.timeToLoad - (performance.now() - this.updated), 0), this.scheduleRefresh(this.uri, e)) : this.loadSteeringManifest(this.uri)) } stopLoad() { this.started = !1, this.loader && (this.loader.destroy(), this.loader = null), self.clearTimeout(this.reloadTimer) } destroy() { this.unregisterListeners(), this.stopLoad(), this.hls = null, this.levels = this.audioTracks = this.subtitleTracks = null } removeLevel(t) { var e = this.levels; e && (this.levels = e.filter(e => e !== t)) } onManifestLoading() { this.stopLoad(), this.enabled = !0, this.timeToLoad = 300, this.updated = 0, this.uri = null, this.pathwayId = ".", this.levels = this.audioTracks = this.subtitleTracks = null } onManifestLoaded(e, t) { t = t.contentSteering; null !== t && (this.pathwayId = t.pathwayId, this.uri = t.uri, this.started) && this.startLoad() } onManifestParsed(e, t) { this.audioTracks = t.audioTracks, this.subtitleTracks = t.subtitleTracks } onError(e, t) { t = t.errorAction; if ((null == t ? void 0 : t.action) === ot.SendAlternateToPenaltyBox && t.flags === mt.MoveAllAlternatesMatchingHost) { let e = this.pathwayPriority; var r = this.pathwayId; this.penalizedPathways[r] || (this.penalizedPathways[r] = performance.now()), (e = !e && this.levels ? this.levels.reduce((e, t) => (-1 === e.indexOf(t.pathwayId) && e.push(t.pathwayId), e), []) : e) && 1 < e.length && (this.updatePathwayPriority(e), t.resolved = this.pathwayId !== r) } } filterParsedLevels(e) { this.levels = e; let t = this.getLevelsForPathway(this.pathwayId); var r; return 0 === t.length && (r = e[0].pathwayId, this.log(`No levels found in Pathway ${this.pathwayId}. Setting initial Pathway to "${r}"`), t = this.getLevelsForPathway(r), this.pathwayId = r), t.length !== e.length ? (this.log(`Found ${t.length}/${e.length} levels in Pathway "${this.pathwayId}"`), t) : e } getLevelsForPathway(t) { return null === this.levels ? [] : this.levels.filter(e => t === e.pathwayId) } updatePathwayPriority(t) { this.pathwayPriority = t; let r = this.penalizedPathways, i = performance.now(); Object.keys(r).forEach(e => { i - r[e] > uo && delete r[e] }); for (let e = 0; e < t.length; e++) { var s = t[e]; if (!r[s]) { if (s === this.pathwayId) return; var a, n = this.hls.nextLoadLevel, o = this.hls.levels[n]; if (0 < (a = this.getLevelsForPathway(s)).length) { this.log(`Setting Pathway to "${s}"`), this.pathwayId = s, this.hls.trigger(m.LEVELS_UPDATED, { levels: a }); s = this.hls.levels[n]; o && s && this.levels && (s.attrs["STABLE-VARIANT-ID"] !== o.attrs["STABLE-VARIANT-ID"] && s.bitrate !== o.bitrate && this.log(`Unstable Pathways change from bitrate ${o.bitrate} to ` + s.bitrate), this.hls.nextLoadLevel = n); break } } } } clonePathways(e) { let r = this.levels; if (r) { let n = {}, o = {}; e.forEach(e => { let { ID: s, "BASE-ID": t, "URI-REPLACEMENT": a } = e; r.some(e => e.pathwayId === s) || (e = this.getLevelsForPathway(t).map(e => { var t = tt({}, e), e = (t.details = void 0, t.url = sr(e.uri, e.attrs["STABLE-VARIANT-ID"], "PER-VARIANT-URIS", a), new Q(e.attrs)), r = (e["PATHWAY-ID"] = s, e.AUDIO && e.AUDIO + "_clone_" + s), i = e.SUBTITLES && e.SUBTITLES + "_clone_" + s, e = (r && (n[e.AUDIO] = r, e.AUDIO = r), i && (o[e.SUBTITLES] = i, e.SUBTITLES = i), t.attrs = e, new Yt(t)); return ce(e, "audio", r), ce(e, "text", i), e }), r.push(...e), ri(this.audioTracks, n, a, s), ri(this.subtitleTracks, o, a, s)) }) } } loadSteeringManifest(e) { var t = this.hls.config, r = t.loader; this.loader && this.loader.destroy(), this.loader = new r(t); let n; try { n = new self.URL(e) } catch { return this.enabled = !1, void this.log("Failed to parse Steering Manifest URI: " + e) } "data:" !== n.protocol && (r = 0 | (this.hls.bandwidthEstimate || t.abrEwmaDefaultEstimate), n.searchParams.set("_HLS_pathway", this.pathwayId), n.searchParams.set("_HLS_throughput", "" + r)); e = { responseType: "json", url: n.href }, r = t.steeringManifestLoadPolicy.default, t = r.errorRetry || r.timeoutRetry || {}, r = { loadPolicy: r, timeout: r.maxLoadTimeMs, maxRetry: t.maxNumRetry || 0, retryDelay: t.retryDelayMs || 0, maxRetryDelay: t.maxRetryDelayMs || 0 }, t = { onSuccess: (e, t, r, i) => { this.log(`Loaded steering manifest: "${n}"`); e = e.data; if (1 !== e.VERSION) this.log(`Steering VERSION ${e.VERSION} not supported!`); else { this.updated = performance.now(), this.timeToLoad = e.TTL; var { "RELOAD-URI": e, "PATHWAY-CLONES": s, "PATHWAY-PRIORITY": a } = e; if (e) try { this.uri = new self.URL(e, n).href } catch { return this.enabled = !1, void this.log("Failed to parse Steering Manifest RELOAD-URI: " + e) } this.scheduleRefresh(this.uri || r.url), s && this.clonePathways(s), a && this.updatePathwayPriority(a) } }, onError: (t, r, e, i) => { if (this.log(`Error loading steering manifest: ${t.code} ${t.text} (${r.url})`), this.stopLoad(), 410 === t.code) this.enabled = !1, this.log(`Steering manifest ${r.url} no longer available`); else { let e = 1e3 * this.timeToLoad; 429 === t.code ? ("function" == typeof (null == (t = this.loader) ? void 0 : t.getResponseHeader) && (t = t.getResponseHeader("Retry-After")) && (e = 1e3 * parseFloat(t)), this.log(`Steering manifest ${r.url} rate limited`)) : this.scheduleRefresh(this.uri || r.url, e) } }, onTimeout: (e, t, r) => { this.log(`Timeout loading steering manifest (${t.url})`), this.scheduleRefresh(this.uri || t.url) } }; this.log("Requesting steering manifest: " + n), this.loader.load(e, r, t) } scheduleRefresh(e, t = 1e3 * this.timeToLoad) { self.clearTimeout(this.reloadTimer), this.reloadTimer = self.setTimeout(() => { this.loadSteeringManifest(e) }, t) } } function ri(t, i, s, a) { t && Object.keys(i).forEach(r => { var e = t.filter(e => e.groupId === r).map(e => { var t = tt({}, e); return t.details = void 0, t.attrs = new Q(t.attrs), t.url = t.attrs.URI = sr(e.url, e.attrs["STABLE-RENDITION-ID"], "PER-RENDITION-URIS", s), t.groupId = t.attrs["GROUP-ID"] = i[r], t.attrs["PATHWAY-ID"] = a, t }); t.push(...e) }) } function sr(e, t, r, i) { let { HOST: s, PARAMS: a, [r]: n } = i, o, l = (t && (o = null == n ? void 0 : n[t]) && (e = o), new self.URL(e)); return s && !o && (l.host = s), a && Object.keys(a).sort().forEach(e => { e && l.searchParams.set(e, a[e]) }), l.href } let go = /^age:\s*[\d.]+\s*$/im; class ir { constructor(e) { this.xhrSetup = void 0, this.requestTimeout = void 0, this.retryTimeout = void 0, this.retryDelay = void 0, this.config = null, this.callbacks = null, this.context = void 0, this.loader = null, this.stats = void 0, this.xhrSetup = e && e.xhrSetup || null, this.stats = new de, this.retryDelay = 0 } destroy() { this.callbacks = null, this.abortInternal(), this.loader = null, this.config = null } abortInternal() { var e = this.loader; self.clearTimeout(this.requestTimeout), self.clearTimeout(this.retryTimeout), e && (e.onreadystatechange = null, e.onprogress = null, 4 !== e.readyState) && (this.stats.aborted = !0, e.abort()) } abort() { var e; this.abortInternal(), null != (e = this.callbacks) && e.onAbort && this.callbacks.onAbort(this.stats, this.context, this.loader) } load(e, t, r) { if (this.stats.loading.start) throw new Error("Loader can only be used once."); this.stats.loading.start = self.performance.now(), this.context = e, this.config = t, this.callbacks = r, this.loadInternal() } loadInternal() { let { config: e, context: s } = this; if (e) { let t = this.loader = new self.XMLHttpRequest, r = this.stats, i = (r.loading.first = 0, r.loaded = 0, this.xhrSetup); i ? Promise.resolve().then(() => { if (!this.stats.aborted) return i(t, s.url) }).catch(e => (t.open("GET", s.url, !0), i(t, s.url))).then(() => { this.stats.aborted || this.openAndSendXhr(t, s, e) }).catch(e => { this.callbacks.onError({ code: t.status, text: e.message }, s, t, r) }) : this.openAndSendXhr(t, s, e) } } openAndSendXhr(e, t, r) { e.readyState || e.open("GET", t.url, !0); var i = this.context.headers, { maxTimeToFirstByteMs: s, maxLoadTimeMs: a } = r.loadPolicy; if (i) for (var n in i) e.setRequestHeader(n, i[n]); t.rangeEnd && e.setRequestHeader("Range", "bytes=" + t.rangeStart + "-" + (t.rangeEnd - 1)), e.onreadystatechange = this.readystatechange.bind(this), e.onprogress = this.loadprogress.bind(this), e.responseType = t.responseType, self.clearTimeout(this.requestTimeout), r.timeout = s && F(s) ? s : a, this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), r.timeout), e.send() } readystatechange() { var e, t, r, i, { context: s, loader: a, stats: n } = this; s && a && (t = a.readyState, e = this.config, !n.aborted) && 2 <= t && (0 === n.loading.first && (n.loading.first = Math.max(self.performance.now(), n.loading.start), e.timeout !== e.loadPolicy.maxLoadTimeMs) && (self.clearTimeout(this.requestTimeout), e.timeout = e.loadPolicy.maxLoadTimeMs, this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), e.loadPolicy.maxLoadTimeMs - (n.loading.first - n.loading.start))), 4 === t) && (self.clearTimeout(this.requestTimeout), a.onreadystatechange = null, a.onprogress = null, t = a.status, i = "text" !== a.responseType, 200 <= t && t < 300 && (i && a.response || null !== a.responseText) ? (n.loading.end = Math.max(self.performance.now(), n.loading.first), i = i ? a.response : a.responseText, r = "arraybuffer" === a.responseType ? i.byteLength : i.length, n.loaded = n.total = r, n.bwEstimate = 8e3 * n.total / (n.loading.end - n.loading.first), this.callbacks && ((r = this.callbacks.onProgress) && r(n, s, i, a), this.callbacks) && (r = { url: a.responseURL, data: i, code: t }, this.callbacks.onSuccess(r, n, s, a))) : le(i = e.loadPolicy.errorRetry, n.retry, !1, t) ? this.retry(i) : (E.error(t + " while loading " + s.url), this.callbacks.onError({ code: t, text: a.statusText }, s, a, n))) } loadtimeout() { var e = null == (e = this.config) ? void 0 : e.loadPolicy.timeoutRetry; le(e, this.stats.retry, !0) ? this.retry(e) : (E.warn("timeout while loading " + this.context.url), (e = this.callbacks) && (this.abortInternal(), e.onTimeout(this.stats, this.context, this.loader))) } retry(e) { var { context: t, stats: r } = this; this.retryDelay = Ze(e, r.retry), r.retry++, E.warn(`${status ? "HTTP Status " + status : "Timeout"} while loading ${t.url}, retrying ${r.retry}/${e.maxNumRetry} in ${this.retryDelay}ms`), this.abortInternal(), this.loader = null, self.clearTimeout(this.retryTimeout), this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay) } loadprogress(e) { var t = this.stats; t.loaded = e.loaded, e.lengthComputable && (t.total = e.total) } getCacheAge() { let e = null; var t; return this.loader && go.test(this.loader.getAllResponseHeaders()) && (t = this.loader.getResponseHeader("age"), e = t ? parseFloat(t) : null), e } getResponseHeader(e) { return this.loader && new RegExp(`^${e}:\\s*[\\d.]+\\s*$`, "im").test(this.loader.getAllResponseHeaders()) ? this.loader.getResponseHeader(e) : null } } function mo() { if (self.fetch && self.AbortController && self.ReadableStream && self.Request) try { return new self.ReadableStream({}), !0 } catch { } return !1 } let po = /(\d+)-(\d+)\/(\d+)/; class ni { constructor(e) { this.fetchSetup = void 0, this.requestTimeout = void 0, this.request = void 0, this.response = void 0, this.controller = void 0, this.context = void 0, this.config = null, this.callbacks = null, this.stats = void 0, this.loader = null, this.fetchSetup = e.fetchSetup || xo, this.controller = new self.AbortController, this.stats = new de } destroy() { this.loader = this.callbacks = null, this.abortInternal() } abortInternal() { var e = this.response; null != e && e.ok || (this.stats.aborted = !0, this.controller.abort()) } abort() { var e; this.abortInternal(), null != (e = this.callbacks) && e.onAbort && this.callbacks.onAbort(this.stats, this.context, this.response) } load(i, s, a) { let n = this.stats; if (n.loading.start) throw new Error("Loader can only be used once."); n.loading.start = self.performance.now(); let e = To(i, this.controller.signal), o = a.onProgress, l = "arraybuffer" === i.responseType, h = l ? "byteLength" : "length", { maxTimeToFirstByteMs: t, maxLoadTimeMs: d } = s.loadPolicy; this.context = i, this.config = s, this.callbacks = a, this.request = this.fetchSetup(i, e), self.clearTimeout(this.requestTimeout), s.timeout = t && F(t) ? t : d, this.requestTimeout = self.setTimeout(() => { this.abortInternal(), a.onTimeout(n, i, this.response) }, s.timeout), self.fetch(this.request).then(e => { this.response = this.loader = e; var t, r = Math.max(self.performance.now(), n.loading.start); if (self.clearTimeout(this.requestTimeout), s.timeout = d, this.requestTimeout = self.setTimeout(() => { this.abortInternal(), a.onTimeout(n, i, this.response) }, d - (r - n.loading.start)), e.ok) return n.loading.first = r, n.total = Eo(e.headers) || n.total, o && F(s.highWaterMark) ? this.loadProgressively(e, n, i, s.highWaterMark, o) : l ? e.arrayBuffer() : "json" === i.responseType ? e.json() : e.text(); throw { status: r, statusText: t } = e, new So(t || "fetch, bad network response", r, e) }).then(e => { var t = this.response, r = (self.clearTimeout(this.requestTimeout), n.loading.end = Math.max(self.performance.now(), n.loading.first), e[h]), r = (r && (n.loaded = n.total = r), { url: t.url, data: e, code: t.status }); o && !F(s.highWaterMark) && o(n, i, e, t), a.onSuccess(r, n, i, t) }).catch(e => { var t, r; self.clearTimeout(this.requestTimeout), n.aborted || (t = e && e.code || 0, r = e ? e.message : null, a.onError({ code: t, text: r }, i, e ? e.details : null, n)) }) } getCacheAge() { let e = null; var t; return this.response && (t = this.response.headers.get("age"), e = t ? parseFloat(t) : null), e } getResponseHeader(e) { return this.response ? this.response.headers.get(e) : null } loadProgressively(r, i, s, a = 0, n) { let o = new Yi, e = r.body.getReader(), l = () => e.read().then(e => { var t; return e.done ? (o.dataLength && n(i, s, o.flush(), r), Promise.resolve(new ArrayBuffer(0))) : (t = (e = e.value).length, i.loaded += t, t < a || o.dataLength ? (o.push(e), o.dataLength >= a && n(i, s, o.flush(), r)) : n(i, s, e, r), l()) }).catch(() => Promise.reject()); return l() } } function To(e, t) { t = { method: "GET", mode: "cors", credentials: "same-origin", signal: t, headers: new self.Headers(tt({}, e.headers)) }; return e.rangeEnd && t.headers.set("Range", "bytes=" + e.rangeStart + "-" + String(e.rangeEnd - 1)), t } function yo(e) { e = po.exec(e); if (e) return parseInt(e[2]) - parseInt(e[1]) + 1 } function Eo(e) { var t = e.get("Content-Range"); if (t) { t = yo(t); if (F(t)) return t } t = e.get("Content-Length"); if (t) return parseInt(t) } function xo(e, t) { return new self.Request(e.url, t) } class So extends Error { constructor(e, t, r) { super(e), this.code = void 0, this.details = void 0, this.code = t, this.details = r } } let vo = /\s/, Ao = { newCue(t, r, i, s) { var a = []; let n, o, l, h, d; var u, c = self.VTTCue || self.TextTrackCue; for (let e = 0; e < s.rows.length; e++)if (n = s.rows[e], l = !0, h = 0, d = "", !n.isEmpty()) { for (let e = 0; e < n.chars.length; e++)vo.test(n.chars[e].uchar) && l ? h++ : (d += n.chars[e].uchar, l = !1); (n.cueStartTime = r) === i && (i += 1e-4), 16 <= h ? h-- : h++; var f = Ji(d.trim()), g = hs(r, i, f); null != t && null != (u = t.cues) && u.getCueById(g) || ((o = new c(r, i, f)).id = g, o.line = e + 1, o.align = "left", o.position = 10 + Math.min(80, 10 * Math.floor(8 * h / 32)), a.push(o)) } return t && a.length && (a.sort((e, t) => "auto" === e.line || "auto" === t.line ? 0 : 8 < e.line && 8 < t.line ? t.line - e.line : e.line - t.line), a.forEach(e => Li(t, e))), a } }, Lo = { maxTimeToFirstByteMs: 8e3, maxLoadTimeMs: 2e4, timeoutRetry: null, errorRetry: null }, Ro = ct(ct({ autoStartLoad: !0, startPosition: -1, defaultAudioCodec: void 0, debug: !1, capLevelOnFPSDrop: !1, capLevelToPlayerSize: !1, ignoreDevicePixelRatio: !1, initialLiveManifestSize: 1, maxBufferLength: 30, backBufferLength: 1 / 0, maxBufferSize: 6e7, maxBufferHole: .1, highBufferWatchdogPeriod: 2, nudgeOffset: .1, nudgeMaxRetry: 3, maxFragLookUpTolerance: .25, liveSyncDurationCount: 3, liveMaxLatencyDurationCount: 1 / 0, liveSyncDuration: void 0, liveMaxLatencyDuration: void 0, maxLiveSyncPlaybackRate: 1, liveDurationInfinity: !1, liveBackBufferLength: null, maxMaxBufferLength: 600, enableWorker: !0, workerPath: null, enableSoftwareAES: !0, startLevel: void 0, startFragPrefetch: !1, fpsDroppedMonitoringPeriod: 5e3, fpsDroppedMonitoringThreshold: .2, appendErrorMaxRetry: 3, loader: ir, fLoader: void 0, pLoader: void 0, xhrSetup: void 0, licenseXhrSetup: void 0, licenseResponseCallback: void 0, abrController: Da, bufferController: Na, capLevelController: ds, errorController: xn, fpsController: lo, stretchShortVideoTrack: !1, maxAudioFramesDrift: 1, forceKeyFrameOnDiscontinuity: !0, abrEwmaFastLive: 3, abrEwmaSlowLive: 9, abrEwmaFastVoD: 3, abrEwmaSlowVoD: 9, abrEwmaDefaultEstimate: 5e5, abrBandWidthFactor: .95, abrBandWidthUpFactor: .7, abrMaxWithRealBitrate: !1, maxStarvationDelay: 4, maxLoadingDelay: 4, minAutoBitrate: 0, emeEnabled: !1, widevineLicenseUrl: void 0, drmSystems: {}, drmSystemOptions: {}, requestMediaKeySystemAccessFunc: di, testBandwidth: !0, progressive: !1, lowLatencyMode: !0, cmcd: void 0, enableDateRangeMetadataCues: !0, enableEmsgMetadataCues: !0, enableID3MetadataCues: !0, certLoadPolicy: { default: Lo }, keyLoadPolicy: { default: { maxTimeToFirstByteMs: 8e3, maxLoadTimeMs: 2e4, timeoutRetry: { maxNumRetry: 1, retryDelayMs: 1e3, maxRetryDelayMs: 2e4, backoff: "linear" }, errorRetry: { maxNumRetry: 8, retryDelayMs: 1e3, maxRetryDelayMs: 2e4, backoff: "linear" } } }, manifestLoadPolicy: { default: { maxTimeToFirstByteMs: 1 / 0, maxLoadTimeMs: 2e4, timeoutRetry: { maxNumRetry: 2, retryDelayMs: 0, maxRetryDelayMs: 0 }, errorRetry: { maxNumRetry: 1, retryDelayMs: 1e3, maxRetryDelayMs: 8e3 } } }, playlistLoadPolicy: { default: { maxTimeToFirstByteMs: 1e4, maxLoadTimeMs: 2e4, timeoutRetry: { maxNumRetry: 2, retryDelayMs: 0, maxRetryDelayMs: 0 }, errorRetry: { maxNumRetry: 2, retryDelayMs: 1e3, maxRetryDelayMs: 8e3 } } }, fragLoadPolicy: { default: { maxTimeToFirstByteMs: 1e4, maxLoadTimeMs: 12e4, timeoutRetry: { maxNumRetry: 4, retryDelayMs: 0, maxRetryDelayMs: 0 }, errorRetry: { maxNumRetry: 6, retryDelayMs: 1e3, maxRetryDelayMs: 8e3 } } }, steeringManifestLoadPolicy: { default: { maxTimeToFirstByteMs: 1e4, maxLoadTimeMs: 2e4, timeoutRetry: { maxNumRetry: 2, retryDelayMs: 0, maxRetryDelayMs: 0 }, errorRetry: { maxNumRetry: 1, retryDelayMs: 1e3, maxRetryDelayMs: 8e3 } } }, manifestLoadingTimeOut: 1e4, manifestLoadingMaxRetry: 1, manifestLoadingRetryDelay: 1e3, manifestLoadingMaxRetryTimeout: 64e3, levelLoadingTimeOut: 1e4, levelLoadingMaxRetry: 4, levelLoadingRetryDelay: 1e3, levelLoadingMaxRetryTimeout: 64e3, fragLoadingTimeOut: 2e4, fragLoadingMaxRetry: 6, fragLoadingRetryDelay: 1e3, fragLoadingMaxRetryTimeout: 64e3 }, Io()), {}, { subtitleStreamController: Pa, subtitleTrackController: Oa, timelineController: no, audioStreamController: ka, audioTrackController: _a, emeController: $t, cmcdController: Dt, contentSteeringController: fo }); function Io() { return { cueHandler: Ao, enableWebVTT: !0, enableIMSC1: !0, enableCEA708Captions: !0, captionsTextTrack1Label: "English", captionsTextTrack1LanguageCode: "en", captionsTextTrack2Label: "Spanish", captionsTextTrack2LanguageCode: "es", captionsTextTrack3Label: "Unknown CC", captionsTextTrack3LanguageCode: "", captionsTextTrack4Label: "Unknown CC", captionsTextTrack4LanguageCode: "", renderTextTracksNatively: !0 } } function bo(e, l) { if ((l.liveSyncDurationCount || l.liveMaxLatencyDurationCount) && (l.liveSyncDuration || l.liveMaxLatencyDuration)) throw new Error("Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration"); if (void 0 !== l.liveMaxLatencyDurationCount && (void 0 === l.liveSyncDurationCount || l.liveMaxLatencyDurationCount <= l.liveSyncDurationCount)) throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be greater than "liveSyncDurationCount"'); if (void 0 !== l.liveMaxLatencyDuration && (void 0 === l.liveSyncDuration || l.liveMaxLatencyDuration <= l.liveSyncDuration)) throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be greater than "liveSyncDuration"'); let h = je(e), t = ["TimeOut", "MaxRetry", "RetryDelay", "MaxRetryTimeout"]; return ["manifest", "level", "frag"].forEach(s => { let a = `${"level" === s ? "playlist" : s}LoadPolicy`, n = void 0 === l[a], o = []; t.forEach(e => { var t = s + "Loading" + e, r = l[t]; if (void 0 !== r && n) { o.push(t); var i = h[a].default; switch (l[a] = { default: i }, e) { case "TimeOut": i.maxLoadTimeMs = r, i.maxTimeToFirstByteMs = r; break; case "MaxRetry": i.errorRetry.maxNumRetry = r, i.timeoutRetry.maxNumRetry = r; break; case "RetryDelay": i.errorRetry.retryDelayMs = r, i.timeoutRetry.retryDelayMs = r; break; case "MaxRetryTimeout": i.errorRetry.maxRetryDelayMs = r, i.timeoutRetry.maxRetryDelayMs = r } } }), o.length && E.warn(`hls.js config: "${o.join('", "')}" setting(s) are deprecated, use "${a}": ` + JSON.stringify(l[a])) }), ct(ct({}, h), l) } function je(r) { return r && "object" == typeof r ? Array.isArray(r) ? r.map(je) : Object.keys(r).reduce((e, t) => (e[t] = je(r[t]), e), {}) : r } function Do(e) { var t = e.loader; t !== ni && t !== ir ? (E.log("[config]: Custom loader detected, cannot enable progressive streaming"), e.progressive = !1) : mo() && (e.loader = ni, e.progressive = !0, e.enableSoftwareAES = !0, E.log("[config]: Progressive streaming enabled, using FetchLoader")) } class Rt { static get version() { return "1.4.4" } static isSupported() { return Bn() } static get Events() { return m } static get ErrorTypes() { return N } static get ErrorDetails() { return L } static get DefaultConfig() { return Rt.defaultConfig || Ro } static set DefaultConfig(e) { Rt.defaultConfig = e } constructor(e = {}) { this.config = void 0, this.userConfig = void 0, this.coreComponents = void 0, this.networkControllers = void 0, this._emitter = new ls, this._autoLevelCapping = void 0, this._maxHdcpLevel = null, this.abrController = void 0, this.bufferController = void 0, this.capLevelController = void 0, this.latencyController = void 0, this.levelController = void 0, this.streamController = void 0, this.audioTrackController = void 0, this.subtitleTrackController = void 0, this.emeController = void 0, this.cmcdController = void 0, this._media = null, this.url = null, hr(e.debug || !1, "Hls instance"); var t = this.config = bo(Rt.DefaultConfig, e), { abrController: e, bufferController: r, capLevelController: i, errorController: s, fpsController: a } = (this.userConfig = e, this._autoLevelCapping = -1, t.progressive && Do(t), t), s = new s(this), e = this.abrController = new e(this), r = this.bufferController = new r(this), i = this.capLevelController = new i(this), a = new a(this), n = new tn(this), o = new an(this), l = t.contentSteeringController, l = l ? new l(this) : null, h = this.levelController = new vn(this, l), d = new An(this), u = new Rn(this.config), c = this.streamController = new Ia(this, d, u), n = (i.setStreamController(c), a.setStreamController(c), [n, h, c]), h = (l && n.splice(1, 0, l), this.networkControllers = n, [e, r, i, a, o, d]), c = (this.audioTrackController = this.createController(t.audioTrackController, n), t.audioStreamController), l = (c && n.push(new c(this, d, u)), this.subtitleTrackController = this.createController(t.subtitleTrackController, n), t.subtitleStreamController), e = (l && n.push(new l(this, d, u)), this.createController(t.timelineController, h), u.emeController = this.emeController = this.createController(t.emeController, h), this.cmcdController = this.createController(t.cmcdController, h), this.latencyController = this.createController(on, h), this.coreComponents = h, n.push(s), s.onErrorOut); "function" == typeof e && this.on(m.ERROR, e, s) } createController(e, t) { return e ? (e = new e(this), t && t.push(e), e) : null } on(e, t, r = this) { this._emitter.on(e, t, r) } once(e, t, r = this) { this._emitter.once(e, t, r) } removeAllListeners(e) { this._emitter.removeAllListeners(e) } off(e, t, r = this, i) { this._emitter.off(e, t, r, i) } listeners(e) { return this._emitter.listeners(e) } emit(e, t, r) { return this._emitter.emit(e, t, r) } trigger(t, e) { if (this.config.debug) return this.emit(t, t, e); try { return this.emit(t, t, e) } catch (e) { E.error("An internal error happened while handling event " + t + '. Error message: "' + e.message + '". Here is a stacktrace:', e), this.trigger(m.ERROR, { type: N.OTHER_ERROR, details: L.INTERNAL_EXCEPTION, fatal: !1, event: t, error: e }) } return !1 } listenerCount(e) { return this._emitter.listenerCount(e) } destroy() { E.log("destroy"), this.trigger(m.DESTROYING, void 0), this.detachMedia(), this.removeAllListeners(), this._autoLevelCapping = -1, this.url = null, this.networkControllers.forEach(e => e.destroy()), this.networkControllers.length = 0, this.coreComponents.forEach(e => e.destroy()), this.coreComponents.length = 0; var e = this.config; e.xhrSetup = e.fetchSetup = void 0, this.userConfig = null } attachMedia(e) { E.log("attachMedia"), this._media = e, this.trigger(m.MEDIA_ATTACHING, { media: e }) } detachMedia() { E.log("detachMedia"), this.trigger(m.MEDIA_DETACHING, void 0), this._media = null } loadSource(e) { this.stopLoad(); var t = this.media, r = this.url, i = this.url = ze.buildAbsoluteURL(self.location.href, e, { alwaysNormalize: !0 }); E.log("loadSource:" + i), t && r && (r !== i || this.bufferController.hasSourceTypes()) && (this.detachMedia(), this.attachMedia(t)), this.trigger(m.MANIFEST_LOADING, { url: e }) } startLoad(t = -1) { E.log(`startLoad(${t})`), this.networkControllers.forEach(e => { e.startLoad(t) }) } stopLoad() { E.log("stopLoad"), this.networkControllers.forEach(e => { e.stopLoad() }) } swapAudioCodec() { E.log("swapAudioCodec"), this.streamController.swapAudioCodec() } recoverMediaError() { E.log("recoverMediaError"); var e = this._media; this.detachMedia(), e && this.attachMedia(e) } removeLevel(e, t = 0) { this.levelController.removeLevel(e, t) } get levels() { return this.levelController.levels || [] } get currentLevel() { return this.streamController.currentLevel } set currentLevel(e) { E.log("set currentLevel:" + e), this.loadLevel = e, this.abrController.clearTimer(), this.streamController.immediateLevelSwitch() } get nextLevel() { return this.streamController.nextLevel } set nextLevel(e) { E.log("set nextLevel:" + e), this.levelController.manualLevel = e, this.streamController.nextLevelSwitch() } get loadLevel() { return this.levelController.level } set loadLevel(e) { E.log("set loadLevel:" + e), this.levelController.manualLevel = e } get nextLoadLevel() { return this.levelController.nextLoadLevel } set nextLoadLevel(e) { this.levelController.nextLoadLevel = e } get firstLevel() { return Math.max(this.levelController.firstLevel, this.minAutoLevel) } set firstLevel(e) { E.log("set firstLevel:" + e), this.levelController.firstLevel = e } get startLevel() { return this.levelController.startLevel } set startLevel(e) { E.log("set startLevel:" + e), -1 !== e && (e = Math.max(e, this.minAutoLevel)), this.levelController.startLevel = e } get capLevelToPlayerSize() { return this.config.capLevelToPlayerSize } set capLevelToPlayerSize(e) { e = !!e; e !== this.config.capLevelToPlayerSize && (e ? this.capLevelController.startCapping() : (this.capLevelController.stopCapping(), this.autoLevelCapping = -1, this.streamController.nextLevelSwitch()), this.config.capLevelToPlayerSize = e) } get autoLevelCapping() { return this._autoLevelCapping } get bandwidthEstimate() { var e = this.abrController.bwEstimator; return e ? e.getEstimate() : NaN } get ttfbEstimate() { var e = this.abrController.bwEstimator; return e ? e.getEstimateTTFB() : NaN } set autoLevelCapping(e) { this._autoLevelCapping !== e && (E.log("set autoLevelCapping:" + e), this._autoLevelCapping = e) } get maxHdcpLevel() { return this._maxHdcpLevel } set maxHdcpLevel(e) { -1 < He.indexOf(e) && (this._maxHdcpLevel = e) } get autoLevelEnabled() { return -1 === this.levelController.manualLevel } get manualLevel() { return this.levelController.manualLevel } get minAutoLevel() { var { levels: t, config: { minAutoBitrate: r } } = this; if (t) { var i = t.length; for (let e = 0; e < i; e++)if (t[e].maxBitrate >= r) return e } return 0 } get maxAutoLevel() { var { levels: t, autoLevelCapping: e, maxHdcpLevel: r } = this; let i; if (i = -1 === e && t && t.length ? t.length - 1 : e, r) for (let e = i; e--;) { var s = t[e].attrs["HDCP-LEVEL"]; if (s && s <= r) return e } return i } get nextAutoLevel() { return Math.min(Math.max(this.abrController.nextAutoLevel, this.minAutoLevel), this.maxAutoLevel) } set nextAutoLevel(e) { this.abrController.nextAutoLevel = Math.max(this.minAutoLevel, e) } get playingDate() { return this.streamController.currentProgramDateTime } get mainForwardBufferInfo() { return this.streamController.getMainFwdBufferInfo() } get audioTracks() { var e = this.audioTrackController; return e ? e.audioTracks : [] } get audioTrack() { var e = this.audioTrackController; return e ? e.audioTrack : -1 } set audioTrack(e) { var t = this.audioTrackController; t && (t.audioTrack = e) } get subtitleTracks() { var e = this.subtitleTrackController; return e ? e.subtitleTracks : [] } get subtitleTrack() { var e = this.subtitleTrackController; return e ? e.subtitleTrack : -1 } get media() { return this._media } set subtitleTrack(e) { var t = this.subtitleTrackController; t && (t.subtitleTrack = e) } get subtitleDisplay() { var e = this.subtitleTrackController; return !!e && e.subtitleDisplay } set subtitleDisplay(e) { var t = this.subtitleTrackController; t && (t.subtitleDisplay = e) } get lowLatencyMode() { return this.config.lowLatencyMode } set lowLatencyMode(e) { this.config.lowLatencyMode = e } get liveSyncPosition() { return this.latencyController.liveSyncPosition } get latency() { return this.latencyController.latency } get maxLatency() { return this.latencyController.maxLatency } get targetLatency() { return this.latencyController.targetLatency } get drift() { return this.latencyController.drift } get forceStartLoad() { return this.streamController.forceStartLoad } } Rt.defaultConfig = void 0; let Kt = document.getElementById("stream-select"), Xe = document.getElementById("country-select"), Ut = document.getElementById("video"); fetch("https://api.github.com/repos/iptv-org/iptv/contents/streams").then(async e => { (await e.json()).forEach(({ name: e, path: t }) => { e = new Option(e.replace(".m3u", ""), t); Xe.add(e) }) }), Xe.addEventListener("change", () => {
    fetch("https://raw.githubusercontent.com/iptv-org/iptv/master/" + Xe.value).then(async e => {
        var t = (await e.text()).split(`
`), r = []; for (let e = 0; e < t.length; e++) { var i, s = t[e]; s.startsWith("#EXTINF") && (s = s.split(",")[1], i = t[e + 1].trim(), r.push({ title: s, link: i }), e++) } Kt.innerHTML = "<option>Select stream</option>", r.forEach(({ title: e, link: t }) => { e = new Option(e, t); Kt.add(e) }), Kt.style.display = "block"
    }), Kt.addEventListener("change", e => { e.preventDefault(); var t, e = Kt.value; Rt.isSupported() ? ((t = new Rt).loadSource(e), t.attachMedia(Ut), t.on(Rt.Events.MANIFEST_PARSED, () => { Ut.play() })) : Ut.canPlayType("application/vnd.apple.mpegurl") && (Ut.src = e, Ut.addEventListener("loadedmetadata", () => { Ut.play() })) })
});